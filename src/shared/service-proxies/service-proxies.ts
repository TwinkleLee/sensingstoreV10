/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonateExtra(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImpersonateExtra";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateExtra(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonateExtra(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AdServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditStatus (optional) 
     * @param tagId (optional) 
     * @param isCustom (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAds(auditStatus: AuditStatus | undefined, tagId: number | null | undefined, isCustom: boolean | null | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAds?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagId !== undefined && tagId !== null)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (isCustom !== undefined && isCustom !== null)
            url_ += "IsCustom=" + encodeURIComponent("" + isCustom) + "&";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAds(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAds(response: HttpResponseBase): Observable<PagedResultDtoOfAdListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdListDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param tagId (optional) 
     * @param isCustom (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsToExcel(status: AuditStatus | undefined, tagId: number | null | undefined, isCustom: boolean | null | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAdsToExcel?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (tagId !== undefined && tagId !== null)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (isCustom !== undefined && isCustom !== null)
            url_ += "IsCustom=" + encodeURIComponent("" + isCustom) + "&";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleAd(id: number | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSingleAd?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAd(body: CreateAdInput | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/CreateAd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * @param adId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdResources(adId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdResourcesFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetAdResources?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdResources(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdResourcesFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdResourcesFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdResources(response: HttpResponseBase): Observable<PagedResultDtoOfAdResourcesFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdResourcesFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdResourcesFileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAdResource(body: AddAdResourceFileInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddAdResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAdResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAdResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAdResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAdResource(body: AddAdResourceFileInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateAdResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteAdResources(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAdResources?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAdResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAd(body: UpdateAdInput | undefined): Observable<AdDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateAd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAd(<any>response_);
                } catch (e) {
                    return <Observable<AdDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAd(response: HttpResponseBase): Observable<AdDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAd(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAd?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteAdByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteAdByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAdByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAdByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAdByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleProgramScheduling(id: number | undefined): Observable<GetAdSchedulingDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSingleProgramScheduling?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProgramScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProgramScheduling(<any>response_);
                } catch (e) {
                    return <Observable<GetAdSchedulingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAdSchedulingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProgramScheduling(response: HttpResponseBase): Observable<GetAdSchedulingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAdSchedulingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAdSchedulingDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSchedulings(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAdSchedulingDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetSchedulings?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAdSchedulingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAdSchedulingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSchedulings(response: HttpResponseBase): Observable<PagedResultDtoOfGetAdSchedulingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAdSchedulingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAdSchedulingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateScheduling(body: AddOrUpdateAdSchedulingInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddOrUpdateScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateScheDulingContent(body: SchedulingContentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateScheDulingContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheDulingContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheDulingContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheDulingContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateScheDulingContent(body: SchedulingContent | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddOrUpdateScheDulingContent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateScheDulingContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateScheDulingContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateScheDulingContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addContentToScheduling(body: PublishContentToAdScheduling | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/AddContentToScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddContentToScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddContentToScheduling(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddContentToScheduling(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param adSchedulingId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @return Success
     */
    getScheduleCalendar(adSchedulingId: number | undefined, startTime: DateTime | undefined, endTime: DateTime | undefined): Observable<ScheduleCalendarDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetScheduleCalendar?";
        if (adSchedulingId === null)
            throw new Error("The parameter 'adSchedulingId' cannot be null.");
        else if (adSchedulingId !== undefined)
            url_ += "AdSchedulingId=" + encodeURIComponent("" + adSchedulingId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetScheduleCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetScheduleCalendar(<any>response_);
                } catch (e) {
                    return <Observable<ScheduleCalendarDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScheduleCalendarDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetScheduleCalendar(response: HttpResponseBase): Observable<ScheduleCalendarDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScheduleCalendarDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScheduleCalendarDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateScheduleCalendar(body: SchedulingContentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateScheduleCalendar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateScheduleCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateScheduleCalendar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateScheduleCalendar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSchedulingContents(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteSchedulingContents?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSchedulingContents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSchedulingContents(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSchedulingContents(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param adSchedulingId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProgramsIn24HoursList(adSchedulingId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetProgramsIn24HoursDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetProgramsIn24HoursList?";
        if (adSchedulingId !== undefined && adSchedulingId !== null)
            url_ += "AdSchedulingId=" + encodeURIComponent("" + adSchedulingId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramsIn24HoursList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramsIn24HoursList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProgramsIn24HoursDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProgramsIn24HoursDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramsIn24HoursList(response: HttpResponseBase): Observable<PagedResultDtoOfGetProgramsIn24HoursDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProgramsIn24HoursDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProgramsIn24HoursDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSchedulings(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteSchedulings?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSchedulings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishSchedulingToDevice(body: PublishAdScheduliingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishSchedulingToDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSchedulingToDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSchedulingToDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSchedulingToDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceSchedulings(deviceId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetDeviceSchedulingDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetDeviceSchedulings?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceSchedulings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceSchedulings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDeviceSchedulingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDeviceSchedulingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceSchedulings(response: HttpResponseBase): Observable<PagedResultDtoOfGetDeviceSchedulingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDeviceSchedulingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDeviceSchedulingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/PublishAllToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPrograms(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/GetPrograms?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrograms(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrograms(response: HttpResponseBase): Observable<PagedResultDtoOfProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProgramDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProgram(body: CreateProgramInput | undefined): Observable<ProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/CreateProgram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProgram(response: HttpResponseBase): Observable<ProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProgram(body: UpdateProgramInput | undefined): Observable<ProgramDto> {
        let url_ = this.baseUrl + "/api/services/app/Ad/UpdateProgram";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProgram(response: HttpResponseBase): Observable<ProgramDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProgram(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ad/DeleteProgram?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProgram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProgram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    informDevicesByMqtt(body: number[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Ad/InformDevicesByMqtt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInformDevicesByMqtt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInformDevicesByMqtt(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processInformDevicesByMqtt(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    shutDeviceScheduling(body: number[] | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/ShutDeviceScheduling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShutDeviceScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShutDeviceScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processShutDeviceScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param schedulingId (optional) 
     * @param deviceId (optional) 
     * @param isOpen (optional) 
     * @return Success
     */
    openOrShutDeviceScheduling(schedulingId: number | undefined, deviceId: number | undefined, isOpen: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Ad/OpenOrShutDeviceScheduling?";
        if (schedulingId === null)
            throw new Error("The parameter 'schedulingId' cannot be null.");
        else if (schedulingId !== undefined)
            url_ += "SchedulingId=" + encodeURIComponent("" + schedulingId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (isOpen === null)
            throw new Error("The parameter 'isOpen' cannot be null.");
        else if (isOpen !== undefined)
            url_ += "IsOpen=" + encodeURIComponent("" + isOpen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenOrShutDeviceScheduling(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenOrShutDeviceScheduling(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processOpenOrShutDeviceScheduling(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class AdsPackageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateAdsPackage(body: AddOrUpdateAdsPackageInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/AddOrUpdateAdsPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateAdsPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateAdsPackage(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateAdsPackage(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPackages(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPackageDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetPackages?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPackageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPackageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackages(response: HttpResponseBase): Observable<PagedResultDtoOfGetPackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPackageDto>(<any>null);
    }

    /**
     * @param packageId (optional) 
     * @return Success
     */
    getPackageById(packageId: number | undefined): Observable<AdsPackageDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetPackageById?";
        if (packageId === null)
            throw new Error("The parameter 'packageId' cannot be null.");
        else if (packageId !== undefined)
            url_ += "packageId=" + encodeURIComponent("" + packageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackageById(<any>response_);
                } catch (e) {
                    return <Observable<AdsPackageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdsPackageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPackageById(response: HttpResponseBase): Observable<AdsPackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdsPackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdsPackageDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePackageByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/DeletePackageByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePackageByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePackageByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePackageByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param adsPackageId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdInfosInSamePackage(adsPackageId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdPackageDto> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAdInfosInSamePackage?";
        if (adsPackageId === null)
            throw new Error("The parameter 'adsPackageId' cannot be null.");
        else if (adsPackageId !== undefined)
            url_ += "AdsPackageId=" + encodeURIComponent("" + adsPackageId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdInfosInSamePackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdInfosInSamePackage(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdPackageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdPackageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdInfosInSamePackage(response: HttpResponseBase): Observable<PagedResultDtoOfAdPackageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdPackageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdPackageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAdPackage(body: UpdateAdPackageInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/UpdateAdPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdPackage(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAdPackage(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setAdsToPackage(body: SetAdsToPackageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/SetAdsToPackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAdsToPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAdsToPackage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAdsToPackage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param adId (optional) 
     * @return Success
     */
    getAdPackageByAdId(adId: number | undefined): Observable<AdPackage> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAdPackageByAdId?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdPackageByAdId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdPackageByAdId(<any>response_);
                } catch (e) {
                    return <Observable<AdPackage>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdPackage>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdPackageByAdId(response: HttpResponseBase): Observable<AdPackage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdPackage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdPackage>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setUserAds(body: SetUserAds | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/SetUserAds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserAds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetUserAds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param adId (optional) 
     * @return Success
     */
    getUserAdByAdId(adId: number | undefined): Observable<UserAd> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetUserAdByAdId?";
        if (adId === null)
            throw new Error("The parameter 'adId' cannot be null.");
        else if (adId !== undefined)
            url_ += "AdId=" + encodeURIComponent("" + adId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAdByAdId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAdByAdId(<any>response_);
                } catch (e) {
                    return <Observable<UserAd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAd>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAdByAdId(response: HttpResponseBase): Observable<UserAd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAd>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTransitionsInAds(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/AdsPackage/GetAllTransitionsInAds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransitionsInAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransitionsInAds(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTransitionsInAds(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class ApplyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param type (optional) 
     * @param applyStatus (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyForms(type: string | null | undefined, applyStatus: string | null | undefined, start: DateTime | null | undefined, end: DateTime | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfApplyFormDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyForms?";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (applyStatus !== undefined && applyStatus !== null)
            url_ += "ApplyStatus=" + encodeURIComponent("" + applyStatus) + "&";
        if (start !== undefined && start !== null)
            url_ += "Start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "End=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyForms(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplyFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyForms(response: HttpResponseBase): Observable<PagedResultDtoOfApplyFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApplyFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApplyFormDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createApplyForm(body: CreateApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/CreateApplyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    audit(body: AuditApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appFormId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyFormDetails(appFormId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfIdNamePicDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyFormDetails?";
        if (appFormId === null)
            throw new Error("The parameter 'appFormId' cannot be null.");
        else if (appFormId !== undefined)
            url_ += "AppFormId=" + encodeURIComponent("" + appFormId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyFormDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyFormDetails(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIdNamePicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIdNamePicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyFormDetails(response: HttpResponseBase): Observable<PagedResultDtoOfIdNamePicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIdNamePicDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIdNamePicDto>(<any>null);
    }

    /**
     * @param appFormId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditDeviceDetails(appFormId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetAuditDeviceDetails?";
        if (appFormId === null)
            throw new Error("The parameter 'appFormId' cannot be null.");
        else if (appFormId !== undefined)
            url_ += "AppFormId=" + encodeURIComponent("" + appFormId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditDeviceDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditDeviceDetails(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditDeviceDetails(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceDto>(<any>null);
    }
}

@Injectable()
export class AppVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAppVersion(body: CreateAppVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/CreateAppVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAppVersion(body: UpdateAppVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/UpdateAppVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAppVersions(editionId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAppVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetAppVersions?";
        if (editionId !== undefined && editionId !== null)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppVersions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAppVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAppVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppVersions(response: HttpResponseBase): Observable<PagedResultDtoOfAppVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAppVersionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteAppVersion(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/DeleteAppVersion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAppVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAppVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAppVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteAppVersions(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/BatchDeleteAppVersions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteAppVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteAppVersions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteAppVersions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionInfoForSelect(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetEditionInfoForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionInfoForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionInfoForSelect(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionInfoForSelect(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined && serviceName !== null)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined && methodName !== null)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined && browserInfo !== null)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined && hasException !== null)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined && minExecutionDuration !== null)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined && maxExecutionDuration !== null)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined && entityTypeFullName !== null)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BackendDownloadTaskServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateExportTask(body: ExportMissionInput | undefined): Observable<ExportMissionInput> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/AddOrUpdateExportTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateExportTask(<any>response_);
                } catch (e) {
                    return <Observable<ExportMissionInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportMissionInput>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateExportTask(response: HttpResponseBase): Observable<ExportMissionInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportMissionInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportMissionInput>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExportTask(status: ExportMissionStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExportTaskDto> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/GetExportTask?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportTask(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExportTaskDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExportTaskDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportTask(response: HttpResponseBase): Observable<PagedResultDtoOfExportTaskDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExportTaskDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExportTaskDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteExportTask(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/DeleteExportTask?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExportTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteExportTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BatchTaskLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param batchType (optional) 
     * @param onlineStoreId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBatchTaskLogs(batchType: string | null | undefined, onlineStoreId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBatchTaskLogDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchTaskLog/GetBatchTaskLogs?";
        if (batchType !== undefined && batchType !== null)
            url_ += "BatchType=" + encodeURIComponent("" + batchType) + "&";
        if (onlineStoreId !== undefined && onlineStoreId !== null)
            url_ += "OnlineStoreId=" + encodeURIComponent("" + onlineStoreId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchTaskLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchTaskLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBatchTaskLogDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBatchTaskLogDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchTaskLogs(response: HttpResponseBase): Observable<PagedResultDtoOfBatchTaskLogDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBatchTaskLogDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBatchTaskLogDto>(<any>null);
    }
}

@Injectable()
export class BehaviorRecordsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadToTaobao(body: UploadToTaobaoBehaviorInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BehaviorRecords/UploadToTaobao";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadToTaobao(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadToTaobao(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadToTaobao(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BrandServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tagId (optional) 
     * @param catetoryIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(tagId: number | null | undefined, catetoryIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBrandDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/Gets?";
        if (tagId !== undefined && tagId !== null)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBrandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBrandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfBrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBrandDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param catetoryIds (optional) 
     * @return Success
     */
    getSingle(input: number | undefined, catetoryIds: number[] | null | undefined): Observable<BrandDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetSingle?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingle(<any>response_);
                } catch (e) {
                    return <Observable<BrandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingle(response: HttpResponseBase): Observable<BrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBrandInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBrandInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param isIncludeProduct (optional) 
     * @param isAllBrands (optional) 
     * @param brandIds (optional) 
     * @return Success
     */
    deleteBrands(isIncludeProduct: boolean | undefined, isAllBrands: boolean | undefined, brandIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/DeleteBrands?";
        if (isIncludeProduct === null)
            throw new Error("The parameter 'isIncludeProduct' cannot be null.");
        else if (isIncludeProduct !== undefined)
            url_ += "IsIncludeProduct=" + encodeURIComponent("" + isIncludeProduct) + "&";
        if (isAllBrands === null)
            throw new Error("The parameter 'isAllBrands' cannot be null.");
        else if (isAllBrands !== undefined)
            url_ += "IsAllBrands=" + encodeURIComponent("" + isAllBrands) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrands(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrands(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBrandResources(entityId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandResources?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandResources(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandResources(response: HttpResponseBase): Observable<PagedResultDtoOfEntityFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityFileDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteBrandResources(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/DeleteBrandResources?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrandResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrandResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrandResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBrandResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/DeleteBrandResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrandResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrandResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrandResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addBrandResource(body: CreateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/AddBrandResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBrandResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBrandResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddBrandResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrandResource(body: UpdateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/UpdateBrandResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrandResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrandResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrandResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTags(body: SetBrandTagsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/SetTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onlineOrOfflineBrand(body: OnlineOrOffLineBrandInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/OnlineOrOfflineBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnlineOrOfflineBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnlineOrOfflineBrand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOnlineOrOfflineBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateBrandCategory(body: AddOrUpdateBrandCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/AddOrUpdateBrandCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateBrandCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateBrandCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateBrandCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getBrandCategoryTrees(): Observable<BrandCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandCategoryTrees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<BrandCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandCategoryTrees(response: HttpResponseBase): Observable<BrandCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BrandCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBrandCategories(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBrandCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandCategories?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBrandCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBrandCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandCategories(response: HttpResponseBase): Observable<PagedResultDtoOfBrandCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBrandCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBrandCategoryDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getBrandCategoriesBySubKey(subKey: string | null | undefined): Observable<PagedResultDtoOfBrandCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandCategoriesBySubKey?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandCategoriesBySubKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandCategoriesBySubKey(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBrandCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBrandCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandCategoriesBySubKey(response: HttpResponseBase): Observable<PagedResultDtoOfBrandCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBrandCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBrandCategoryDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getTreesBySubKey(subKey: string | null | undefined): Observable<BrandCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetTreesBySubKey?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreesBySubKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreesBySubKey(<any>response_);
                } catch (e) {
                    return <Observable<BrandCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreesBySubKey(response: HttpResponseBase): Observable<BrandCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BrandCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleBrandCategory(id: number | undefined): Observable<BrandCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetSingleBrandCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleBrandCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleBrandCategory(<any>response_);
                } catch (e) {
                    return <Observable<BrandCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleBrandCategory(response: HttpResponseBase): Observable<BrandCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBrandCategory(body: CreateBrandCategoryInput | undefined): Observable<BrandCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/CreateBrandCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrandCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrandCategory(<any>response_);
                } catch (e) {
                    return <Observable<BrandCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrandCategory(response: HttpResponseBase): Observable<BrandCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrandCategory(body: UpdateBrandCategoryInput | undefined): Observable<BrandCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Brand/UpdateBrandCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrandCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrandCategory(<any>response_);
                } catch (e) {
                    return <Observable<BrandCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrandCategory(response: HttpResponseBase): Observable<BrandCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBrandCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/DeleteBrandCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrandCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrandCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrandCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Brand/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId !== undefined && minMessageId !== null)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class CouponServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditStatus (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCoupons(auditStatus: AuditStatus | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCouponOutDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/GetCoupons?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoupons(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoupons(response: HttpResponseBase): Observable<PagedResultDtoOfCouponOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCouponOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCouponOutDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCoupon(body: CreateCouponInput | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/CreateCoupon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoupon(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoupon(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCoupon(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/DeleteCoupon?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCoupon(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCoupon(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCoupon(body: UpdateCouponInput | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/UpdateCoupon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoupon(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoupon(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/PublishToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/PublishAllToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCouponByTicket(body: CreateCouponByTicketInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/CreateCouponByTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCouponByTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCouponByTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCouponByTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | null | undefined, application: string | null | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(<any>response_);
                } catch (e) {
                    return <Observable<Dashboard>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dashboard>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dashboard>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(<any>response_);
                } catch (e) {
                    return <Observable<AddNewPageOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddNewPageOutput>><any>_observableThrow(response_);
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddNewPageOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | null | undefined, dashboardName: string | null | undefined, application: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(<any>response_);
                } catch (e) {
                    return <Observable<Widget>><any>_observableThrow(e);
                }
            } else
                return <Observable<Widget>><any>_observableThrow(response_);
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Widget>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | null | undefined, application: string | null | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(<any>response_);
                } catch (e) {
                    return <Observable<DashboardOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DashboardOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashboardOutput>(<any>null);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | null | undefined, application: string | null | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName !== undefined && dashboardName !== null)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application !== undefined && application !== null)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(<any>response_);
                } catch (e) {
                    return <Observable<WidgetOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WidgetOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WidgetOutput[]>(<any>null);
    }

    /**
     * @param application (optional) 
     * @return Success
     */
    getSettingName(application: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application !== undefined && application !== null)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined && input !== null)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param deviceTypeIds (optional) 
     * @param status (optional) 
     * @param operatingType (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDevicesForHost(tenantId: number | null | undefined, deviceTypeIds: number[] | null | undefined, status: DeviceStatus | undefined, operatingType: OperatingType | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantDeviceOutput> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDevicesForHost?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (deviceTypeIds !== undefined && deviceTypeIds !== null)
            deviceTypeIds && deviceTypeIds.forEach(item => { url_ += "DeviceTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (operatingType === null)
            throw new Error("The parameter 'operatingType' cannot be null.");
        else if (operatingType !== undefined)
            url_ += "OperatingType=" + encodeURIComponent("" + operatingType) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesForHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesForHost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDeviceOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDeviceOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesForHost(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDeviceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantDeviceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDeviceOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDeviceById(id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDeviceById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceById(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceById(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDeviceByIdTask(id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDeviceByIdTask?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceByIdTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceByIdTask(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceByIdTask(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param operatingType (optional) 
     * @param auditStatus (optional) 
     * @param isHaveChildDevices (optional) 
     * @param deviceTypeIds (optional) 
     * @param storesId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDevices(status: DeviceStatus | undefined, operatingType: OperatingType | undefined, auditStatus: AuditStatus | undefined, isHaveChildDevices: boolean | null | undefined, deviceTypeIds: number[] | null | undefined, storesId: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDevices?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (operatingType === null)
            throw new Error("The parameter 'operatingType' cannot be null.");
        else if (operatingType !== undefined)
            url_ += "OperatingType=" + encodeURIComponent("" + operatingType) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (isHaveChildDevices !== undefined && isHaveChildDevices !== null)
            url_ += "IsHaveChildDevices=" + encodeURIComponent("" + isHaveChildDevices) + "&";
        if (deviceTypeIds !== undefined && deviceTypeIds !== null)
            deviceTypeIds && deviceTypeIds.forEach(item => { url_ += "DeviceTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (storesId !== undefined && storesId !== null)
            storesId && storesId.forEach(item => { url_ += "StoresId=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevices(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevices(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDevice(body: CreateDeviceInput | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/CreateDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDevice(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDevice(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeviceFromScanCode(body: CreateDeviceFromScanCodeInput | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/CreateDeviceFromScanCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceFromScanCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceFromScanCode(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceFromScanCode(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bindDeviceFromScanCode(body: BindDeviceFromScanCodeInput | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/BindDeviceFromScanCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindDeviceFromScanCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindDeviceFromScanCode(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processBindDeviceFromScanCode(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDevice(body: UpdateDeviceInput | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/UpdateDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDevice(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDevice(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDevice(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/DeleteDevice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDevices(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/DeleteDevices?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdOutDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetAdsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfAdOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdOutDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwaresByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetSoftwaresByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwaresByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwaresByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwaresByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceSoftwareDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetProductsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceSkusDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetSkusByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceSkusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceSkusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceSkusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceSkusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceSkusDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCouponsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCouponOutDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetCouponsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfCouponOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCouponOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCouponOutDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnPublishedAdsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdOutDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnPublishedAdsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnPublishedAdsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnPublishedAdsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnPublishedAdsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfAdOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdOutDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedSoftwaresByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnpublishedSoftwaresByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedSoftwaresByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedSoftwaresByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedSoftwaresByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceSoftwareDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedProductsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProuctListOutPut> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnpublishedProductsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedProductsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedProductsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedProductsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfProuctListOutPut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProuctListOutPut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProuctListOutPut>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedSkusByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceSkusDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnpublishedSkusByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedSkusByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedSkusByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceSkusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceSkusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedSkusByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceSkusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceSkusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceSkusDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnPublishedCouponsByDeviceId(deviceId: number, id: number | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCouponOutDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnPublishedCouponsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnPublishedCouponsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnPublishedCouponsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnPublishedCouponsByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfCouponOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCouponOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCouponOutDto>(<any>null);
    }

    /**
     * @return Success
     */
    getTreeDevices(): Observable<TreeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetTreeDevices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeDevices(<any>response_);
                } catch (e) {
                    return <Observable<TreeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreeDevices(response: HttpResponseBase): Observable<TreeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToStore(body: PublishDeviceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/PublishToStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    recycleFromStore(body: RecycleDeviceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/RecycleFromStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecycleFromStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecycleFromStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecycleFromStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    onlineStoreInfoSelect(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/OnlineStoreInfoSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnlineStoreInfoSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnlineStoreInfoSelect(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOnlineStoreInfoSelect(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mirrorPublish(body: DeviceMirrorPublishInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/MirrorPublish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMirrorPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMirrorPublish(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMirrorPublish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateThirdDeviceCode(body: UpdateThirdDeivceCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/UpdateThirdDeviceCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateThirdDeviceCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateThirdDeviceCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateThirdDeviceCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSmartStoreDeviceToExtraPlatform(body: AddSmartStoreDeviceToExtraPlatformInput | undefined): Observable<ExtraPlatformDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/AddSmartStoreDeviceToExtraPlatform";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSmartStoreDeviceToExtraPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSmartStoreDeviceToExtraPlatform(<any>response_);
                } catch (e) {
                    return <Observable<ExtraPlatformDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtraPlatformDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddSmartStoreDeviceToExtraPlatform(response: HttpResponseBase): Observable<ExtraPlatformDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExtraPlatformDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtraPlatformDeviceDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param operatingType (optional) 
     * @param auditStatus (optional) 
     * @param isHaveChildDevices (optional) 
     * @param deviceTypeIds (optional) 
     * @param storesId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceToExcel(status: DeviceStatus | undefined, operatingType: OperatingType | undefined, auditStatus: AuditStatus | undefined, isHaveChildDevices: boolean | null | undefined, deviceTypeIds: number[] | null | undefined, storesId: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDeviceToExcel?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (operatingType === null)
            throw new Error("The parameter 'operatingType' cannot be null.");
        else if (operatingType !== undefined)
            url_ += "OperatingType=" + encodeURIComponent("" + operatingType) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (isHaveChildDevices !== undefined && isHaveChildDevices !== null)
            url_ += "IsHaveChildDevices=" + encodeURIComponent("" + isHaveChildDevices) + "&";
        if (deviceTypeIds !== undefined && deviceTypeIds !== null)
            deviceTypeIds && deviceTypeIds.forEach(item => { url_ += "DeviceTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (storesId !== undefined && storesId !== null)
            storesId && storesId.forEach(item => { url_ += "StoresId=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceSkus(deviceId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetDeviceSkus?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceSkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceSkus(response: HttpResponseBase): Observable<PagedResultDtoOfSkuSimpleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuSimpleDto>(<any>null);
    }
}

@Injectable()
export class DeviceActionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishEvent(body: DeviceActionInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAction/PublishEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishEvent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPublishEvent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    broadcastEvent(body: DevicesActionInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAction/BroadcastEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBroadcastEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBroadcastEvent(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBroadcastEvent(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishEventWithSubkey(body: DevicesActionInputWithSubkey | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAction/PublishEventWithSubkey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishEventWithSubkey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishEventWithSubkey(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPublishEventWithSubkey(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class DeviceCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceCategories(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceCategory/GetDeviceCategories?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCategories(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeviceCategories(body: CreateDeviceCategoryInput | undefined): Observable<DeviceCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceCategory/CreateDeviceCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceCategories(<any>response_);
                } catch (e) {
                    return <Observable<DeviceCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceCategories(response: HttpResponseBase): Observable<DeviceCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeviceCategories(body: UpdateDeviceCategoryInput | undefined): Observable<DeviceCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceCategory/UpdateDeviceCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceCategories(<any>response_);
                } catch (e) {
                    return <Observable<DeviceCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceCategories(response: HttpResponseBase): Observable<DeviceCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceCategories(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceCategory/DeleteDeviceCategories?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    selectDeviceCategory(): Observable<SelectDtoOfInt32[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceCategory/SelectDeviceCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectDeviceCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectDeviceCategory(<any>response_);
                } catch (e) {
                    return <Observable<SelectDtoOfInt32[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectDtoOfInt32[]>><any>_observableThrow(response_);
        }));
    }

    protected processSelectDeviceCategory(response: HttpResponseBase): Observable<SelectDtoOfInt32[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectDtoOfInt32.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectDtoOfInt32[]>(<any>null);
    }
}

@Injectable()
export class DeviceExtraServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeviceExtra(body: CreateDeviceExtraInput | undefined): Observable<DeviceExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceExtra/CreateDeviceExtra";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceExtra(<any>response_);
                } catch (e) {
                    return <Observable<DeviceExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceExtra(response: HttpResponseBase): Observable<DeviceExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceExtraDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeviceExtra(body: UpdateDeviceExtraInput | undefined): Observable<DeviceExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceExtra/UpdateDeviceExtra";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceExtra(<any>response_);
                } catch (e) {
                    return <Observable<DeviceExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceExtra(response: HttpResponseBase): Observable<DeviceExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceExtraDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceExtra(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceExtra/DeleteDeviceExtra?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceExtra(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceExtra(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param externalEnum (optional) 
     * @param deviceId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceExtras(externalEnum: ExternalEnum | undefined, deviceId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceExtra/GetDeviceExtras?";
        if (externalEnum === null)
            throw new Error("The parameter 'externalEnum' cannot be null.");
        else if (externalEnum !== undefined)
            url_ += "ExternalEnum=" + encodeURIComponent("" + externalEnum) + "&";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceExtras(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceExtras(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceExtras(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceExtraDto>(<any>null);
    }

    /**
     * @param cargoRoadsId (optional) 
     * @param thingId (optional) 
     * @return Success
     */
    updateInventory(cargoRoadsId: number | undefined, thingId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DeviceExtra/UpdateInventory?";
        if (cargoRoadsId === null)
            throw new Error("The parameter 'cargoRoadsId' cannot be null.");
        else if (cargoRoadsId !== undefined)
            url_ += "CargoRoadsId=" + encodeURIComponent("" + cargoRoadsId) + "&";
        if (thingId === null)
            throw new Error("The parameter 'thingId' cannot be null.");
        else if (thingId !== undefined)
            url_ += "ThingId=" + encodeURIComponent("" + thingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInventory(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInventory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class DeviceHeatmapDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dtStart (optional) 
     * @param dtEnd (optional) 
     * @param deviceID (optional) 
     * @return Success
     */
    getDeviceHeatmapData(dtStart: DateTime | undefined, dtEnd: DateTime | undefined, deviceID: number | undefined): Observable<DeviceHeatMapViewModel[]> {
        let url_ = this.baseUrl + "/api/services/app/DeviceHeatmapData/GetDeviceHeatmapData?";
        if (dtStart === null)
            throw new Error("The parameter 'dtStart' cannot be null.");
        else if (dtStart !== undefined)
            url_ += "dtStart=" + encodeURIComponent(dtStart ? "" + dtStart.toJSON() : "") + "&";
        if (dtEnd === null)
            throw new Error("The parameter 'dtEnd' cannot be null.");
        else if (dtEnd !== undefined)
            url_ += "dtEnd=" + encodeURIComponent(dtEnd ? "" + dtEnd.toJSON() : "") + "&";
        if (deviceID === null)
            throw new Error("The parameter 'deviceID' cannot be null.");
        else if (deviceID !== undefined)
            url_ += "deviceID=" + encodeURIComponent("" + deviceID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceHeatmapData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceHeatmapData(<any>response_);
                } catch (e) {
                    return <Observable<DeviceHeatMapViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceHeatMapViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceHeatmapData(response: HttpResponseBase): Observable<DeviceHeatMapViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceHeatMapViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceHeatMapViewModel[]>(<any>null);
    }
}

@Injectable()
export class DeviceTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceTypes(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceType/GetDeviceTypes?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceTypes(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceTypes(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeviceType(body: CreateDeviceTypeInput | undefined): Observable<DeviceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceType/CreateDeviceType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceType(<any>response_);
                } catch (e) {
                    return <Observable<DeviceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceType(response: HttpResponseBase): Observable<DeviceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeviceType(body: UpdateDeviceTypeInput | undefined): Observable<DeviceTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceType/UpdateDeviceType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceType(<any>response_);
                } catch (e) {
                    return <Observable<DeviceTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceType(response: HttpResponseBase): Observable<DeviceTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceTypeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceType/DeleteDeviceType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDeviceTypeSelect(): Observable<ListResultDtoOfNameValueAbilities> {
        let url_ = this.baseUrl + "/api/services/app/DeviceType/GetDeviceTypeSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceTypeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceTypeSelect(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueAbilities>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueAbilities>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceTypeSelect(response: HttpResponseBase): Observable<ListResultDtoOfNameValueAbilities> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueAbilities.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueAbilities>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @param entityFullName (optional) 
     * @return Success
     */
    getAllPropertiesOfAnEntity(entityFullName: string | null | undefined): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllPropertiesOfAnEntity?";
        if (entityFullName !== undefined && entityFullName !== null)
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPropertiesOfAnEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPropertiesOfAnEntity(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPropertiesOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEntitiesHasDynamicProperty(): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllEntitiesHasDynamicProperty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesHasDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesHasDynamicProperty(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEntitiesHasDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAllowedInputTypeNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllAllowedInputTypeNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllowedInputTypeNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllowedInputTypeNames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class DynamicEntityPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicEntityPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicEntityPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicEntityPropertyValueDto>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @param propertyId (optional) 
     * @return Success
     */
    getAll(entityId: string | null | undefined, propertyId: number | undefined): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAll?";
        if (entityId !== undefined && entityId !== null)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicEntityPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicEntityPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicEntityPropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDynamicEntityPropertyValues(entityFullName: string, entityId: string): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAllDynamicEntityPropertyValues?";
        if (entityFullName === undefined || entityFullName === null)
            throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
        else
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicEntityPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicEntityPropertyValues(<any>response_);
                } catch (e) {
                    return <Observable<GetAllDynamicEntityPropertyValuesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAllDynamicEntityPropertyValuesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDynamicEntityPropertyValues(response: HttpResponseBase): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDynamicEntityPropertyValuesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAllDynamicEntityPropertyValuesOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/InsertOrUpdateAllValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateAllValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateAllValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cleanValues(body: CleanValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/CleanValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCleanValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DynamicPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    findAllowedInputType(name: string | null | undefined): Observable<IInputType> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/FindAllowedInputType?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAllowedInputType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAllowedInputType(<any>response_);
                } catch (e) {
                    return <Observable<IInputType>><any>_observableThrow(e);
                }
            } else
                return <Observable<IInputType>><any>_observableThrow(response_);
        }));
    }

    protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IInputType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IInputType>(<any>null);
    }
}

@Injectable()
export class DynamicPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DynamicPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicPropertyValueDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllValuesOfDynamicProperty(id: number | undefined): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/GetAllValuesOfDynamicProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValuesOfDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValuesOfDynamicProperty(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDynamicPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDynamicPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllValuesOfDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDynamicPropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined && selectedEditionId !== null)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class ExternalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPricesScope(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/External/GetPricesScope";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPricesScope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPricesScope(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPricesScope(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPadResource(): Observable<ExternalPadResDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetPadResource";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPadResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPadResource(<any>response_);
                } catch (e) {
                    return <Observable<ExternalPadResDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalPadResDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPadResource(response: HttpResponseBase): Observable<ExternalPadResDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalPadResDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalPadResDto>(<any>null);
    }

    /**
     * @param pricesScope (optional) 
     * @param categoryIds (optional) 
     * @param tagIds (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTotalSkus(pricesScope: string | null | undefined, categoryIds: number[] | null | undefined, tagIds: number[] | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetTotalSkus?";
        if (pricesScope !== undefined && pricesScope !== null)
            url_ += "PricesScope=" + encodeURIComponent("" + pricesScope) + "&";
        if (categoryIds !== undefined && categoryIds !== null)
            categoryIds && categoryIds.forEach(item => { url_ += "CategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalSkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTotalSkus(response: HttpResponseBase): Observable<PagedResultDtoOfExternalSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalSkuDto>(<any>null);
    }

    /**
     * @param pricesScope (optional) 
     * @param categoryIds (optional) 
     * @param tagIds (optional) 
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkus(pricesScope: string | null | undefined, categoryIds: number[] | null | undefined, tagIds: number[] | null | undefined, auditStatus: AuditStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetSkus?";
        if (pricesScope !== undefined && pricesScope !== null)
            url_ += "PricesScope=" + encodeURIComponent("" + pricesScope) + "&";
        if (categoryIds !== undefined && categoryIds !== null)
            categoryIds && categoryIds.forEach(item => { url_ += "CategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkus(response: HttpResponseBase): Observable<PagedResultDtoOfExternalSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalSkuDto>(<any>null);
    }

    /**
     * @param skuId (optional) 
     * @return Success
     */
    getProductBySkuId(skuId: number | undefined): Observable<ExternalProductDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetProductBySkuId?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBySkuId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBySkuId(<any>response_);
                } catch (e) {
                    return <Observable<ExternalProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductBySkuId(response: HttpResponseBase): Observable<ExternalProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalProductDto>(<any>null);
    }

    /**
     * @param itemId (optional) 
     * @return Success
     */
    getProductByItemId(itemId: string | null | undefined): Observable<ExternalProductDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetProductByItemId?";
        if (itemId !== undefined && itemId !== null)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductByItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductByItemId(<any>response_);
                } catch (e) {
                    return <Observable<ExternalProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductByItemId(response: HttpResponseBase): Observable<ExternalProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalProductDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getproductCategories(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetproductCategories?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetproductCategories(response: HttpResponseBase): Observable<PagedResultDtoOfExternalProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalProductCategoryDto>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDevices(organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/External/GetDevices?";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevices(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevices(response: HttpResponseBase): Observable<PagedResultDtoOfExternalDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalDeviceDto>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    searchSkuByBarCode(code: string | null | undefined): Observable<ExternalSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/External/SearchSkuByBarCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchSkuByBarCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchSkuByBarCode(<any>response_);
                } catch (e) {
                    return <Observable<ExternalSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchSkuByBarCode(response: HttpResponseBase): Observable<ExternalSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalSkuDto>(<any>null);
    }

    /**
     * @return Success
     */
    keepIISAlive(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/External/KeepIISAlive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeepIISAlive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeepIISAlive(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processKeepIISAlive(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param skuId (optional) 
     * @param subkey (optional) 
     * @return Success
     */
    getProductBySkuIdsubkey(skuId: number | undefined, subkey: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/External/GetProductBySkuIdsubkey?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBySkuIdsubkey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBySkuIdsubkey(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductBySkuIdsubkey(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class ExternalAccessServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalAccessDto> {
        let url_ = this.baseUrl + "/api/services/app/ExternalAccess/GetAll?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalAccessDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalAccessDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfExternalAccessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalAccessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalAccessDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addExternalAccess(body: CreateExternalAccessInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalAccess/AddExternalAccess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddExternalAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddExternalAccess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddExternalAccess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateExternalAccess(body: UpdateExternalAccessInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalAccess/UpdateExternalAccess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateExternalAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateExternalAccess(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateExternalAccess(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateAccessToken(body: AddOrUpdateAccessTokenInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ExternalAccess/AddOrUpdateAccessToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateAccessToken(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateAccessToken(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExternalAccess/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}


@Injectable()
export class OrganizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStores(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalStoreDto> {
        let url_ = this.baseUrl + "/api/services/external/organization/GetStores?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStores(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalStoreDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalStoreDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStores(response: HttpResponseBase): Observable<PagedResultDtoOfExternalStoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalStoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalStoreDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateStore(body: ExternalAddOrUpdateStoreModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/external/organization/AddOrUpdateStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}



@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param fileType (optional) 
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string | null | undefined, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        if (fileType !== undefined && fileType !== null)
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&";
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "FileToken=" + encodeURIComponent("" + fileToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getOssUsedInfo(tenantId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/File/GetOssUsedInfo?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOssUsedInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOssUsedInfo(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetOssUsedInfo(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param contentType (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    downloadBinaryFile(id: string | undefined, contentType: string | null | undefined, fileName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadBinaryFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (contentType !== undefined && contentType !== null)
            url_ += "contentType=" + encodeURIComponent("" + contentType) + "&";
        if (fileName !== undefined && fileName !== null)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadBinaryFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadBinaryFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadBinaryFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    uploadSingleBigFile(fileArea: FileArea): Observable<TinyFileOutput> {
        let url_ = this.baseUrl + "/api/File/UploadSingleBigFile?";
        if (fileArea === undefined || fileArea === null)
            throw new Error("The parameter 'fileArea' must be defined and cannot be null.");
        else
            url_ += "fileArea=" + encodeURIComponent("" + fileArea) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSingleBigFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSingleBigFile(<any>response_);
                } catch (e) {
                    return <Observable<TinyFileOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TinyFileOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUploadSingleBigFile(response: HttpResponseBase): Observable<TinyFileOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TinyFileOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TinyFileOutput>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GroupKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param organizationUnitId (optional) 
     * @param storeId (optional) 
     * @param scaleTimeStart (optional) 
     * @param scaleTimeEnd (optional) 
     * @param kPIScale (optional) 
     * @param name (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getGroupKPIs(organizationUnitId: number | null | undefined, storeId: number | null | undefined, scaleTimeStart: DateTime | null | undefined, scaleTimeEnd: DateTime | null | undefined, kPIScale: GroupKPIScaleEnum | undefined, name: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGroupKPIDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/GetGroupKPIs?";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (scaleTimeStart !== undefined && scaleTimeStart !== null)
            url_ += "ScaleTimeStart=" + encodeURIComponent(scaleTimeStart ? "" + scaleTimeStart.toJSON() : "") + "&";
        if (scaleTimeEnd !== undefined && scaleTimeEnd !== null)
            url_ += "ScaleTimeEnd=" + encodeURIComponent(scaleTimeEnd ? "" + scaleTimeEnd.toJSON() : "") + "&";
        if (kPIScale === null)
            throw new Error("The parameter 'kPIScale' cannot be null.");
        else if (kPIScale !== undefined)
            url_ += "KPIScale=" + encodeURIComponent("" + kPIScale) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupKPIs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGroupKPIDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGroupKPIDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupKPIs(response: HttpResponseBase): Observable<PagedResultDtoOfGroupKPIDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGroupKPIDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGroupKPIDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGroupKPI(body: CreateGroupKpiDtoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/CreateGroupKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGroupKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroupKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGroupKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGroupKPI(body: UpdateGroupKpiDtoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/UpdateGroupKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGroupKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroupKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGroupKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSingleGroupKPI(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/DeleteSingleGroupKPI?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSingleGroupKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSingleGroupKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSingleGroupKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteGroupKPIs(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/DeleteGroupKPIs?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroupKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroupKPIs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGroupKPIs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @return Success
     */
    getKpiNames(organizationUnitId: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/GroupKPI/GetKpiNames?";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKpiNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKpiNames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKpiNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(<any>response_);
                } catch (e) {
                    return <Observable<TopStatsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<TopStatsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopStatsData>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetRecentTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRecentTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRecentTenantsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(<any>response_);
                } catch (e) {
                    return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetExpiringTenantsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetExpiringTenantsOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(<any>null);
    }
}

@Injectable()
export class ImportAdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importAdsByZip(): Observable<ImportAdResultDto> {
        let url_ = this.baseUrl + "/ImportAds/ImportAdsByZip";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportAdsByZip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportAdsByZip(<any>response_);
                } catch (e) {
                    return <Observable<ImportAdResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportAdResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportAdsByZip(response: HttpResponseBase): Observable<ImportAdResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportAdResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportAdResultDto>(<any>null);
    }
}

@Injectable()
export class ImportDevicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importDevicesByExcel(): Observable<ImportDeviceResultDto> {
        let url_ = this.baseUrl + "/ImportDevices/ImportDevicesByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportDevicesByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportDevicesByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportDeviceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportDeviceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportDevicesByExcel(response: HttpResponseBase): Observable<ImportDeviceResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportDeviceResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportDeviceResultDto>(<any>null);
    }
}

@Injectable()
export class ImportFloorGuideRoomAndStoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importBrandAndStoreFromExcel(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: { [key: string]: string[]; } | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<ImportResultDto[]> {
        let url_ = this.baseUrl + "/ImportFloorGuideRoomAndStore/ImportBrandAndStoreFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", headers.toString());
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportBrandAndStoreFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportBrandAndStoreFromExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processImportBrandAndStoreFromExcel(response: HttpResponseBase): Observable<ImportResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImportResultDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultDto[]>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importBrandFromExcel(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: { [key: string]: string[]; } | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<ImportResultDto> {
        let url_ = this.baseUrl + "/ImportFloorGuideRoomAndStore/ImportBrandFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", headers.toString());
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportBrandFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportBrandFromExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportBrandFromExcel(response: HttpResponseBase): Observable<ImportResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultDto>(<any>null);
    }

    /**
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    importStoreFromExcel(contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: { [key: string]: string[]; } | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<ImportResultDto> {
        let url_ = this.baseUrl + "/ImportFloorGuideRoomAndStore/ImportStoreFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            content_.append("Headers", headers.toString());
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportStoreFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportStoreFromExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportStoreFromExcel(response: HttpResponseBase): Observable<ImportResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultDto>(<any>null);
    }
}

@Injectable()
export class ImportLikesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isAutoOffLine (optional) 
     * @return Success
     */
    importLikeByZip(isAutoOffLine: boolean | undefined): Observable<ImportLikeResultDto> {
        let url_ = this.baseUrl + "/ImportLikes/ImportLikeByZip?";
        if (isAutoOffLine === null)
            throw new Error("The parameter 'isAutoOffLine' cannot be null.");
        else if (isAutoOffLine !== undefined)
            url_ += "isAutoOffLine=" + encodeURIComponent("" + isAutoOffLine) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportLikeByZip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportLikeByZip(<any>response_);
                } catch (e) {
                    return <Observable<ImportLikeResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportLikeResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportLikeByZip(response: HttpResponseBase): Observable<ImportLikeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportLikeResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportLikeResultDto>(<any>null);
    }
}

@Injectable()
export class ImportMatchesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isAutoOffLine (optional) 
     * @return Success
     */
    importMatchByZip(isAutoOffLine: boolean | undefined): Observable<ImportMatchResultDto> {
        let url_ = this.baseUrl + "/ImportMatches/ImportMatchByZip?";
        if (isAutoOffLine === null)
            throw new Error("The parameter 'isAutoOffLine' cannot be null.");
        else if (isAutoOffLine !== undefined)
            url_ += "isAutoOffLine=" + encodeURIComponent("" + isAutoOffLine) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMatchByZip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMatchByZip(<any>response_);
                } catch (e) {
                    return <Observable<ImportMatchResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportMatchResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportMatchByZip(response: HttpResponseBase): Observable<ImportMatchResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportMatchResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportMatchResultDto>(<any>null);
    }
}

@Injectable()
export class ImportMojingStoresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inputFile (optional) 
     * @return Success
     */
    importMojingStoresByExcel(inputFile: FileParameter | null | undefined): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportMojingStores/ImportMojingStoresByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputFile !== null && inputFile !== undefined)
            content_.append("InputFile", inputFile.data, inputFile.fileName ? inputFile.fileName : "InputFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMojingStoresByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMojingStoresByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportMojingStoresByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class ImportOuAndStoresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inputFile (optional) 
     * @return Success
     */
    importOuAndStoreByExcel(inputFile: FileParameter | null | undefined): Observable<ImportResultBaseDto> {
        let url_ = this.baseUrl + "/ImportOuAndStores/ImportOuAndStoreByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputFile !== null && inputFile !== undefined)
            content_.append("InputFile", inputFile.data, inputFile.fileName ? inputFile.fileName : "InputFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportOuAndStoreByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportOuAndStoreByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportOuAndStoreByExcel(response: HttpResponseBase): Observable<ImportResultBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportResultBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultBaseDto>(<any>null);
    }
}

@Injectable()
export class ImportProductsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param isAutoOffLine (optional) 
     * @return Success
     */
    importProductByZip(isAutoOffLine: boolean | undefined): Observable<ImportProductResultDto> {
        let url_ = this.baseUrl + "/ImportProducts/ImportProductByZip?";
        if (isAutoOffLine === null)
            throw new Error("The parameter 'isAutoOffLine' cannot be null.");
        else if (isAutoOffLine !== undefined)
            url_ += "isAutoOffLine=" + encodeURIComponent("" + isAutoOffLine) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProductByZip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProductByZip(<any>response_);
                } catch (e) {
                    return <Observable<ImportProductResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportProductResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportProductByZip(response: HttpResponseBase): Observable<ImportProductResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProductResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportProductResultDto>(<any>null);
    }
}

@Injectable()
export class ImportSkuRfidsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importSkuRfidByExcel(): Observable<ImportResultBaseDto> {
        let url_ = this.baseUrl + "/ImportSkuRfids/ImportSkuRfidByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportSkuRfidByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportSkuRfidByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportSkuRfidByExcel(response: HttpResponseBase): Observable<ImportResultBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportResultBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultBaseDto>(<any>null);
    }
}

@Injectable()
export class ImportStorageCheckServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param inputFile (optional) 
     * @return Success
     */
    importStoageCheckByExcel(inputFile: FileParameter | null | undefined): Observable<ImportResultBaseDto> {
        let url_ = this.baseUrl + "/ImportStorageCheck/ImportStoageCheckByExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputFile !== null && inputFile !== undefined)
            content_.append("InputFile", inputFile.data, inputFile.fileName ? inputFile.fileName : "InputFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportStoageCheckByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportStoageCheckByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportResultBaseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportResultBaseDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportStoageCheckByExcel(response: HttpResponseBase): Observable<ImportResultBaseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportResultBaseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportResultBaseDto>(<any>null);
    }
}

@Injectable()
export class ImportStoreKpisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importStoreKPIsByExcel(): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportStoreKpis/ImportStoreKPIsByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportStoreKPIsByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportStoreKPIsByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportStoreKPIsByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class ImportStoresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    importStoresByExcel(): Observable<ImportStoreResultDto> {
        let url_ = this.baseUrl + "/ImportStores/ImportStoresByExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportStoresByExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportStoresByExcel(<any>response_);
                } catch (e) {
                    return <Observable<ImportStoreResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImportStoreResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processImportStoresByExcel(response: HttpResponseBase): Observable<ImportStoreResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportStoreResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImportStoreResultDto>(<any>null);
    }
}

@Injectable()
export class IndependentDeploymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param customer (optional) 
     * @param checkaction (optional) 
     * @param host (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    checkIndependentDeployment(customer: string | null | undefined, checkaction: string | null | undefined, host: string | null | undefined, tenantId: number | null | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/CheckIndependentDeployment?";
        if (customer !== undefined && customer !== null)
            url_ += "customer=" + encodeURIComponent("" + customer) + "&";
        if (checkaction !== undefined && checkaction !== null)
            url_ += "checkaction=" + encodeURIComponent("" + checkaction) + "&";
        if (host !== undefined && host !== null)
            url_ += "host=" + encodeURIComponent("" + host) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIndependentDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIndependentDeployment(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIndependentDeployment(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * @param customer (optional) 
     * @param tenantAction (optional) 
     * @param host (optional) 
     * @param tenantId (optional) 
     * @param tenancyName (optional) 
     * @return Success
     */
    tenantActionCallBack(customer: string | null | undefined, tenantAction: string | null | undefined, host: string | null | undefined, tenantId: number | undefined, tenancyName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/TenantActionCallBack?";
        if (customer !== undefined && customer !== null)
            url_ += "customer=" + encodeURIComponent("" + customer) + "&";
        if (tenantAction !== undefined && tenantAction !== null)
            url_ += "tenantAction=" + encodeURIComponent("" + tenantAction) + "&";
        if (host !== undefined && host !== null)
            url_ += "host=" + encodeURIComponent("" + host) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (tenancyName !== undefined && tenancyName !== null)
            url_ += "tenancyName=" + encodeURIComponent("" + tenancyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTenantActionCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTenantActionCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTenantActionCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customer (optional) 
     * @param deviceAction (optional) 
     * @param host (optional) 
     * @param tenantId (optional) 
     * @param deviceId (optional) 
     * @param deviceName (optional) 
     * @return Success
     */
    deviceActionCallBack(customer: string | null | undefined, deviceAction: string | null | undefined, host: string | null | undefined, tenantId: number | undefined, deviceId: number | undefined, deviceName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/DeviceActionCallBack?";
        if (customer !== undefined && customer !== null)
            url_ += "customer=" + encodeURIComponent("" + customer) + "&";
        if (deviceAction !== undefined && deviceAction !== null)
            url_ += "deviceAction=" + encodeURIComponent("" + deviceAction) + "&";
        if (host !== undefined && host !== null)
            url_ += "host=" + encodeURIComponent("" + host) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (deviceName !== undefined && deviceName !== null)
            url_ += "deviceName=" + encodeURIComponent("" + deviceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeviceActionCallBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeviceActionCallBack(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeviceActionCallBack(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createIndependentDeployment(body: CreateIndependentDeploymentInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/CreateIndependentDeployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIndependentDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIndependentDeployment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateIndependentDeployment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIndependentDeployment(body: UpdateIndependentDeploymentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/UpdateIndependentDeployment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIndependentDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIndependentDeployment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIndependentDeployment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteIndependentDeployment(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/DeleteIndependentDeployment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndependentDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndependentDeployment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteIndependentDeployment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteIndependentDeployments(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/BatchDeleteIndependentDeployments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteIndependentDeployments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteIndependentDeployments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteIndependentDeployments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getIndependentDeployments(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfIndependentDeploymentDto> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/GetIndependentDeployments?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndependentDeployments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndependentDeployments(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIndependentDeploymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIndependentDeploymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndependentDeployments(response: HttpResponseBase): Observable<PagedResultDtoOfIndependentDeploymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIndependentDeploymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIndependentDeploymentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleIndependentDeployment(id: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfIndependentDeploymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/GetSingleIndependentDeployment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleIndependentDeployment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleIndependentDeployment(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIndependentDeploymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIndependentDeploymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleIndependentDeployment(response: HttpResponseBase): Observable<PagedResultDtoOfIndependentDeploymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIndependentDeploymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIndependentDeploymentInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateIndependentDeploymentInfo(body: AddOrUpdateIndependentDeploymentInfoInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/AddOrUpdateIndependentDeploymentInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateIndependentDeploymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateIndependentDeploymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateIndependentDeploymentInfo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteIndependentDeploymentInfo(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/DeleteIndependentDeploymentInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndependentDeploymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndependentDeploymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteIndependentDeploymentInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteIndependentDeploymentInfos(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/BatchDeleteIndependentDeploymentInfos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteIndependentDeploymentInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteIndependentDeploymentInfos(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteIndependentDeploymentInfos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleIndependentDeploymentInfo(id: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeployedTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/GetSingleIndependentDeploymentInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleIndependentDeploymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleIndependentDeploymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeployedTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeployedTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleIndependentDeploymentInfo(response: HttpResponseBase): Observable<PagedResultDtoOfDeployedTenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeployedTenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeployedTenantDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateDeployedTenant(body: AddOrUpdateDeployedTenant | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/AddOrUpdateDeployedTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateDeployedTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateDeployedTenant(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateDeployedTenant(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeployedTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/DeleteDeployedTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeployedTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeployedTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeployedTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteDeployedTenant(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/BatchDeleteDeployedTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteDeployedTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteDeployedTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteDeployedTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleDeployedTenant(id: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeployedDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/GetSingleDeployedTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleDeployedTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleDeployedTenant(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeployedDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeployedDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleDeployedTenant(response: HttpResponseBase): Observable<PagedResultDtoOfDeployedDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeployedDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeployedDeviceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateDeployedTenantDevice(body: AddOrUpdateDeployedTenantDeviceInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/AddOrUpdateDeployedTenantDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateDeployedTenantDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateDeployedTenantDevice(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateDeployedTenantDevice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDeployedTenantDevice(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/DeleteDeployedTenantDevice?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeployedTenantDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeployedTenantDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeployedTenantDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDeleteDeplyedTenantDevices(body: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IndependentDeployment/BatchDeleteDeplyedTenantDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteDeplyedTenantDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteDeplyedTenantDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteDeplyedTenantDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName !== undefined && baseLanguageName !== null)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter !== undefined && targetValueFilter !== null)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText !== undefined && filterText !== null)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LikeInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(skuId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Gets?";
        if (skuId !== undefined && skuId !== null)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfLikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLikeInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getSingle(input: number | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/GetSingle?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingle(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingle(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLikeInfoInput | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLikeInfoInput | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param likeInfoId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusForLikeInfo(likeInfoId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/GetSkusForLikeInfo?";
        if (likeInfoId !== undefined && likeInfoId !== null)
            url_ += "LikeInfoId=" + encodeURIComponent("" + likeInfoId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusForLikeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusForLikeInfo(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusForLikeInfo(response: HttpResponseBase): Observable<PagedResultDtoOfSkuSimpleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuSimpleDto>(<any>null);
    }
}

@Injectable()
export class LikeInfoExcelImporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    import(body: CreateLikeInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfoExcelImporter/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LikeItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Gets?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfLikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLikeItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param openId (optional) 
     * @return Success
     */
    getBindingAccountByOpenId(openId: string | null | undefined): Observable<BindingAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetBindingAccountByOpenId?";
        if (openId !== undefined && openId !== null)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBindingAccountByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBindingAccountByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<BindingAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BindingAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBindingAccountByOpenId(response: HttpResponseBase): Observable<BindingAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BindingAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BindingAccountDto[]>(<any>null);
    }

    /**
     * @param qrcodeId (optional) 
     * @param userId (optional) 
     * @param openId (optional) 
     * @return Success
     */
    authenticateByExtra(qrcodeId: number | undefined, userId: number | undefined, openId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Login/AuthenticateByExtra?";
        if (qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' cannot be null.");
        else if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (openId !== undefined && openId !== null)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateByExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateByExtra(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateByExtra(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param qrcodeId (optional) 
     * @return Success
     */
    getTokenByQrcodeId(qrcodeId: number | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetTokenByQrcodeId?";
        if (qrcodeId === null)
            throw new Error("The parameter 'qrcodeId' cannot be null.");
        else if (qrcodeId !== undefined)
            url_ += "qrcodeId=" + encodeURIComponent("" + qrcodeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenByQrcodeId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenByQrcodeId(<any>response_);
                } catch (e) {
                    return <Observable<TokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTokenByQrcodeId(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bindPlatformUserWithUnionId(body: BindPlatformUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Login/BindPlatformUserWithUnionId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindPlatformUserWithUnionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindPlatformUserWithUnionId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindPlatformUserWithUnionId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param unionId (optional) 
     * @return Success
     */
    unBindPlatformUser(unionId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Login/UnBindPlatformUser?";
        if (unionId !== undefined && unionId !== null)
            url_ += "unionId=" + encodeURIComponent("" + unionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnBindPlatformUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnBindPlatformUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnBindPlatformUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @return Success
     */
    getBindingAccountsByJsCode(code: string | null | undefined): Observable<BindingAccountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetBindingAccountsByJsCode?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBindingAccountsByJsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBindingAccountsByJsCode(<any>response_);
                } catch (e) {
                    return <Observable<BindingAccountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BindingAccountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBindingAccountsByJsCode(response: HttpResponseBase): Observable<BindingAccountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BindingAccountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BindingAccountDto[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param openId (optional) 
     * @param type (optional) 
     * @return Success
     */
    authenticateForThridPartyByOpenId(userId: number | undefined, openId: string | null | undefined, type: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Login/AuthenticateForThridPartyByOpenId?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (openId !== undefined && openId !== null)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateForThridPartyByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateForThridPartyByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateForThridPartyByOpenId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param unionId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getPlatformUserByUnionId(unionId: string | null | undefined, tenantId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetPlatformUserByUnionId?";
        if (unionId !== undefined && unionId !== null)
            url_ += "unionId=" + encodeURIComponent("" + unionId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlatformUserByUnionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlatformUserByUnionId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlatformUserByUnionId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getPlatformUserDetailByOpenId(openId: string | null | undefined, tenantId: number | null | undefined): Observable<UserListDto> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetPlatformUserDetailByOpenId?";
        if (openId !== undefined && openId !== null)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlatformUserDetailByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlatformUserDetailByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<UserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlatformUserDetailByOpenId(response: HttpResponseBase): Observable<UserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getPlatformUsers(tenantId: number | null | undefined): Observable<SimpleUserDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Login/GetPlatformUsers?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlatformUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlatformUsers(<any>response_);
                } catch (e) {
                    return <Observable<SimpleUserDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleUserDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlatformUsers(response: HttpResponseBase): Observable<SimpleUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleUserDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleUserDto[]>(<any>null);
    }
}

@Injectable()
export class MatchInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(skuId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Gets?";
        if (skuId !== undefined && skuId !== null)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfMatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMatchInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getSingle(input: number | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/GetSingle?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingle(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingle(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMatchInfoInput | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMatchInfoInput | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param matchInfoId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusForMatchInfo(matchInfoId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/GetSkusForMatchInfo?";
        if (matchInfoId !== undefined && matchInfoId !== null)
            url_ += "MatchInfoId=" + encodeURIComponent("" + matchInfoId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusForMatchInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusForMatchInfo(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusForMatchInfo(response: HttpResponseBase): Observable<PagedResultDtoOfSkuSimpleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuSimpleDto>(<any>null);
    }
}

@Injectable()
export class MatchItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMatchItemDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchItem/Gets?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMatchItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMatchItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfMatchItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMatchItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMatchItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMatchItemInput | undefined): Observable<MatchItemDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MatchItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MatchItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMatchItemInput | undefined): Observable<MatchItemDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MatchItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MatchItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchItemDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | null | undefined, endDate: DateTime | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OnlineStoreProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(userId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOnlineStoreProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineStoreProfile/Gets?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOnlineStoreProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOnlineStoreProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfOnlineStoreProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOnlineStoreProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOnlineStoreProfileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOnlineStoreProfileInput | undefined): Observable<OnlineStoreProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineStoreProfile/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OnlineStoreProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnlineStoreProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OnlineStoreProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineStoreProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnlineStoreProfileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOnlineStoreProfileInput | undefined): Observable<OnlineStoreProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/OnlineStoreProfile/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OnlineStoreProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnlineStoreProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OnlineStoreProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OnlineStoreProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnlineStoreProfileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OnlineStoreProfile/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfGroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGroupDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnitsToExcel(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitsToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param ouId (optional) 
     * @return Success
     */
    getOrganizationUnitById(ouId: number | undefined): Observable<GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitById?";
        if (ouId === null)
            throw new Error("The parameter 'ouId' cannot be null.");
        else if (ouId !== undefined)
            url_ += "ouId=" + encodeURIComponent("" + ouId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitById(<any>response_);
                } catch (e) {
                    return <Observable<GroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitById(response: HttpResponseBase): Observable<GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationPosition(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationPositionDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationPosition?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationPosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationPosition(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationPositionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationPositionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationPosition(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationPositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationPositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationPositionDto>(<any>null);
    }

    /**
     * @param organizationUnitTypeName (optional) 
     * @param organizationUnitId (optional) 
     * @param areas (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStores(organizationUnitTypeName: string | null | undefined, organizationUnitId: number | null | undefined, areas: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStoreDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetStores?";
        if (organizationUnitTypeName !== undefined && organizationUnitTypeName !== null)
            url_ += "OrganizationUnitTypeName=" + encodeURIComponent("" + organizationUnitTypeName) + "&";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (areas !== undefined && areas !== null)
            areas && areas.forEach(item => { url_ += "Areas=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStores(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoreDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoreDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStores(response: HttpResponseBase): Observable<PagedResultDtoOfStoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoreDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDaquList(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetDaquList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDaquList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDaquList(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDaquList(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param daquIds (optional) 
     * @return Success
     */
    getProvinceList(daquIds: number[] | null | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetProvinceList?";
        if (daquIds !== undefined && daquIds !== null)
            daquIds && daquIds.forEach(item => { url_ += "DaquIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinceList(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProvinceList(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param daquIds (optional) 
     * @param provinceIds (optional) 
     * @return Success
     */
    getStoreList(daquIds: number[] | null | undefined, provinceIds: number[] | null | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetStoreList?";
        if (daquIds !== undefined && daquIds !== null)
            daquIds && daquIds.forEach(item => { url_ += "DaquIds=" + encodeURIComponent("" + item) + "&"; });
        if (provinceIds !== undefined && provinceIds !== null)
            provinceIds && provinceIds.forEach(item => { url_ += "ProvinceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreList(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreList(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentTenantOrganizationUnitsTree(): Observable<TreeDtoOfInt64> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetCurrentTenantOrganizationUnitsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentTenantOrganizationUnitsTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentTenantOrganizationUnitsTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeDtoOfInt64>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeDtoOfInt64>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentTenantOrganizationUnitsTree(response: HttpResponseBase): Observable<TreeDtoOfInt64> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeDtoOfInt64.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeDtoOfInt64>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentUserOrganizationUnits(): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetCurrentUserOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userExistInTenantAndOU(body: UserTenantOUDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UserExistInTenantAndOU";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserExistInTenantAndOU(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserExistInTenantAndOU(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUserExistInTenantAndOU(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param groupName (optional) 
     * @return Success
     */
    getOrganizationUnitUsersForSelect(groupName: string | null | undefined): Observable<OrganizationUnitUserListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsersForSelect?";
        if (groupName !== undefined && groupName !== null)
            url_ += "GroupName=" + encodeURIComponent("" + groupName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsersForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsersForSelect(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitUserListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitUserListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsersForSelect(response: HttpResponseBase): Observable<OrganizationUnitUserListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitUserListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitUserListDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<GroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateGroupInput | undefined): Observable<GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<GroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<GroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param isDeleteChildren (optional) 
     * @return Success
     */
    deleteOrganizationUnitOrChildren(id: number | undefined, isDeleteChildren: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnitOrChildren?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (isDeleteChildren === null)
            throw new Error("The parameter 'isDeleteChildren' cannot be null.");
        else if (isDeleteChildren !== undefined)
            url_ += "IsDeleteChildren=" + encodeURIComponent("" + isDeleteChildren) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnitOrChildren(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnitOrChildren(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnitOrChildren(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationUnitClaims(id: number | undefined): Observable<OrganizationUnitClaimsDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitClaims?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitClaims(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitClaimsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitClaimsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitClaims(response: HttpResponseBase): Observable<OrganizationUnitClaimsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitClaimsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitClaimsDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setOrganizationUnitClaims(body: OrganizationUnitClaimsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/SetOrganizationUnitClaims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrganizationUnitClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrganizationUnitClaims(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetOrganizationUnitClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addClaimsToOrganizationUnit(body: OrganizationUnitClaimsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddClaimsToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClaimsToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClaimsToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddClaimsToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ouId (optional) 
     * @return Success
     */
    organizationUnitClaims(ouId: number | undefined): Observable<NameValue[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/OrganizationUnitClaims?";
        if (ouId === null)
            throw new Error("The parameter 'ouId' cannot be null.");
        else if (ouId !== undefined)
            url_ += "ouId=" + encodeURIComponent("" + ouId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOrganizationUnitClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrganizationUnitClaims(<any>response_);
                } catch (e) {
                    return <Observable<NameValue[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValue[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrganizationUnitClaims(response: HttpResponseBase): Observable<NameValue[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValue.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValue[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param organizationUnitId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getUsersByTenantIdAndOUId(tenantId: number | null | undefined, organizationUnitId: number | undefined, maxResultCount: number | undefined, skipCount: number | undefined, filter: string | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetUsersByTenantIdAndOUId?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByTenantIdAndOUId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByTenantIdAndOUId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByTenantIdAndOUId(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param organizationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSpeicalOrganization(tenantId: number | undefined, organizationId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfIdNameDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetSpeicalOrganization?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpeicalOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpeicalOrganization(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIdNameDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIdNameDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpeicalOrganization(response: HttpResponseBase): Observable<PagedResultDtoOfIdNameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIdNameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIdNameDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAreas(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAreas";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAreas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAreas(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAreas(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitTypes(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/GetOrganizationUnitTypes?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitTypes(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitTypes(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnitType(body: CreateOrganizationUnitTypeInput | undefined): Observable<OrganizationUnitTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/CreateOrganizationUnitType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnitType(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnitType(response: HttpResponseBase): Observable<OrganizationUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDefaultOUtType(body: CreateDefaultOUTypeInput | undefined): Observable<OrganizationUnitTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/CreateDefaultOUtType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDefaultOUtType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDefaultOUtType(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDefaultOUtType(response: HttpResponseBase): Observable<OrganizationUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitTypeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnitType(body: UpdateOrganizationUnitTypeInput | undefined): Observable<OrganizationUnitTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/UpdateOrganizationUnitType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnitType(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitTypeDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnitType(response: HttpResponseBase): Observable<OrganizationUnitTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitTypeDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnitType(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/DeleteOrganizationUnitType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnitType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnitType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnitType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnitTypeSelect(): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnitType/GetOrganizationUnitTypeSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitTypeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitTypeSelect(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitTypeSelect(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class OssServerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getToken(): Observable<StsTokenModel> {
        let url_ = this.baseUrl + "/api/services/app/OssServer/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<StsTokenModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<StsTokenModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<StsTokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StsTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StsTokenModel>(<any>null);
    }
}

@Injectable()
export class OutPutInStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateOutPutInStorageBill(body: AddOrUpdateOutPutInStorageBillInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddOrUpdateOutPutInStorageBill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateOutPutInStorageBill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateOutPutInStorageBill(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateOutPutInStorageBill(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOutPutInStorageBills(body: GetOutPutInStorageBillInput | undefined): Observable<PagedResultDtoOfGetOutPutInStorageBillDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetOutPutInStorageBills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutPutInStorageBills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutPutInStorageBills(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOutPutInStorageBillDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOutPutInStorageBillDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutPutInStorageBills(response: HttpResponseBase): Observable<PagedResultDtoOfGetOutPutInStorageBillDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetOutPutInStorageBillDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetOutPutInStorageBillDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOutPutInStorageRecords(body: GetOutPutInStorageRecordInput | undefined): Observable<PagedResultDtoOfGetOutPutInStorageRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetOutPutInStorageRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutPutInStorageRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutPutInStorageRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOutPutInStorageRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOutPutInStorageRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutPutInStorageRecords(response: HttpResponseBase): Observable<PagedResultDtoOfGetOutPutInStorageRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetOutPutInStorageRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetOutPutInStorageRecordDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOutPutInStorageBillFromOrder(tenantId: number | null | undefined, storeId: number | null | undefined, body: AddOrUpdateOutPutInStorageBillInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddOutPutInStorageBillFromOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "StoreId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOutPutInStorageBillFromOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOutPutInStorageBillFromOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOutPutInStorageBillFromOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param pricesScope (optional) 
     * @param categoryIds (optional) 
     * @param storeIds (optional) 
     * @param tagIds (optional) 
     * @param rfidCode (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkus(pricesScope: string | null | undefined, categoryIds: number[] | null | undefined, storeIds: number[] | null | undefined, tagIds: number[] | null | undefined, rfidCode: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfExternalSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetSkus?";
        if (pricesScope !== undefined && pricesScope !== null)
            url_ += "PricesScope=" + encodeURIComponent("" + pricesScope) + "&";
        if (categoryIds !== undefined && categoryIds !== null)
            categoryIds && categoryIds.forEach(item => { url_ += "CategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds !== undefined && storeIds !== null)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (rfidCode !== undefined && rfidCode !== null)
            url_ += "RfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfExternalSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkus(response: HttpResponseBase): Observable<PagedResultDtoOfExternalSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfExternalSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfExternalSkuDto>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @param skuId (optional) 
     * @param ignoreStore (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuRfids(storeId: number[] | null | undefined, skuId: number | null | undefined, ignoreStore: boolean | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetSkuRfidDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetSkuRfids?";
        if (storeId !== undefined && storeId !== null)
            storeId && storeId.forEach(item => { url_ += "StoreId=" + encodeURIComponent("" + item) + "&"; });
        if (skuId !== undefined && skuId !== null)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (ignoreStore === null)
            throw new Error("The parameter 'ignoreStore' cannot be null.");
        else if (ignoreStore !== undefined)
            url_ += "IgnoreStore=" + encodeURIComponent("" + ignoreStore) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuRfids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuRfids(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSkuRfidDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSkuRfidDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuRfids(response: HttpResponseBase): Observable<PagedResultDtoOfGetSkuRfidDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSkuRfidDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSkuRfidDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addStorageCheck(body: AddStorageCheckInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddStorageCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStorageCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStorageCheck(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddStorageCheck(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param rfidCode (optional) 
     * @return Success
     */
    recoverRfidCode(rfidCode: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/RecoverRfidCode?";
        if (rfidCode !== undefined && rfidCode !== null)
            url_ += "rfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecoverRfidCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecoverRfidCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecoverRfidCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined && upgradeEditionId !== null)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined && recurringPaymentsEnabled !== null)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId !== undefined && paypalOrderId !== null)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }
}

@Injectable()
export class PeripheralServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPeripherals(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPeripheralDto> {
        let url_ = this.baseUrl + "/api/services/app/Peripheral/GetPeripherals?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPeripherals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPeripherals(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPeripheralDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPeripheralDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPeripherals(response: HttpResponseBase): Observable<PagedResultDtoOfPeripheralDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPeripheralDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPeripheralDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPeripheral(body: CreatePeripheralInput | undefined): Observable<PeripheralDto> {
        let url_ = this.baseUrl + "/api/services/app/Peripheral/CreatePeripheral";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePeripheral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePeripheral(<any>response_);
                } catch (e) {
                    return <Observable<PeripheralDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PeripheralDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePeripheral(response: HttpResponseBase): Observable<PeripheralDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeripheralDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PeripheralDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePeripheral(body: UpdatePeripheralInput | undefined): Observable<PeripheralDto> {
        let url_ = this.baseUrl + "/api/services/app/Peripheral/UpdatePeripheral";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePeripheral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePeripheral(<any>response_);
                } catch (e) {
                    return <Observable<PeripheralDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PeripheralDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePeripheral(response: HttpResponseBase): Observable<PeripheralDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PeripheralDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PeripheralDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePeripheral(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Peripheral/DeletePeripheral?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePeripheral(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePeripheral(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePeripheral(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    selectPeriperal(): Observable<SelectDtoOfInt32[]> {
        let url_ = this.baseUrl + "/api/services/app/Peripheral/SelectPeriperal";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectPeriperal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectPeriperal(<any>response_);
                } catch (e) {
                    return <Observable<SelectDtoOfInt32[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectDtoOfInt32[]>><any>_observableThrow(response_);
        }));
    }

    protected processSelectPeriperal(response: HttpResponseBase): Observable<SelectDtoOfInt32[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectDtoOfInt32.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectDtoOfInt32[]>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateUserPermission(body: string[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Permission/AuthenticateUserPermission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateUserPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateUserPermission(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateUserPermission(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PictureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param mac (optional) 
     * @param cameraImage (optional) 
     * @return Success
     */
    postSnapShotByDevice(subKey: string | null | undefined, mac: string | null | undefined, cameraImage: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Picture/PostSnapShotByDevice?";
        if (subKey !== undefined && subKey !== null)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (mac !== undefined && mac !== null)
            url_ += "Mac=" + encodeURIComponent("" + mac) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (cameraImage !== null && cameraImage !== undefined)
            content_.append("CameraImage", cameraImage.data, cameraImage.fileName ? cameraImage.fileName : "CameraImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSnapShotByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSnapShotByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostSnapShotByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param collectionTime (optional) 
     * @param subKey (optional) 
     * @param mac (optional) 
     * @param heatmapData (optional) 
     * @return Success
     */
    postHeatmapByDevice(collectionTime: DateTime | undefined, subKey: string | null | undefined, mac: string | null | undefined, heatmapData: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Picture/PostHeatmapByDevice?";
        if (collectionTime === null)
            throw new Error("The parameter 'collectionTime' cannot be null.");
        else if (collectionTime !== undefined)
            url_ += "CollectionTime=" + encodeURIComponent(collectionTime ? "" + collectionTime.toJSON() : "") + "&";
        if (subKey !== undefined && subKey !== null)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (mac !== undefined && mac !== null)
            url_ += "Mac=" + encodeURIComponent("" + mac) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (heatmapData !== null && heatmapData !== undefined)
            content_.append("HeatmapData", heatmapData.data, heatmapData.fileName ? heatmapData.fileName : "HeatmapData");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostHeatmapByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostHeatmapByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostHeatmapByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PriceTagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultPriceTag(body: UpdateDefaultPriceTagInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/UpdateDefaultPriceTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultPriceTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultPriceTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultPriceTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    priceTagIntegration(body: PriceTagPriceTagIntegrationInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/PriceTagIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceTagIntegration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceTagIntegration(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPriceTagIntegration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    syncProduct(body: PriceTagSyncProductInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/SyncProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncProduct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncProduct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getDefaultAndBindSkusByPriceTagId(deviceId: number | undefined): Observable<PriceDefaultDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/GetDefaultAndBindSkusByPriceTagId?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultAndBindSkusByPriceTagId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultAndBindSkusByPriceTagId(<any>response_);
                } catch (e) {
                    return <Observable<PriceDefaultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PriceDefaultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultAndBindSkusByPriceTagId(response: HttpResponseBase): Observable<PriceDefaultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceDefaultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PriceDefaultDto>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getProductPriceTags(productId: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/GetProductPriceTags?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPriceTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPriceTags(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPriceTags(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleProduct(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, organizationId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, pointRedeemType: RedeemType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSingleProduct?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProduct(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProducts(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, organizationId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, pointRedeemType: RedeemType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProuctListOutPut> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProducts?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<PagedResultDtoOfProuctListOutPut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProuctListOutPut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProuctListOutPut>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProductById(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteProductByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSkuByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductSkus(productId: number | null | undefined, skuId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuSimpleDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductSkus?";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId !== undefined && skuId !== null)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductSkus(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuSimpleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductSkus(response: HttpResponseBase): Observable<PagedResultDtoOfSkuSimpleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuSimpleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuSimpleDto>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductRfids(productId: number | undefined, skuId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetSkuRfidDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductRfids?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (skuId !== undefined && skuId !== null)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductRfids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductRfids(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSkuRfidDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSkuRfidDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductRfids(response: HttpResponseBase): Observable<PagedResultDtoOfGetSkuRfidDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSkuRfidDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSkuRfidDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSku(body: UpdateSkuInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSku(body: CreateSkuInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSku(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSku(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishSearchedProducts(body: PublishSearchedProductInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishSearchedProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSearchedProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSearchedProducts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSearchedProducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishSkuToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishSkuToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSkuToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSkuToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSkuToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishAllToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleSku(productId: number | null | undefined, skuId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSingleSku?";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId !== undefined && skuId !== null)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSku(<any>response_);
                } catch (e) {
                    return <Observable<SkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSku(response: HttpResponseBase): Observable<SkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTags(body: SetProductTagsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/SetTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setCategories(body: SetProductCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/SetCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSku(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSku?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param type (optional) 
     * @return Success
     */
    getSkuByCode(code: string | null | undefined, type: string | null | undefined): Observable<GetSkuByCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuByCode?";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuByCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuByCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuByCode(response: HttpResponseBase): Observable<GetSkuByCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuByCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuByCodeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPictures(body: GetProductPicturesInput | undefined): Observable<IdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPictures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPictures(<any>response_);
                } catch (e) {
                    return <Observable<IdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPictures(response: HttpResponseBase): Observable<IdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdPicUrlDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPicturesByItemId(body: GetProductPicturesByItemIdInput | undefined): Observable<ItemIdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPicturesByItemId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPicturesByItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPicturesByItemId(<any>response_);
                } catch (e) {
                    return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPicturesByItemId(response: HttpResponseBase): Observable<ItemIdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemIdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemIdPicUrlDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPicturesByOuterId(body: GetProductPicturesByItemIdInput | undefined): Observable<ItemIdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPicturesByOuterId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPicturesByOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPicturesByOuterId(<any>response_);
                } catch (e) {
                    return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPicturesByOuterId(response: HttpResponseBase): Observable<ItemIdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemIdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemIdPicUrlDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getIdAndNamesByOuterId(body: GetProductIdAndName | undefined): Observable<IdNameItemIdDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetIdAndNamesByOuterId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdAndNamesByOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdAndNamesByOuterId(<any>response_);
                } catch (e) {
                    return <Observable<IdNameItemIdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameItemIdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIdAndNamesByOuterId(response: HttpResponseBase): Observable<IdNameItemIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameItemIdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameItemIdDto[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductComments(productId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductCommentDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductComments?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductComments(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCommentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCommentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductComments(response: HttpResponseBase): Observable<PagedResultDtoOfProductCommentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCommentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCommentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteComments(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteComments?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCommentByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteCommentByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCommentByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCommentByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCommentByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addComments(body: CreateProductCommentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddComments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddComments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateComments(body: UpdateProductCommentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateComments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateComments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param entityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductResources(entityId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductResources?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductResources(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductResources(response: HttpResponseBase): Observable<PagedResultDtoOfEntityFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityFileDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteProductResources(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductResources?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProductResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProductResource(body: CreateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddProductResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductResource(body: UpdateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProductResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductOnlinestoreInfos(productId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductOnlineStoreInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOnlinestoreInfos?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOnlinestoreInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOnlinestoreInfos(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductOnlineStoreInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductOnlineStoreInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOnlinestoreInfos(response: HttpResponseBase): Observable<PagedResultDtoOfProductOnlineStoreInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductOnlineStoreInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductOnlineStoreInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProductOnlinestoreInfo(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductOnlinestoreInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addProductOnlinestoreInfo(body: CreateProductOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddProductOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductOnlinestoreInfo(body: UpdateProductOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProductOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuResources(skuId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuFileDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuResources?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuResources(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuResources(response: HttpResponseBase): Observable<PagedResultDtoOfSkuFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuFileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSkuResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSkuResources(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuResources?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSkuResource(body: CreateSkuResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddSkuResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSkuResource(body: UpdateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSkuResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuOnlinestoreInfos(skuId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSkuOnlineStoreInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuOnlinestoreInfos?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuOnlinestoreInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuOnlinestoreInfos(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSkuOnlineStoreInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSkuOnlineStoreInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuOnlinestoreInfos(response: HttpResponseBase): Observable<PagedResultDtoOfSkuOnlineStoreInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSkuOnlineStoreInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSkuOnlineStoreInfoDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSkuOnlinestoreInfo(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuOnlinestoreInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSkuOnlinestoreInfo(body: CreateSkuOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddSkuOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSkuOnlinestoreInfo(body: UpdateSkuOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSkuOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPropertiesByProductId(id: number | undefined): Observable<ProductPropertyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPropertiesByProductId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertiesByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertiesByProductId(<any>response_);
                } catch (e) {
                    return <Observable<ProductPropertyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPropertyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertiesByProductId(response: HttpResponseBase): Observable<ProductPropertyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductPropertyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPropertyDto[]>(<any>null);
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedProductIds(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, organizationId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, pointRedeemType: RedeemType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IdAndTotalCount[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPagedProductIds?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedProductIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedProductIds(<any>response_);
                } catch (e) {
                    return <Observable<IdAndTotalCount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdAndTotalCount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedProductIds(response: HttpResponseBase): Observable<IdAndTotalCount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdAndTotalCount.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdAndTotalCount[]>(<any>null);
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductToExcel(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, organizationId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, pointRedeemType: RedeemType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductToExcel?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductToExcelTask(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, organizationId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, pointRedeemType: RedeemType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductToExcelTask?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductToExcelTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductToExcelTask(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductToExcelTask(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getRegions(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegions(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class ProductCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getproductCategories(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetproductCategories?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetproductCategories(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleProductCategory(id: number | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetSingleProductCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProductCategory(body: CreateProductCategoryInput | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/CreateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductCategory(body: UpdateProductCategoryInput | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/UpdateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProductCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/DeleteProductCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCategoryTrees(): Observable<ProductCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetCategoryTrees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTrees(response: HttpResponseBase): Observable<ProductCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategoryTreeById(id: number | undefined): Observable<ProductCategoryTreeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetCategoryTreeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTreeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTreeById(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryTreeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryTreeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTreeById(response: HttpResponseBase): Observable<ProductCategoryTreeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryTreeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryTreeItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateProductCategory(body: AddOrUpdateProductCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/AddOrUpdateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateProductCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUserName?";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PromotionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdatePromotion(body: AddOrUpdatePromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/AddOrUpdatePromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdatePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdatePromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdatePromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param promotionType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPromotions(promotionType: PromotionTypeEnum | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetPromotioDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/GetPromotions?";
        if (promotionType === null)
            throw new Error("The parameter 'promotionType' cannot be null.");
        else if (promotionType !== undefined)
            url_ += "PromotionType=" + encodeURIComponent("" + promotionType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromotions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPromotioDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPromotioDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromotions(response: HttpResponseBase): Observable<PagedResultDtoOfGetPromotioDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetPromotioDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPromotioDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePromotions(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/DeletePromotions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePromotions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePromotions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateProductsToPromotion(body: AddOrUpdateProductsToPromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/AddOrUpdateProductsToPromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateProductsToPromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateProductsToPromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateProductsToPromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param promotionId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductPromotions(promotionId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetProductPromotionDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/GetProductPromotions?";
        if (promotionId === null)
            throw new Error("The parameter 'promotionId' cannot be null.");
        else if (promotionId !== undefined)
            url_ += "PromotionId=" + encodeURIComponent("" + promotionId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPromotions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetProductPromotionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetProductPromotionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPromotions(response: HttpResponseBase): Observable<PagedResultDtoOfGetProductPromotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetProductPromotionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetProductPromotionDto>(<any>null);
    }
}

@Injectable()
export class PropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Property/Gets?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPropertyDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSignle(id: number | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Property/GetSignle?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignle(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSignle(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePropertyInput | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Property/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePropertyInput | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Property/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Property/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param propertyId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(propertyId: number | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/PropertyValue/Gets?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PagedResultDtoOfPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreatePropertyValueInput | undefined): Observable<PropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/PropertyValue/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<PropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<PropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePropertyValueInput | undefined): Observable<PropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/PropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<PropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<PropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyValueDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReleaseApiTestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    releaseApiTest(): Observable<NameValueTimeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ReleaseApiTest/ReleaseApiTest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseApiTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseApiTest(<any>response_);
                } catch (e) {
                    return <Observable<NameValueTimeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueTimeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseApiTest(response: HttpResponseBase): Observable<NameValueTimeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueTimeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueTimeDto[]>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCountReportGet(body: GetCountReportInput | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCountReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountReportGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountReportGet(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountReportGet(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCountReportPost(body: GetCountReportInput | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCountReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountReportPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountReportPost(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountReportPost(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getStoresCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetStoresCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getProductsCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetProductsCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getAdsCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetAdsCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getDevicesCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetDevicesCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @return Success
     */
    getOnlineDevicesCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetOnlineDevicesCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnlineDevicesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnlineDevicesCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnlineDevicesCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class ResourceFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @param fileType (optional) 
     * @param fileArea (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getResources(id: number | null | undefined, fileType: FileType | undefined, fileArea: FileArea | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfResourceFileDto> {
        let url_ = this.baseUrl + "/api/services/app/ResourceFile/GetResources?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "FileType=" + encodeURIComponent("" + fileType) + "&";
        if (fileArea === null)
            throw new Error("The parameter 'fileArea' cannot be null.");
        else if (fileArea !== undefined)
            url_ += "FileArea=" + encodeURIComponent("" + fileArea) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResources(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfResourceFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfResourceFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetResources(response: HttpResponseBase): Observable<PagedResultDtoOfResourceFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfResourceFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfResourceFileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createResource(body: CreateResourceFileInput | undefined): Observable<ResourceFileDto> {
        let url_ = this.baseUrl + "/api/services/app/ResourceFile/CreateResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateResource(<any>response_);
                } catch (e) {
                    return <Observable<ResourceFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResourceFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateResource(response: HttpResponseBase): Observable<ResourceFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResourceFileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateResource(body: UpdateResourceFileInput | undefined): Observable<ResourceFileDto> {
        let url_ = this.baseUrl + "/api/services/app/ResourceFile/UpdateResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResource(<any>response_);
                } catch (e) {
                    return <Observable<ResourceFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResourceFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateResource(response: HttpResponseBase): Observable<ResourceFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResourceFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResourceFileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ResourceFile/DeleteResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setTags(body: SetResourceTagsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ResourceFile/SetTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetRolesInput | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    registerDevice(subKey: string | null | undefined, body: RegisterDeviceInput | undefined): Observable<DeviceOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/RegisterDevice?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterDevice(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterDevice(response: HttpResponseBase): Observable<DeviceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    priceTagIntegration(body: PriceTagIntegrationWithSubkeyInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PriceTagIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceTagIntegration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceTagIntegration(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPriceTagIntegration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    createDeviceByGatewaySubKey(subKey: string | null | undefined, body: CreateDeviceInput | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/CreateDeviceByGatewaySubKey?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceByGatewaySubKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceByGatewaySubKey(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceByGatewaySubKey(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateStatusByGatewaySubKey(subKey: string | null | undefined, body: UpdateDeviceStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UpdateStatusByGatewaySubKey?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatusByGatewaySubKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatusByGatewaySubKey(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatusByGatewaySubKey(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStatusByType(body: UpdateDeviceStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UpdateStatusByType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatusByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatusByType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatusByType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param body (optional) 
     * @return Success
     */
    deviceHeartBeat(subKey: string | null | undefined, body: DeviceHeartBeatInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DeviceHeartBeat?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeviceHeartBeat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeviceHeartBeat(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeviceHeartBeat(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param hardwareCode (optional) 
     * @return Success
     */
    getDeviceSubkeyByHardwareCode(hardwareCode: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDeviceSubkeyByHardwareCode?";
        if (hardwareCode !== undefined && hardwareCode !== null)
            url_ += "hardwareCode=" + encodeURIComponent("" + hardwareCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceSubkeyByHardwareCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceSubkeyByHardwareCode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceSubkeyByHardwareCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    smartstoreDeviceStatusFeedback(deviceId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/SmartstoreDeviceStatusFeedback?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSmartstoreDeviceStatusFeedback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSmartstoreDeviceStatusFeedback(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSmartstoreDeviceStatusFeedback(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getTenantAndOrganizationUnitInfo(subKey: string | null | undefined): Observable<TenantAndOrganizationUnitAndStoreOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetTenantAndOrganizationUnitInfo?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantAndOrganizationUnitInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantAndOrganizationUnitInfo(<any>response_);
                } catch (e) {
                    return <Observable<TenantAndOrganizationUnitAndStoreOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantAndOrganizationUnitAndStoreOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantAndOrganizationUnitInfo(response: HttpResponseBase): Observable<TenantAndOrganizationUnitAndStoreOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantAndOrganizationUnitAndStoreOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantAndOrganizationUnitAndStoreOutput>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getDeviceInfo(subKey: string | null | undefined): Observable<DeviceOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDeviceInfo?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceInfo(<any>response_);
                } catch (e) {
                    return <Observable<DeviceOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceInfo(response: HttpResponseBase): Observable<DeviceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceOutput>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApps(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDeviceSoftwareSdkModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetApps?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApps(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceSoftwareSdkModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceSoftwareSdkModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetApps(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceSoftwareSdkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceSoftwareSdkModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceSoftwareSdkModel>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProducts(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductSdkModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProducts?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductSdkModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductSdkModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<PagedResultDtoOfProductSdkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductSdkModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductSdkModel>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param outerId (optional) 
     * @return Success
     */
    getProductBySubKeyAndSkuOuterId(subkey: string | null | undefined, outerId: string | null | undefined): Observable<GetProductBySubKeyAndOuterIdOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductBySubKeyAndSkuOuterId?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (outerId !== undefined && outerId !== null)
            url_ += "OuterId=" + encodeURIComponent("" + outerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBySubKeyAndSkuOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBySubKeyAndSkuOuterId(<any>response_);
                } catch (e) {
                    return <Observable<GetProductBySubKeyAndOuterIdOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductBySubKeyAndOuterIdOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductBySubKeyAndSkuOuterId(response: HttpResponseBase): Observable<GetProductBySubKeyAndOuterIdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductBySubKeyAndOuterIdOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductBySubKeyAndOuterIdOutput>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductCategories(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProductCategorySDKModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductCategories?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategorySDKModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategorySDKModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategories(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategorySDKModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategorySDKModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategorySDKModel>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param startTime (optional) 
     * @return Success
     */
    getAdAndAppTimelinesInAWeek(subKey: string | null | undefined, startTime: DateTime | undefined): Observable<AdAndAppTimelineScheduleDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAdAndAppTimelinesInAWeek?";
        if (subKey !== undefined && subKey !== null)
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdAndAppTimelinesInAWeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdAndAppTimelinesInAWeek(<any>response_);
                } catch (e) {
                    return <Observable<AdAndAppTimelineScheduleDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdAndAppTimelineScheduleDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdAndAppTimelinesInAWeek(response: HttpResponseBase): Observable<AdAndAppTimelineScheduleDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdAndAppTimelineScheduleDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdAndAppTimelineScheduleDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTagSdkModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetTags?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagSdkModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagSdkModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<PagedResultDtoOfTagSdkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagSdkModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagSdkModel>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMatchInfos(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetMatchInfos?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchInfos(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchInfos(response: HttpResponseBase): Observable<PagedResultDtoOfMatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMatchInfoDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLikeInfos(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetLikeInfos?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLikeInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLikeInfos(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLikeInfos(response: HttpResponseBase): Observable<PagedResultDtoOfLikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLikeInfoDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getBrandIdAndProductIds(tenantId: number | undefined): Observable<BrandProductDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBrandIdAndProductIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandIdAndProductIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandIdAndProductIds(<any>response_);
                } catch (e) {
                    return <Observable<BrandProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandIdAndProductIds(response: HttpResponseBase): Observable<BrandProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandProductDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getBrandIdAndSkuIds(tenantId: number | undefined): Observable<BrandSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBrandIdAndSkuIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandIdAndSkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandIdAndSkuIds(<any>response_);
                } catch (e) {
                    return <Observable<BrandSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandIdAndSkuIds(response: HttpResponseBase): Observable<BrandSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandSkuDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getSkuIds(tenantId: number | undefined): Observable<SkuIdAndOuterIdDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetSkuIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuIds(<any>response_);
                } catch (e) {
                    return <Observable<SkuIdAndOuterIdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuIdAndOuterIdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuIds(response: HttpResponseBase): Observable<SkuIdAndOuterIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkuIdAndOuterIdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuIdAndOuterIdDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStaffs(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStaffSdkModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetStaffs?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStaffs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStaffSdkModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStaffSdkModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetStaffs(response: HttpResponseBase): Observable<PagedResultDtoOfStaffSdkModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStaffSdkModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStaffSdkModel>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCoupons(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCouponDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCoupons?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoupons(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoupons(response: HttpResponseBase): Observable<PagedResultDtoOfCouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCouponDto>(<any>null);
    }

    /**
     * @param couponId (optional) 
     * @return Success
     */
    getCouponUrl(couponId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCouponUrl?";
        if (couponId === null)
            throw new Error("The parameter 'couponId' cannot be null.");
        else if (couponId !== undefined)
            url_ += "CouponId=" + encodeURIComponent("" + couponId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProperties(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSensingDevicePropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProperties?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProperties(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDevicePropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDevicePropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProperties(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDevicePropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDevicePropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDevicePropertyDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductComments(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSensingDeviceProductCommentModel> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductComments?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductComments(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSensingDeviceProductCommentModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSensingDeviceProductCommentModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductComments(response: HttpResponseBase): Observable<PagedResultDtoOfSensingDeviceProductCommentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSensingDeviceProductCommentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSensingDeviceProductCommentModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRecommendsByFaces(body: FacesRecommendsInput | undefined): Observable<FaceRecommnedsOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetRecommendsByFaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendsByFaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendsByFaces(<any>response_);
                } catch (e) {
                    return <Observable<FaceRecommnedsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FaceRecommnedsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommendsByFaces(response: HttpResponseBase): Observable<FaceRecommnedsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FaceRecommnedsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceRecommnedsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    faceRecognition(body: string | null | undefined): Observable<SimpleFaceOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/FaceRecognition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFaceRecognition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFaceRecognition(<any>response_);
                } catch (e) {
                    return <Observable<SimpleFaceOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleFaceOutput>><any>_observableThrow(response_);
        }));
    }

    protected processFaceRecognition(response: HttpResponseBase): Observable<SimpleFaceOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SimpleFaceOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleFaceOutput>(<any>null);
    }

    /**
     * @param gender (optional) 
     * @param age (optional) 
     * @param keywords (optional) 
     * @param subkey (optional) 
     * @param recognized (optional) 
     * @return Success
     */
    getInnerRecommendsByFaces(gender: string | null | undefined, age: number | undefined, keywords: string | null | undefined, subkey: string | null | undefined, recognized: boolean | undefined): Observable<FaceRecommnedsOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetInnerRecommendsByFaces?";
        if (gender !== undefined && gender !== null)
            url_ += "Gender=" + encodeURIComponent("" + gender) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (keywords !== undefined && keywords !== null)
            url_ += "Keywords=" + encodeURIComponent("" + keywords) + "&";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (recognized === null)
            throw new Error("The parameter 'recognized' cannot be null.");
        else if (recognized !== undefined)
            url_ += "Recognized=" + encodeURIComponent("" + recognized) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInnerRecommendsByFaces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInnerRecommendsByFaces(<any>response_);
                } catch (e) {
                    return <Observable<FaceRecommnedsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FaceRecommnedsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInnerRecommendsByFaces(response: HttpResponseBase): Observable<FaceRecommnedsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FaceRecommnedsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceRecommnedsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isFaceMember(body: FaceInput | undefined): Observable<FaceMemberOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/IsFaceMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsFaceMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsFaceMember(<any>response_);
                } catch (e) {
                    return <Observable<FaceMemberOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<FaceMemberOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsFaceMember(response: HttpResponseBase): Observable<FaceMemberOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FaceMemberOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceMemberOutput>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param isDeviceLevel (optional) 
     * @param deviceActivityId (optional) 
     * @param actionId (optional) 
     * @return Success
     */
    getRecommends(subkey: string, type: string | null | undefined, isDeviceLevel: boolean | undefined, deviceActivityId: number | null | undefined, actionId: number | null | undefined): Observable<RecommendsOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetRecommends?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (isDeviceLevel === null)
            throw new Error("The parameter 'isDeviceLevel' cannot be null.");
        else if (isDeviceLevel !== undefined)
            url_ += "IsDeviceLevel=" + encodeURIComponent("" + isDeviceLevel) + "&";
        if (deviceActivityId !== undefined && deviceActivityId !== null)
            url_ += "DeviceActivityId=" + encodeURIComponent("" + deviceActivityId) + "&";
        if (actionId !== undefined && actionId !== null)
            url_ += "ActionId=" + encodeURIComponent("" + actionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommends(<any>response_);
                } catch (e) {
                    return <Observable<RecommendsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecommendsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommends(response: HttpResponseBase): Observable<RecommendsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecommendsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecommendsOutput>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBrands(subkey: string | null | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBrandSdkDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBrands?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames !== undefined && tagNames !== null)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBrandSdkDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBrandSdkDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<PagedResultDtoOfBrandSdkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBrandSdkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBrandSdkDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllStoreBrandBindings(subkey: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStoreBrandBindingDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAllStoreBrandBindings?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStoreBrandBindings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStoreBrandBindings(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoreBrandBindingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoreBrandBindingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStoreBrandBindings(response: HttpResponseBase): Observable<PagedResultDtoOfStoreBrandBindingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreBrandBindingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoreBrandBindingDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getLastUpdateTime(subkey: string | null | undefined): Observable<TableLastTimeDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetLastUpdateTime?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastUpdateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastUpdateTime(<any>response_);
                } catch (e) {
                    return <Observable<TableLastTimeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TableLastTimeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastUpdateTime(response: HttpResponseBase): Observable<TableLastTimeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TableLastTimeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TableLastTimeDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param updatedTime (optional) 
     * @return Success
     */
    getNeedUpdateStatus(subkey: string | null | undefined, updatedTime: DateTime | undefined): Observable<TableNeedUpdateDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetNeedUpdateStatus?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (updatedTime === null)
            throw new Error("The parameter 'updatedTime' cannot be null.");
        else if (updatedTime !== undefined)
            url_ += "UpdatedTime=" + encodeURIComponent(updatedTime ? "" + updatedTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNeedUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNeedUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<TableNeedUpdateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TableNeedUpdateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNeedUpdateStatus(response: HttpResponseBase): Observable<TableNeedUpdateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TableNeedUpdateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TableNeedUpdateDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAppPodUpdateStatus(subkey: string, versions: string): Observable<AppPodUpdateStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAppPodUpdateStatus?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (versions === undefined || versions === null)
            throw new Error("The parameter 'versions' must be defined and cannot be null.");
        else
            url_ += "Versions=" + encodeURIComponent("" + versions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<AppPodUpdateStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodUpdateStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodUpdateStatus(response: HttpResponseBase): Observable<AppPodUpdateStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodUpdateStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodUpdateStatusDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAndroidPadResource(subkey: string): Observable<AndroidPadResDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetAndroidPadResource?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAndroidPadResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAndroidPadResource(<any>response_);
                } catch (e) {
                    return <Observable<AndroidPadResDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AndroidPadResDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAndroidPadResource(response: HttpResponseBase): Observable<AndroidPadResDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AndroidPadResDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AndroidPadResDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    productCountAndStorage(tenantId: number | undefined, storeId: number | null | undefined): Observable<GetProductsCountAndInventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/productCountAndStorage?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductCountAndStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductCountAndStorage(<any>response_);
                } catch (e) {
                    return <Observable<GetProductsCountAndInventoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductsCountAndInventoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processProductCountAndStorage(response: HttpResponseBase): Observable<GetProductsCountAndInventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductsCountAndInventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductsCountAndInventoryDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param rfideCode (optional) 
     * @return Success
     */
    getWeishopProductRfidQrcode(tenantId: number | undefined, rfideCode: string | null | undefined): Observable<RfidQrcodeDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetWeishopProductRfidQrcode?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (rfideCode !== undefined && rfideCode !== null)
            url_ += "rfideCode=" + encodeURIComponent("" + rfideCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopProductRfidQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopProductRfidQrcode(<any>response_);
                } catch (e) {
                    return <Observable<RfidQrcodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RfidQrcodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopProductRfidQrcode(response: HttpResponseBase): Observable<RfidQrcodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RfidQrcodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RfidQrcodeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    queryProductsOrSkus(body: QueryProductsOrSkusInput | undefined): Observable<SimpleProductOrSkuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/QueryProductsOrSkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryProductsOrSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryProductsOrSkus(<any>response_);
                } catch (e) {
                    return <Observable<SimpleProductOrSkuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleProductOrSkuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryProductsOrSkus(response: HttpResponseBase): Observable<SimpleProductOrSkuDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleProductOrSkuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleProductOrSkuDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getDeviceReport(subkey: string | null | undefined): Observable<IndustryDeviceReportDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDeviceReport?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceReport(<any>response_);
                } catch (e) {
                    return <Observable<IndustryDeviceReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustryDeviceReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceReport(response: HttpResponseBase): Observable<IndustryDeviceReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndustryDeviceReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustryDeviceReportDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param selfPickupcode (optional) 
     * @return Success
     */
    getCargoInfoForWeimobActivity(subKey: string | null | undefined, selfPickupcode: string | null | undefined): Observable<CargoInfoForWeimobActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoInfoForWeimobActivity?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (selfPickupcode !== undefined && selfPickupcode !== null)
            url_ += "selfPickupcode=" + encodeURIComponent("" + selfPickupcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoInfoForWeimobActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoInfoForWeimobActivity(<any>response_);
                } catch (e) {
                    return <Observable<CargoInfoForWeimobActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoInfoForWeimobActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoInfoForWeimobActivity(response: HttpResponseBase): Observable<CargoInfoForWeimobActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoInfoForWeimobActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoInfoForWeimobActivityDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadDailyInfo(body: UploadDailyInfosInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UploadDailyInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDailyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDailyInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDailyInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    postPlayerDataWithMessage(body: PostPlayerDataInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostPlayerDataWithMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPlayerDataWithMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPlayerDataWithMessage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostPlayerDataWithMessage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subKeys (optional) 
     * @return Success
     */
    getIntfaDeviceIotInfos(subKeys: string[] | null | undefined): Observable<IntfaDeviceDescriptionWithId[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetIntfaDeviceIotInfos?";
        if (subKeys !== undefined && subKeys !== null)
            subKeys && subKeys.forEach(item => { url_ += "subKeys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIntfaDeviceIotInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIntfaDeviceIotInfos(<any>response_);
                } catch (e) {
                    return <Observable<IntfaDeviceDescriptionWithId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IntfaDeviceDescriptionWithId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIntfaDeviceIotInfos(response: HttpResponseBase): Observable<IntfaDeviceDescriptionWithId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IntfaDeviceDescriptionWithId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntfaDeviceDescriptionWithId[]>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getIntfaDeviceDescriptions(subKey: string | null | undefined): Observable<IntfaDeviceDescriptionWithId[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetIntfaDeviceDescriptions?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIntfaDeviceDescriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIntfaDeviceDescriptions(<any>response_);
                } catch (e) {
                    return <Observable<IntfaDeviceDescriptionWithId[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IntfaDeviceDescriptionWithId[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIntfaDeviceDescriptions(response: HttpResponseBase): Observable<IntfaDeviceDescriptionWithId[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IntfaDeviceDescriptionWithId.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntfaDeviceDescriptionWithId[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIntfaDeviceDescriptions(body: UpdateIntfaDeviceDescriptionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UpdateIntfaDeviceDescriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIntfaDeviceDescriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIntfaDeviceDescriptions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIntfaDeviceDescriptions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEcovacsQrcode(body: CreateEcovacsQrcodeInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/CreateEcovacsQrcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEcovacsQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEcovacsQrcode(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEcovacsQrcode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getRecommendProducts(subKey: string | null | undefined): Observable<ProductSdkModel[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetRecommendProducts?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductSdkModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductSdkModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommendProducts(response: HttpResponseBase): Observable<ProductSdkModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSdkModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductSdkModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getWeishopProductBySkuID(body: PDFDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetWeishopProductBySkuID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopProductBySkuID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopProductBySkuID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopProductBySkuID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param title (optional) 
     * @param isTop (optional) 
     * @param column (optional) 
     * @param body (optional) 
     * @return Success
     */
    outputfile(title: string | null | undefined, isTop: number | undefined, column: number | undefined, body: string[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/Outputfile?";
        if (title !== undefined && title !== null)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (isTop === null)
            throw new Error("The parameter 'isTop' cannot be null.");
        else if (isTop !== undefined)
            url_ += "IsTop=" + encodeURIComponent("" + isTop) + "&";
        if (column === null)
            throw new Error("The parameter 'column' cannot be null.");
        else if (column !== undefined)
            url_ += "Column=" + encodeURIComponent("" + column) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutputfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutputfile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processOutputfile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getStoresList(subKey: string | null | undefined): Observable<PagedResultDtoOfStoresDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetStoresList?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresList(response: HttpResponseBase): Observable<PagedResultDtoOfStoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoresDto>(<any>null);
    }
}

@Injectable()
export class SensingShopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getProducts(tenantId: number | undefined, memberId: number | null | undefined, body: GetSensingSdkShopInput | undefined): Observable<ShopPagedResultDtoOfProuctListOutPut> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ShopPagedResultDtoOfProuctListOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopPagedResultDtoOfProuctListOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ShopPagedResultDtoOfProuctListOutPut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopPagedResultDtoOfProuctListOutPut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopPagedResultDtoOfProuctListOutPut>(<any>null);
    }

    /**
     * @param number (optional) 
     * @return Success
     */
    sendRegisterMessage(number: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendRegisterMessage?";
        if (number !== undefined && number !== null)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendRegisterMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendRegisterMessage(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSendRegisterMessage(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param number (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    sendRegisterMessageById(number: string | null | undefined, tenantId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/SendRegisterMessageById?";
        if (number !== undefined && number !== null)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendRegisterMessageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendRegisterMessageById(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSendRegisterMessageById(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getSingleProduct(tenantId: number | undefined, memberId: number | null | undefined, body: GetSingleShopProductInput | undefined): Observable<SingleShopProductDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetSingleProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProduct(<any>response_);
                } catch (e) {
                    return <Observable<SingleShopProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SingleShopProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProduct(response: HttpResponseBase): Observable<SingleShopProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleShopProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SingleShopProductDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getproductCategories(tenantId: number | undefined, body: GetShopProductCategoriesInput | undefined): Observable<PagedResultDtoOfProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetproductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetproductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetproductCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetproductCategories(response: HttpResponseBase): Observable<PagedResultDtoOfProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProductCategoryDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getShopCategoryTrees(tenantId: number | undefined): Observable<ProductCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopCategoryTrees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopCategoryTrees(response: HttpResponseBase): Observable<ProductCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getShopSkus(tenantId: number | undefined, body: number[] | null | undefined): Observable<ShopProductSkuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopSkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopSkus(<any>response_);
                } catch (e) {
                    return <Observable<ShopProductSkuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopProductSkuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopSkus(response: HttpResponseBase): Observable<ShopProductSkuDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopProductSkuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopProductSkuDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param productId (optional) 
     * @return Success
     */
    getShopProduct(tenantId: number | undefined, productId: number | undefined): Observable<ProductTagAndCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopProduct?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductTagAndCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductTagAndCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopProduct(response: HttpResponseBase): Observable<ProductTagAndCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductTagAndCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductTagAndCategoryDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getShopSetting(tenantId: number | null | undefined): Observable<ShopSettingDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopSetting?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopSetting(<any>response_);
                } catch (e) {
                    return <Observable<ShopSettingDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopSettingDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopSetting(response: HttpResponseBase): Observable<ShopSettingDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopSettingDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopSettingDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    getShopBasicInformations(tenantId: number | undefined, memberId: number | undefined, storeId: number | null | undefined): Observable<BasicShopDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopBasicInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "StoreId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopBasicInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopBasicInformations(<any>response_);
                } catch (e) {
                    return <Observable<BasicShopDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BasicShopDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopBasicInformations(response: HttpResponseBase): Observable<BasicShopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicShopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BasicShopDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getShopLikeInfos(tenantId: number | undefined, memberId: number | undefined, body: GetShopLikeInfosInput | undefined): Observable<ShopLikeInfosDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopLikeInfos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopLikeInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopLikeInfos(<any>response_);
                } catch (e) {
                    return <Observable<ShopLikeInfosDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopLikeInfosDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopLikeInfos(response: HttpResponseBase): Observable<ShopLikeInfosDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopLikeInfosDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopLikeInfosDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getShopCarInfos(tenantId: number | undefined, storeId: number | null | undefined, memberId: number | undefined): Observable<ShopCarDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopCarInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "StoreId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopCarInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopCarInfos(<any>response_);
                } catch (e) {
                    return <Observable<ShopCarDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopCarDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopCarInfos(response: HttpResponseBase): Observable<ShopCarDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopCarDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopCarDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrDeleteShopCars(tenantId: number | undefined, memberId: number | undefined, body: AddOrUpdateShopCarsInput | undefined): Observable<ShopCarDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrDeleteShopCars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrDeleteShopCars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrDeleteShopCars(<any>response_);
                } catch (e) {
                    return <Observable<ShopCarDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopCarDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrDeleteShopCars(response: HttpResponseBase): Observable<ShopCarDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopCarDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopCarDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    deleteShopCars(tenantId: number | undefined, memberId: number | undefined, body: DeleteShopCarsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/DeleteShopCars";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopCars(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopCars(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopCars(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @return Success
     */
    getShopCollections(tenantId: number | undefined, memberId: number | undefined): Observable<PagedResultDtoOfShopCollectionDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopCollections";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopCollections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopCollections(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopCollectionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopCollectionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopCollections(response: HttpResponseBase): Observable<PagedResultDtoOfShopCollectionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopCollectionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopCollectionDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOrDeleteCollections(tenantId: number | undefined, memberId: number | undefined, body: AddOrDeleteCollectionsInput | undefined): Observable<ShopCollectionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/AddOrDeleteCollections";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrDeleteCollections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrDeleteCollections(<any>response_);
                } catch (e) {
                    return <Observable<ShopCollectionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopCollectionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrDeleteCollections(response: HttpResponseBase): Observable<ShopCollectionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShopCollectionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopCollectionDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getShopRecommendProducts(tenantId: number | undefined, body: GetShopRecommendProductsInput | undefined): Observable<PagedResultDtoOfSingleShopProductDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopRecommendProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopRecommendProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopRecommendProducts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSingleShopProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSingleShopProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopRecommendProducts(response: HttpResponseBase): Observable<PagedResultDtoOfSingleShopProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSingleShopProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSingleShopProductDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    getShopFreight(tenantId: number | undefined, memberId: number | undefined, body: GetShopFreightInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetShopFreight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopFreight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopFreight(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopFreight(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    createShopComment(tenantId: number | undefined, storeId: number | null | undefined, memberId: number | undefined, body: CreateShopCommentInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/CreateShopComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "StoreId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "MemberId": memberId !== undefined && memberId !== null ? "" + memberId : "",
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopComment(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopComment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param rfidCode (optional) 
     * @return Success
     */
    updateSkuRfid(tenantId: number | undefined, rfidCode: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UpdateSkuRfid?";
        if (rfidCode !== undefined && rfidCode !== null)
            url_ += "RfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuRfid(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuRfid(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param output (optional) 
     * @param state (optional) 
     * @return Success
     */
    updateOrInsertAccessTokenInfo(output: string | null | undefined, state: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/UpdateOrInsertAccessTokenInfo?";
        if (output !== undefined && output !== null)
            url_ += "output=" + encodeURIComponent("" + output) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrInsertAccessTokenInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrInsertAccessTokenInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrInsertAccessTokenInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param rfidCodes (optional) 
     * @return Success
     */
    getRfidCodeState(rfidCodes: string[] | null | undefined): Observable<RfidCodeStateDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingShop/GetRfidCodeState?";
        if (rfidCodes !== undefined && rfidCodes !== null)
            rfidCodes && rfidCodes.forEach(item => { url_ += "rfidCodes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfidCodeState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfidCodeState(<any>response_);
                } catch (e) {
                    return <Observable<RfidCodeStateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RfidCodeStateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfidCodeState(response: HttpResponseBase): Observable<RfidCodeStateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RfidCodeStateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RfidCodeStateDto>(<any>null);
    }
}

@Injectable()
export class SensingSkuRfidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subkey (optional) 
     * @param code (optional) 
     * @param type (optional) 
     * @return Success
     */
    getSkuByCode(subkey: string | null | undefined, code: string | null | undefined, type: string | null | undefined): Observable<GetSkuByCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingSkuRfid/GetSkuByCode?";
        if (subkey !== undefined && subkey !== null)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuByCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuByCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuByCode(response: HttpResponseBase): Observable<GetSkuByCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuByCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuByCodeDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activeOrInactivePromotion(body: ActivePromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingSkuRfid/ActiveOrInactivePromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveOrInactivePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveOrInactivePromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActiveOrInactivePromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activePromotion(body: Promotion | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingSkuRfid/ActivePromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivePromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivePromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SensingStoreIntegrationEventServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addAndSaveEvent(body: any | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingStoreIntegrationEventService/AddAndSaveEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAndSaveEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAndSaveEvent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddAndSaveEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentLoginInformationsWithOrganizationUnits(): Observable<GetCurrentLoginInformationsWithOrganizationUnitOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformationsWithOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformationsWithOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformationsWithOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsWithOrganizationUnitOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsWithOrganizationUnitOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformationsWithOrganizationUnits(response: HttpResponseBase): Observable<GetCurrentLoginInformationsWithOrganizationUnitOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsWithOrganizationUnitOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsWithOrganizationUnitOutput>(<any>null);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSetting(body: SettingInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Setting/CreateSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSetting(body: SettingInfo | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Setting/UpdateSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getSettings(): Observable<SettingInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/Setting/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<SettingInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<SettingInfo[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingInfo[]>(<any>null);
    }
}

@Injectable()
export class ShopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShopSetting(body: UpdateShopSettingInput | undefined): Observable<ShopSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/UpdateShopSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShopSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShopSetting(<any>response_);
                } catch (e) {
                    return <Observable<ShopSettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopSettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShopSetting(response: HttpResponseBase): Observable<ShopSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopSettingDto>(<any>null);
    }

    /**
     * @return Success
     */
    getShopSettings(): Observable<ShopSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopSettings(<any>response_);
                } catch (e) {
                    return <Observable<ShopSettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopSettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopSettings(response: HttpResponseBase): Observable<ShopSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopSettingDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShopSlider(body: CreateShopSliderInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/CreateShopSlider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopSlider(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopSlider(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteShopSlider(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/DeleteShopSlider?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopSlider(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopSlider(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShopSlider(body: UpdateShopSliderInput | undefined): Observable<ShopSliderDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/UpdateShopSlider";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShopSlider(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShopSlider(<any>response_);
                } catch (e) {
                    return <Observable<ShopSliderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopSliderDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShopSlider(response: HttpResponseBase): Observable<ShopSliderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopSliderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopSliderDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopSliders(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfShopSliderDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopSliders?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopSliders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopSliders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopSliderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopSliderDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopSliders(response: HttpResponseBase): Observable<PagedResultDtoOfShopSliderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopSliderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopSliderDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShopTag(body: CreateShopTagInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/CreateShopTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteShopTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/DeleteShopTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShopTag(body: UpdateShopTagInput | undefined): Observable<ShopTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/UpdateShopTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShopTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShopTag(<any>response_);
                } catch (e) {
                    return <Observable<ShopTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShopTag(response: HttpResponseBase): Observable<ShopTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopTagDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopTags(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfShopTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopTags?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopTags(response: HttpResponseBase): Observable<PagedResultDtoOfShopTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopTagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShopCategory(body: CreateShopCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/CreateShopCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteShopCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/DeleteShopCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShopCategory(body: UpdateShopCategoryInput | undefined): Observable<ShopCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/UpdateShopCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShopCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShopCategory(<any>response_);
                } catch (e) {
                    return <Observable<ShopCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShopCategory(response: HttpResponseBase): Observable<ShopCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopCategoryDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopCategories(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfShopCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopCategories?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopCategories(response: HttpResponseBase): Observable<PagedResultDtoOfShopCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopCategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShopFreight(body: CreateShopFreightInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/CreateShopFreight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopFreight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopFreight(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopFreight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteShopFreight(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/DeleteShopFreight?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopFreight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopFreight(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopFreight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShopFreight(body: UpdateShopFreightInput | undefined): Observable<ShopFreightDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/UpdateShopFreight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateShopFreight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateShopFreight(<any>response_);
                } catch (e) {
                    return <Observable<ShopFreightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShopFreightDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateShopFreight(response: HttpResponseBase): Observable<ShopFreightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShopFreightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShopFreightDto>(<any>null);
    }

    /**
     * @param status (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopFreights(status: ShopFreightStatus | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfShopFreightDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopFreights?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopFreights(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopFreights(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopFreightDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopFreightDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopFreights(response: HttpResponseBase): Observable<PagedResultDtoOfShopFreightDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopFreightDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopFreightDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bindProductWithShopFreight(body: BindProductWithShopFreightInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/BindProductWithShopFreight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindProductWithShopFreight(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindProductWithShopFreight(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindProductWithShopFreight(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShopForHost(body: CreateShopForHostInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/CreateShopForHost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShopForHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShopForHost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateShopForHost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param id (optional) 
     * @return Success
     */
    deleteShopForHost(tenantId: number | undefined, id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shop/DeleteShopForHost?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteShopForHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteShopForHost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteShopForHost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getShopsForHost(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfShopDto> {
        let url_ = this.baseUrl + "/api/services/app/Shop/GetShopsForHost?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShopsForHost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShopsForHost(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfShopDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfShopDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShopsForHost(response: HttpResponseBase): Observable<PagedResultDtoOfShopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfShopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfShopDto>(<any>null);
    }
}

@Injectable()
export class SkuRfidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateSkuRfidInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSkuRfidInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SoftwareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSoftwares4Dropdownlist(): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftwares4Dropdownlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwares4Dropdownlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwares4Dropdownlist(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwares4Dropdownlist(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @param softwareType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuthorizedSoftwares(organizationUnitId: number | null | undefined, softwareType: SoftwareType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuthorizatedSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetAuthorizedSoftwares?";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorizedSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorizedSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuthorizatedSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuthorizatedSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthorizedSoftwares(response: HttpResponseBase): Observable<PagedResultDtoOfAuthorizatedSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuthorizatedSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuthorizatedSoftwareDto>(<any>null);
    }

    /**
     * @param softwareType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getForTenantSoftwares(softwareType: SoftwareType | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetForTenantSoftwares?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForTenantSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForTenantSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForTenantSoftwares(response: HttpResponseBase): Observable<PagedResultDtoOfSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSoftwareDto>(<any>null);
    }

    /**
     * @param softwareType (optional) 
     * @param isShowToTenant (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwares(softwareType: SoftwareType | undefined, isShowToTenant: boolean | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftwares?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (isShowToTenant !== undefined && isShowToTenant !== null)
            url_ += "IsShowToTenant=" + encodeURIComponent("" + isShowToTenant) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwares(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwares(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwares(response: HttpResponseBase): Observable<PagedResultDtoOfSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSoftwareDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportSoftwareToExcel(body: GetSoftwareInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Software/ExportSoftwareToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportSoftwareToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportSoftwareToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processExportSoftwareToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleSoftware(id: number | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSingleSoftware?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSoftware(body: CreateSoftwareInput | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/CreateSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSoftware(body: UpdateSoftwareInput | undefined): Observable<SoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/UpdateSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSoftware(<any>response_);
                } catch (e) {
                    return <Observable<SoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSoftware(response: HttpResponseBase): Observable<SoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SoftwareDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSoftware(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/DeleteSoftware?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param softwareId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeAuthorizeToTenant(softwareId: number | undefined, tenantId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/RemoveAuthorizeToTenant?";
        if (softwareId === null)
            throw new Error("The parameter 'softwareId' cannot be null.");
        else if (softwareId !== undefined)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAuthorizeToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAuthorizeToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveAuthorizeToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authorizeToTenant(body: AuthorizeSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/AuthorizeToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthorizeToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthorizeToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuthorizeToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAuthorizedSoftware(body: UpdateAuthorizeSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/UpdateAuthorizedSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAuthorizedSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAuthorizedSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAuthorizedSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToTenant(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishAllToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToTenant(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishToTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/PublishAllToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param softwareId (optional) 
     * @param organizationUnitId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftWareAuthList(softwareId: number | null | undefined, organizationUnitId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDispatchedSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/Software/GetSoftWareAuthList?";
        if (softwareId !== undefined && softwareId !== null)
            url_ += "SoftwareId=" + encodeURIComponent("" + softwareId) + "&";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftWareAuthList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftWareAuthList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDispatchedSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDispatchedSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftWareAuthList(response: HttpResponseBase): Observable<PagedResultDtoOfDispatchedSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDispatchedSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDispatchedSoftwareDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeviceSoftware(body: UpdateDeviceSoftwareInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Software/UpdateDeviceSoftware";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceSoftware(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceSoftware(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceSoftware(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StaffServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateStaffs(body: AddOrUpdateStaffs | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Staff/AddOrUpdateStaffs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateStaffs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateStaffs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateStaffs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSimpleStorePosition(): Observable<SimpleStorePositionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetSimpleStorePosition";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSimpleStorePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSimpleStorePosition(<any>response_);
                } catch (e) {
                    return <Observable<SimpleStorePositionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleStorePositionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSimpleStorePosition(response: HttpResponseBase): Observable<SimpleStorePositionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleStorePositionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleStorePositionDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePositionLngAndLat(body: SimpleStorePositionInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/UpdatePositionLngAndLat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePositionLngAndLat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePositionLngAndLat(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePositionLngAndLat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getStores(): Observable<ListResultDtoOfStoresDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStores(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfStoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfStoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStores(response: HttpResponseBase): Observable<ListResultDtoOfStoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfStoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfStoresDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStoresList(body: GetStorseListInput | undefined): Observable<PagedResultDtoOfStoresDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStoresList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresList(response: HttpResponseBase): Observable<PagedResultDtoOfStoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoresDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getStoresToExcel(body: GetStorseListInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStoresToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @return Success
     */
    getStoreById(storeId: number | undefined): Observable<StoresDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStoreById?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreById(<any>response_);
                } catch (e) {
                    return <Observable<StoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreById(response: HttpResponseBase): Observable<StoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoresDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStorePosition(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStorePositionDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStorePosition?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorePosition(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStorePositionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStorePositionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorePosition(response: HttpResponseBase): Observable<PagedResultDtoOfStorePositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStorePositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStorePositionDto>(<any>null);
    }

    /**
     * @param includeOfflineStore (optional) 
     * @return Success
     */
    getCurrentTenantOrganizationUnitsAndStoresTree(includeOfflineStore: boolean | undefined): Observable<TreeDtoOfInt64> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetCurrentTenantOrganizationUnitsAndStoresTree?";
        if (includeOfflineStore === null)
            throw new Error("The parameter 'includeOfflineStore' cannot be null.");
        else if (includeOfflineStore !== undefined)
            url_ += "includeOfflineStore=" + encodeURIComponent("" + includeOfflineStore) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentTenantOrganizationUnitsAndStoresTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentTenantOrganizationUnitsAndStoresTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeDtoOfInt64>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeDtoOfInt64>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentTenantOrganizationUnitsAndStoresTree(response: HttpResponseBase): Observable<TreeDtoOfInt64> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeDtoOfInt64.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeDtoOfInt64>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentTenantSimpleOrganizationUnitsAndStoresTree(): Observable<TreeDtoOfInt64> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetCurrentTenantSimpleOrganizationUnitsAndStoresTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentTenantSimpleOrganizationUnitsAndStoresTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentTenantSimpleOrganizationUnitsAndStoresTree(<any>response_);
                } catch (e) {
                    return <Observable<TreeDtoOfInt64>><any>_observableThrow(e);
                }
            } else
                return <Observable<TreeDtoOfInt64>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentTenantSimpleOrganizationUnitsAndStoresTree(response: HttpResponseBase): Observable<TreeDtoOfInt64> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreeDtoOfInt64.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreeDtoOfInt64>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStore(body: CreateStoreInput | undefined): Observable<StoresDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/CreateStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStore(<any>response_);
                } catch (e) {
                    return <Observable<StoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStore(response: HttpResponseBase): Observable<StoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoresDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStore(body: UpdateStoreInput | undefined): Observable<StoresDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/UpdateStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStore(<any>response_);
                } catch (e) {
                    return <Observable<StoresDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoresDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStore(response: HttpResponseBase): Observable<StoresDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoresDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStore(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/DeleteStore?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteStores(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/DeleteStores?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStores(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStores(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ouId (optional) 
     * @return Success
     */
    getStoresByOrganizationUnitId(ouId: number | undefined): Observable<Store[]> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStoresByOrganizationUnitId?";
        if (ouId === null)
            throw new Error("The parameter 'ouId' cannot be null.");
        else if (ouId !== undefined)
            url_ += "ouId=" + encodeURIComponent("" + ouId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresByOrganizationUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresByOrganizationUnitId(<any>response_);
                } catch (e) {
                    return <Observable<Store[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Store[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresByOrganizationUnitId(response: HttpResponseBase): Observable<Store[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Store.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Store[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishToOrganization(body: PublishStoresInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/PublishToOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganization(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganization(body: PublishStoresInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/PublishAllToOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganization(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getStoreDevicesInfos(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetStoreDevicesInfos";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreDevicesInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreDevicesInfos(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreDevicesInfos(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    storeAudit(body: StoreAuditInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Store/StoreAudit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStoreAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStoreAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStoreAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StoreAdsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditStatus (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAdsByStoreId(auditStatus: AuditStatus | undefined, storeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAdListDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreAds/GetAdsByStoreId?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAdListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAdListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdsByStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfAdListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAdListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAdListDto>(<any>null);
    }
}

@Injectable()
export class StoreCouponsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param auditStatus (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCouponsByStoreId(auditStatus: AuditStatus | undefined, storeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCouponOutDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreCoupons/GetCouponsByStoreId?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCouponOutDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponsByStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfCouponOutDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCouponOutDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCouponOutDto>(<any>null);
    }
}

@Injectable()
export class StoreExtraServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStoreExtra(body: CreateStoreExtraInput | undefined): Observable<StoreExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreExtra/CreateStoreExtra";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStoreExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStoreExtra(<any>response_);
                } catch (e) {
                    return <Observable<StoreExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStoreExtra(response: HttpResponseBase): Observable<StoreExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreExtraDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStoreExtra(body: UpdateStoreExtraInput | undefined): Observable<StoreExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreExtra/UpdateStoreExtra";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStoreExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStoreExtra(<any>response_);
                } catch (e) {
                    return <Observable<StoreExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStoreExtra(response: HttpResponseBase): Observable<StoreExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreExtraDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStoreExtra(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreExtra/DeleteStoreExtra?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStoreExtra(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStoreExtra(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStoreExtra(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param externalEnum (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStoreExtras(externalEnum: ExternalEnum | undefined, storeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStoreExtraDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreExtra/GetStoreExtras?";
        if (externalEnum === null)
            throw new Error("The parameter 'externalEnum' cannot be null.");
        else if (externalEnum !== undefined)
            url_ += "ExternalEnum=" + encodeURIComponent("" + externalEnum) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreExtras(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreExtras(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoreExtraDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoreExtraDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreExtras(response: HttpResponseBase): Observable<PagedResultDtoOfStoreExtraDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreExtraDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoreExtraDto>(<any>null);
    }
}

@Injectable()
export class StoreKPIServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param storeId (optional) 
     * @param scaleTimeStart (optional) 
     * @param scaleTimeEnd (optional) 
     * @param kPIScale (optional) 
     * @param name (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStoreKPIs(storeId: number | undefined, scaleTimeStart: DateTime | null | undefined, scaleTimeEnd: DateTime | null | undefined, kPIScale: GroupKPIScaleEnum | undefined, name: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfStoreKPIDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/GetStoreKPIs?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (scaleTimeStart !== undefined && scaleTimeStart !== null)
            url_ += "ScaleTimeStart=" + encodeURIComponent(scaleTimeStart ? "" + scaleTimeStart.toJSON() : "") + "&";
        if (scaleTimeEnd !== undefined && scaleTimeEnd !== null)
            url_ += "ScaleTimeEnd=" + encodeURIComponent(scaleTimeEnd ? "" + scaleTimeEnd.toJSON() : "") + "&";
        if (kPIScale === null)
            throw new Error("The parameter 'kPIScale' cannot be null.");
        else if (kPIScale !== undefined)
            url_ += "KPIScale=" + encodeURIComponent("" + kPIScale) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreKPIs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfStoreKPIDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfStoreKPIDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreKPIs(response: HttpResponseBase): Observable<PagedResultDtoOfStoreKPIDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfStoreKPIDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfStoreKPIDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStoreKPI(body: CreateStoreKpiDtoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/CreateStoreKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateStoreKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateStoreKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateStoreKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStoreKPI(body: UpdateStoreKpiDtoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/UpdateStoreKPI";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStoreKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStoreKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStoreKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSingleGroupKPI(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/DeleteSingleGroupKPI?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSingleGroupKPI(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSingleGroupKPI(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSingleGroupKPI(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteGroupKPIs(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/DeleteGroupKPIs?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroupKPIs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroupKPIs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGroupKPIs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @return Success
     */
    getKpiNames(storeId: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/StoreKPI/GetKpiNames?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKpiNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKpiNames(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKpiNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class StoreProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param currentProductId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param auditStatus (optional) 
     * @param tagIds (optional) 
     * @param catetoryIds (optional) 
     * @param price1 (optional) 
     * @param price2 (optional) 
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) 
     * @param isSearchSku (optional) 
     * @param storeId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductsByStoreId(currentProductId: number | undefined, startTime: DateTime | null | undefined, endTime: DateTime | null | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | null | undefined, catetoryIds: number[] | null | undefined, price1: number | null | undefined, price2: number | null | undefined, stock: string | null | undefined, salesVolume: string | null | undefined, sortStatus: string | null | undefined, isSearchSku: boolean | null | undefined, storeId: number | null | undefined, language: string | null | undefined, region: string | null | undefined, brandIds: number[] | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfProuctListOutPut> {
        let url_ = this.baseUrl + "/api/services/app/StoreProduct/GetProductsByStoreId?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds !== undefined && catetoryIds !== null)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 !== undefined && price1 !== null)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 !== undefined && price2 !== null)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock !== undefined && stock !== null)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume !== undefined && salesVolume !== null)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus !== undefined && sortStatus !== null)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku !== undefined && isSearchSku !== null)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (language !== undefined && language !== null)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region !== undefined && region !== null)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds !== undefined && brandIds !== null)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfProuctListOutPut>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfProuctListOutPut> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfProuctListOutPut.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfProuctListOutPut>(<any>null);
    }
}

@Injectable()
export class StoreSoftwareServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param softwareType (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSoftwaresByStoreId(softwareType: SoftwareType | undefined, storeId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSoftwareDto> {
        let url_ = this.baseUrl + "/api/services/app/StoreSoftware/GetSoftwaresByStoreId?";
        if (softwareType === null)
            throw new Error("The parameter 'softwareType' cannot be null.");
        else if (softwareType !== undefined)
            url_ += "SoftwareType=" + encodeURIComponent("" + softwareType) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSoftwaresByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSoftwaresByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSoftwareDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSoftwaresByStoreId(response: HttpResponseBase): Observable<PagedResultDtoOfSoftwareDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSoftwareDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSoftwareDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId !== undefined && stripeSessionId !== null)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(<any>response_);
                } catch (e) {
                    return <Observable<StripePaymentResultOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripePaymentResultOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripePaymentResultOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTagsToExcel(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: TagType | undefined): Observable<PagedResultDtoOfTagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<PagedResultDtoOfTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class TaobaoOpenPlatformServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTaobaoOpenPlatformList(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTaobaoOpenPlatformDto> {
        let url_ = this.baseUrl + "/api/services/app/TaobaoOpenPlatform/GetTaobaoOpenPlatformList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaobaoOpenPlatformList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaobaoOpenPlatformList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTaobaoOpenPlatformDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTaobaoOpenPlatformDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaobaoOpenPlatformList(response: HttpResponseBase): Observable<PagedResultDtoOfTaobaoOpenPlatformDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTaobaoOpenPlatformDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTaobaoOpenPlatformDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTaobaoOpenPlatform(body: CreateTaobaoOpenPlatformInput | undefined): Observable<TaobaoOpenPlatformDto> {
        let url_ = this.baseUrl + "/api/services/app/TaobaoOpenPlatform/CreateTaobaoOpenPlatform";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTaobaoOpenPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTaobaoOpenPlatform(<any>response_);
                } catch (e) {
                    return <Observable<TaobaoOpenPlatformDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaobaoOpenPlatformDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTaobaoOpenPlatform(response: HttpResponseBase): Observable<TaobaoOpenPlatformDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaobaoOpenPlatformDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaobaoOpenPlatformDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTaobaoOpenPlatform(body: UpdateTaobaoOpenPlatformInput | undefined): Observable<TaobaoOpenPlatformDto> {
        let url_ = this.baseUrl + "/api/services/app/TaobaoOpenPlatform/UpdateTaobaoOpenPlatform";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTaobaoOpenPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaobaoOpenPlatform(<any>response_);
                } catch (e) {
                    return <Observable<TaobaoOpenPlatformDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaobaoOpenPlatformDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTaobaoOpenPlatform(response: HttpResponseBase): Observable<TaobaoOpenPlatformDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaobaoOpenPlatformDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaobaoOpenPlatformDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTaobaoOpenPlatform(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaobaoOpenPlatform/DeleteTaobaoOpenPlatform?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaobaoOpenPlatform(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaobaoOpenPlatform(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaobaoOpenPlatform(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: DateTime | null | undefined, subscriptionEndDateEnd: DateTime | null | undefined, creationDateStart: DateTime | null | undefined, creationDateEnd: DateTime | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | undefined, sorting: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart !== undefined && subscriptionEndDateStart !== null)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&";
        if (subscriptionEndDateEnd !== undefined && subscriptionEndDateEnd !== null)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&";
        if (creationDateStart !== undefined && creationDateStart !== null)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&";
        if (creationDateEnd !== undefined && creationDateEnd !== null)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&";
        if (editionId !== undefined && editionId !== null)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(<any>response_);
                } catch (e) {
                    return <Observable<GetTopStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTopStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTopStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(<any>response_);
                } catch (e) {
                    return <Observable<GetProfitShareOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfitShareOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfitShareOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(<any>response_);
                } catch (e) {
                    return <Observable<GetDailySalesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDailySalesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDailySalesOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginSettingsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginSettingsDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined && selectedTimezoneId !== null)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken !== undefined && impersonationToken !== null)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined && switchAccountToken !== null)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined && message !== null)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity !== undefined && severity !== null)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param organizationUnitId (optional) 
     * @return Success
     */
    setOrganizationUnitId(organizationUnitId: number | null | undefined): Observable<UserTenantOUDto> {
        let url_ = this.baseUrl + "/api/TokenAuth/SetOrganizationUnitId?";
        if (organizationUnitId !== undefined && organizationUnitId !== null)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrganizationUnitId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrganizationUnitId(<any>response_);
                } catch (e) {
                    return <Observable<UserTenantOUDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTenantOUDto>><any>_observableThrow(response_);
        }));
    }

    protected processSetOrganizationUnitId(response: HttpResponseBase): Observable<UserTenantOUDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTenantOUDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTenantOUDto>(<any>null);
    }

    /**
     * @param unionId (optional) 
     * @return Success
     */
    loginWithUserUnionId(unionId: string | null | undefined): Observable<AuthenticateResultModelWithTenant> {
        let url_ = this.baseUrl + "/api/TokenAuth/LoginWithUserUnionId?";
        if (unionId !== undefined && unionId !== null)
            url_ += "unionId=" + encodeURIComponent("" + unionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginWithUserUnionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginWithUserUnionId(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModelWithTenant>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModelWithTenant>><any>_observableThrow(response_);
        }));
    }

    protected processLoginWithUserUnionId(response: HttpResponseBase): Observable<AuthenticateResultModelWithTenant> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModelWithTenant.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModelWithTenant>(<any>null);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(<any>response_);
                } catch (e) {
                    return <Observable<TwitterGetRequestTokenResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TwitterGetRequestTokenResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetRequestTokenResponse>(<any>null);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | null | undefined, verifier: string | null | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier !== undefined && verifier !== null)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(<any>response_);
                } catch (e) {
                    return <Observable<TwitterGetAccessTokenResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TwitterGetAccessTokenResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TwitterGetAccessTokenResponse>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined && themeName !== null)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetUsersInput | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions !== undefined && permissions !== null)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined && role !== null)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDelegationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDelegationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDelegationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(<any>response_);
                } catch (e) {
                    return <Observable<UserDelegationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDelegationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDelegationDto[]>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WebhookEvent>><any>_observableThrow(e);
                }
            } else
                return <Observable<WebhookEvent>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookEvent>(<any>null);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAllSendAttemptsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAllSendAttemptsOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | null | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>(<any>null);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId !== undefined && sendAttemptId !== null)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | null | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId !== undefined && subscriptionId !== null)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(<any>response_);
                } catch (e) {
                    return <Observable<WebhookSubscription>><any>_observableThrow(e);
                }
            } else
                return <Observable<WebhookSubscription>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebhookSubscription>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | null | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName !== undefined && webhookName !== null)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllSubscriptionsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllSubscriptionsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllAvailableWebhooksOutput>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data; 
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export enum AuditStatus {
    Offline = 0,
    Online = 1,
}

export enum AdsType {
    Single = 1,
    Multi = 2,
}

export class IdNameDto implements IIdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class AdListDto implements IAdListDto {
    name!: string;
    organizationUnitId!: number | undefined;
    resourceType!: string | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    adsTags!: IdNameDto[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    fileUrl!: string | undefined;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: DateTime | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isMine!: boolean;
    isCustom!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceType = _data["resourceType"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(IdNameDto.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.fileUrl = _data["fileUrl"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceType"] = this.resourceType;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["fileUrl"] = this.fileUrl;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdListDto {
    name: string;
    organizationUnitId: number | undefined;
    resourceType: string | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    adsTags: IdNameDto[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    fileUrl: string | undefined;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: DateTime | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isMine: boolean;
    isCustom: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfAdListDto implements IPagedResultDtoOfAdListDto {
    totalCount!: number;
    items!: AdListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAdListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAdListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAdListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAdListDto {
    totalCount: number;
    items: AdListDto[] | undefined;
}

export class AdDto implements IAdDto {
    name!: string;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    resourceId!: number;
    resourceType!: string | undefined;
    fileUrl!: string | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    adsTags!: IdNameDto[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: DateTime | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isMine!: boolean;
    isCustom!: boolean;
    customContent!: string | undefined;
    robotMapName!: string | undefined;
    robotMapPointName!: string | undefined;
    guideWord!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceId = _data["resourceId"];
            this.resourceType = _data["resourceType"];
            this.fileUrl = _data["fileUrl"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(IdNameDto.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["fileUrl"] = this.fileUrl;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdDto {
    name: string;
    tenantId: number;
    organizationUnitId: number | undefined;
    resourceId: number;
    resourceType: string | undefined;
    fileUrl: string | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    adsTags: IdNameDto[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: DateTime | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isMine: boolean;
    isCustom: boolean;
    customContent: string | undefined;
    robotMapName: string | undefined;
    robotMapPointName: string | undefined;
    guideWord: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateAdInput implements ICreateAdInput {
    name!: string;
    organizationUnitId!: number | undefined;
    resourceItemId!: number | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    tags!: number[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: DateTime | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isCustom!: boolean;
    customContent!: string | undefined;
    robotMapName!: string | undefined;
    robotMapPointName!: string | undefined;
    guideWord!: string | undefined;

    constructor(data?: ICreateAdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
        }
    }

    static fromJS(data: any): CreateAdInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        return data; 
    }
}

export interface ICreateAdInput {
    name: string;
    organizationUnitId: number | undefined;
    resourceItemId: number | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    tags: number[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: DateTime | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isCustom: boolean;
    customContent: string | undefined;
    robotMapName: string | undefined;
    robotMapPointName: string | undefined;
    guideWord: string | undefined;
}

export class AdResourcesFileDto implements IAdResourcesFileDto {
    adId!: number;
    resourceItemId!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    category!: string | undefined;
    fromType!: string | undefined;
    type!: string | undefined;
    created!: DateTime | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdResourcesFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.resourceItemId = _data["resourceItemId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdResourcesFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdResourcesFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["resourceItemId"] = this.resourceItemId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toString() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdResourcesFileDto {
    adId: number;
    resourceItemId: number;
    name: string | undefined;
    fileUrl: string | undefined;
    category: string | undefined;
    fromType: string | undefined;
    type: string | undefined;
    created: DateTime | undefined;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfAdResourcesFileDto implements IPagedResultDtoOfAdResourcesFileDto {
    totalCount!: number;
    items!: AdResourcesFileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAdResourcesFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdResourcesFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAdResourcesFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAdResourcesFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAdResourcesFileDto {
    totalCount: number;
    items: AdResourcesFileDto[] | undefined;
}

export class AddAdResourceFileInput implements IAddAdResourceFileInput {
    id!: number | undefined;
    fileUrl!: string;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    adId!: number;
    orderNumber!: number;
    fromType!: string | undefined;

    constructor(data?: IAddAdResourceFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileUrl = _data["fileUrl"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.adId = _data["adId"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): AddAdResourceFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddAdResourceFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileUrl"] = this.fileUrl;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["adId"] = this.adId;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IAddAdResourceFileInput {
    id: number | undefined;
    fileUrl: string;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    adId: number;
    orderNumber: number;
    fromType: string | undefined;
}

export class UpdateAdInput implements IUpdateAdInput {
    id!: number;
    name!: string;
    organizationUnitId!: number | undefined;
    resourceItemId!: number | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    tags!: number[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: DateTime | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isCustom!: boolean;
    customContent!: string | undefined;
    robotMapName!: string | undefined;
    robotMapPointName!: string | undefined;
    guideWord!: string | undefined;

    constructor(data?: IUpdateAdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.robotMapName = _data["robotMapName"];
            this.robotMapPointName = _data["robotMapPointName"];
            this.guideWord = _data["guideWord"];
        }
    }

    static fromJS(data: any): UpdateAdInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["robotMapName"] = this.robotMapName;
        data["robotMapPointName"] = this.robotMapPointName;
        data["guideWord"] = this.guideWord;
        return data; 
    }
}

export interface IUpdateAdInput {
    id: number;
    name: string;
    organizationUnitId: number | undefined;
    resourceItemId: number | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    tags: number[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: DateTime | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isCustom: boolean;
    customContent: string | undefined;
    robotMapName: string | undefined;
    robotMapPointName: string | undefined;
    guideWord: string | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class PublishEntitiesInput implements IPublishEntitiesInput {
    entityIds!: number[] | undefined;
    ouOrDeviceOrStoreList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;
    isCreateDefaultSchedule!: boolean;
    informDevice!: boolean;
    type!: string | undefined;

    constructor(data?: IPublishEntitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(_data["ouOrDeviceOrStoreList"])) {
                this.ouOrDeviceOrStoreList = [] as any;
                for (let item of _data["ouOrDeviceOrStoreList"])
                    this.ouOrDeviceOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
            this.isCreateDefaultSchedule = _data["isCreateDefaultSchedule"];
            this.informDevice = _data["informDevice"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PublishEntitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishEntitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouOrDeviceOrStoreList)) {
            data["ouOrDeviceOrStoreList"] = [];
            for (let item of this.ouOrDeviceOrStoreList)
                data["ouOrDeviceOrStoreList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        data["isCreateDefaultSchedule"] = this.isCreateDefaultSchedule;
        data["informDevice"] = this.informDevice;
        data["type"] = this.type;
        return data; 
    }
}

export interface IPublishEntitiesInput {
    entityIds: number[] | undefined;
    ouOrDeviceOrStoreList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
    isCreateDefaultSchedule: boolean;
    informDevice: boolean;
    type: string | undefined;
}

export enum PlayType {
    Sequence = 0,
    TimeLine = 1,
}

export class GetAdSchedulingDto implements IGetAdSchedulingDto {
    id!: number;
    creationTime!: DateTime;
    name!: string | undefined;
    description!: string | undefined;
    activeTime!: DateTime;
    endTime!: DateTime;
    iconUrl!: string | undefined;
    playType!: PlayType;
    adschedulingContent!: string | undefined;
    effectiveTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAdSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? DateTime.fromISO(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.playType = _data["playType"];
            this.adschedulingContent = _data["adschedulingContent"];
            this.effectiveTime = _data["effectiveTime"] ? DateTime.fromISO(_data["effectiveTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAdSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAdSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["playType"] = this.playType;
        data["adschedulingContent"] = this.adschedulingContent;
        data["effectiveTime"] = this.effectiveTime ? this.effectiveTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetAdSchedulingDto {
    id: number;
    creationTime: DateTime;
    name: string | undefined;
    description: string | undefined;
    activeTime: DateTime;
    endTime: DateTime;
    iconUrl: string | undefined;
    playType: PlayType;
    adschedulingContent: string | undefined;
    effectiveTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
}

export class PagedResultDtoOfGetAdSchedulingDto implements IPagedResultDtoOfGetAdSchedulingDto {
    totalCount!: number;
    items!: GetAdSchedulingDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAdSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAdSchedulingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAdSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAdSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAdSchedulingDto {
    totalCount: number;
    items: GetAdSchedulingDto[] | undefined;
}

export class AddOrUpdateAdSchedulingInput implements IAddOrUpdateAdSchedulingInput {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    activeTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    iconUrl!: string | undefined;
    playType!: PlayType;

    constructor(data?: IAddOrUpdateAdSchedulingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? DateTime.fromISO(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.playType = _data["playType"];
        }
    }

    static fromJS(data: any): AddOrUpdateAdSchedulingInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAdSchedulingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["playType"] = this.playType;
        return data; 
    }
}

export interface IAddOrUpdateAdSchedulingInput {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    activeTime: DateTime | undefined;
    endTime: DateTime | undefined;
    iconUrl: string | undefined;
    playType: PlayType;
}

export class AdOrAppItem implements IAdOrAppItem {
    id!: number;
    duration!: number;
    transition!: string | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;

    constructor(data?: IAdOrAppItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.duration = _data["duration"];
            this.transition = _data["transition"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
        }
    }

    static fromJS(data: any): AdOrAppItem {
        data = typeof data === 'object' ? data : {};
        let result = new AdOrAppItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["duration"] = this.duration;
        data["transition"] = this.transition;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        return data; 
    }
}

export interface IAdOrAppItem {
    id: number;
    duration: number;
    transition: string | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
}

export class ProgramItem implements IProgramItem {
    scheduleStartTime!: string | undefined;
    scheduleEndTime!: string | undefined;
    idleAble!: boolean;
    unstoppable!: boolean;
    packageName!: string | undefined;
    children!: AdOrAppItem[] | undefined;
    type!: number;

    constructor(data?: IProgramItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scheduleStartTime = _data["scheduleStartTime"];
            this.scheduleEndTime = _data["scheduleEndTime"];
            this.idleAble = _data["idleAble"];
            this.unstoppable = _data["unstoppable"];
            this.packageName = _data["packageName"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(AdOrAppItem.fromJS(item));
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProgramItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleStartTime"] = this.scheduleStartTime;
        data["scheduleEndTime"] = this.scheduleEndTime;
        data["idleAble"] = this.idleAble;
        data["unstoppable"] = this.unstoppable;
        data["packageName"] = this.packageName;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IProgramItem {
    scheduleStartTime: string | undefined;
    scheduleEndTime: string | undefined;
    idleAble: boolean;
    unstoppable: boolean;
    packageName: string | undefined;
    children: AdOrAppItem[] | undefined;
    type: number;
}

export class SchedulingContent implements ISchedulingContent {
    id!: number | undefined;
    name!: string | undefined;
    content!: string | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    ads!: ProgramItem[] | undefined;
    playType!: PlayType;

    constructor(data?: ISchedulingContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            if (Array.isArray(_data["ads"])) {
                this.ads = [] as any;
                for (let item of _data["ads"])
                    this.ads!.push(ProgramItem.fromJS(item));
            }
            this.playType = _data["playType"];
        }
    }

    static fromJS(data: any): SchedulingContent {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulingContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["content"] = this.content;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        if (Array.isArray(this.ads)) {
            data["ads"] = [];
            for (let item of this.ads)
                data["ads"].push(item.toJSON());
        }
        data["playType"] = this.playType;
        return data; 
    }
}

export interface ISchedulingContent {
    id: number | undefined;
    name: string | undefined;
    content: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    ads: ProgramItem[] | undefined;
    playType: PlayType;
}

export class SchedulingContentInput implements ISchedulingContentInput {
    id!: number;
    schedulingContent!: SchedulingContent;

    constructor(data?: ISchedulingContentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.schedulingContent = _data["schedulingContent"] ? SchedulingContent.fromJS(_data["schedulingContent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SchedulingContentInput {
        data = typeof data === 'object' ? data : {};
        let result = new SchedulingContentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["schedulingContent"] = this.schedulingContent ? this.schedulingContent.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISchedulingContentInput {
    id: number;
    schedulingContent: SchedulingContent;
}

export class PublishContentToAdScheduling implements IPublishContentToAdScheduling {
    adSchedulingContentIds!: number[] | undefined;
    adschedulingId!: number;
    action!: string | undefined;

    constructor(data?: IPublishContentToAdScheduling) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adSchedulingContentIds"])) {
                this.adSchedulingContentIds = [] as any;
                for (let item of _data["adSchedulingContentIds"])
                    this.adSchedulingContentIds!.push(item);
            }
            this.adschedulingId = _data["adschedulingId"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishContentToAdScheduling {
        data = typeof data === 'object' ? data : {};
        let result = new PublishContentToAdScheduling();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adSchedulingContentIds)) {
            data["adSchedulingContentIds"] = [];
            for (let item of this.adSchedulingContentIds)
                data["adSchedulingContentIds"].push(item);
        }
        data["adschedulingId"] = this.adschedulingId;
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishContentToAdScheduling {
    adSchedulingContentIds: number[] | undefined;
    adschedulingId: number;
    action: string | undefined;
}

export class ScheduleModel implements IScheduleModel {
    id!: number;
    model!: number;
    monthDay!: number[] | undefined;
    weekdayList!: number[] | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    playModel!: number;
    priority!: number | undefined;

    constructor(data?: IScheduleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.model = _data["model"];
            if (Array.isArray(_data["monthDay"])) {
                this.monthDay = [] as any;
                for (let item of _data["monthDay"])
                    this.monthDay!.push(item);
            }
            if (Array.isArray(_data["weekdayList"])) {
                this.weekdayList = [] as any;
                for (let item of _data["weekdayList"])
                    this.weekdayList!.push(item);
            }
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.playModel = _data["playModel"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): ScheduleModel {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["model"] = this.model;
        if (Array.isArray(this.monthDay)) {
            data["monthDay"] = [];
            for (let item of this.monthDay)
                data["monthDay"].push(item);
        }
        if (Array.isArray(this.weekdayList)) {
            data["weekdayList"] = [];
            for (let item of this.weekdayList)
                data["weekdayList"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["playModel"] = this.playModel;
        data["priority"] = this.priority;
        return data; 
    }
}

export interface IScheduleModel {
    id: number;
    model: number;
    monthDay: number[] | undefined;
    weekdayList: number[] | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    playModel: number;
    priority: number | undefined;
}

export class ScheduleContent implements IScheduleContent {
    adSchedulingContentId!: number | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    scheduleModel!: ScheduleModel;
    adIds!: ProgramItem[] | undefined;

    constructor(data?: IScheduleContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adSchedulingContentId = _data["adSchedulingContentId"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.scheduleModel = _data["scheduleModel"] ? ScheduleModel.fromJS(_data["scheduleModel"]) : <any>undefined;
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(ProgramItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduleContent {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adSchedulingContentId"] = this.adSchedulingContentId;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["scheduleModel"] = this.scheduleModel ? this.scheduleModel.toJSON() : <any>undefined;
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IScheduleContent {
    adSchedulingContentId: number | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    scheduleModel: ScheduleModel;
    adIds: ProgramItem[] | undefined;
}

export enum GameTypeEnum {
    OffLine = 0,
    OnLine = 1,
}

export class SoftwareDto implements ISoftwareDto {
    name!: string | undefined;
    code!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: string | undefined;
    versionNumber!: string | undefined;
    packageUrl!: string | undefined;
    exePath!: string | undefined;
    type!: string | undefined;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean;
    isSendWechatBeforeGame!: boolean;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean;
    shareActionTabName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISoftwareDto {
    name: string | undefined;
    code: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: string | undefined;
    versionNumber: string | undefined;
    packageUrl: string | undefined;
    exePath: string | undefined;
    type: string | undefined;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean;
    isSendWechatBeforeGame: boolean;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean;
    shareActionTabName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ScheduleCalendarDto implements IScheduleCalendarDto {
    message!: string | undefined;
    scheduleContents!: ScheduleContent[] | undefined;
    ads!: AdListDto[] | undefined;
    softwares!: SoftwareDto[] | undefined;

    constructor(data?: IScheduleCalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["scheduleContents"])) {
                this.scheduleContents = [] as any;
                for (let item of _data["scheduleContents"])
                    this.scheduleContents!.push(ScheduleContent.fromJS(item));
            }
            if (Array.isArray(_data["ads"])) {
                this.ads = [] as any;
                for (let item of _data["ads"])
                    this.ads!.push(AdListDto.fromJS(item));
            }
            if (Array.isArray(_data["softwares"])) {
                this.softwares = [] as any;
                for (let item of _data["softwares"])
                    this.softwares!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScheduleCalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScheduleCalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.scheduleContents)) {
            data["scheduleContents"] = [];
            for (let item of this.scheduleContents)
                data["scheduleContents"].push(item.toJSON());
        }
        if (Array.isArray(this.ads)) {
            data["ads"] = [];
            for (let item of this.ads)
                data["ads"].push(item.toJSON());
        }
        if (Array.isArray(this.softwares)) {
            data["softwares"] = [];
            for (let item of this.softwares)
                data["softwares"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IScheduleCalendarDto {
    message: string | undefined;
    scheduleContents: ScheduleContent[] | undefined;
    ads: AdListDto[] | undefined;
    softwares: SoftwareDto[] | undefined;
}

export class GetProgramsIn24HoursDto implements IGetProgramsIn24HoursDto {
    id!: number;
    name!: string | undefined;
    content!: string | undefined;
    startTime!: string | undefined;
    endTime!: string | undefined;
    ads!: string | undefined;
    adList!: AdListDto[] | undefined;
    softwareList!: SoftwareDto[] | undefined;

    constructor(data?: IGetProgramsIn24HoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.content = _data["content"];
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.ads = _data["ads"];
            if (Array.isArray(_data["adList"])) {
                this.adList = [] as any;
                for (let item of _data["adList"])
                    this.adList!.push(AdListDto.fromJS(item));
            }
            if (Array.isArray(_data["softwareList"])) {
                this.softwareList = [] as any;
                for (let item of _data["softwareList"])
                    this.softwareList!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProgramsIn24HoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProgramsIn24HoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["content"] = this.content;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["ads"] = this.ads;
        if (Array.isArray(this.adList)) {
            data["adList"] = [];
            for (let item of this.adList)
                data["adList"].push(item.toJSON());
        }
        if (Array.isArray(this.softwareList)) {
            data["softwareList"] = [];
            for (let item of this.softwareList)
                data["softwareList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProgramsIn24HoursDto {
    id: number;
    name: string | undefined;
    content: string | undefined;
    startTime: string | undefined;
    endTime: string | undefined;
    ads: string | undefined;
    adList: AdListDto[] | undefined;
    softwareList: SoftwareDto[] | undefined;
}

export class PagedResultDtoOfGetProgramsIn24HoursDto implements IPagedResultDtoOfGetProgramsIn24HoursDto {
    totalCount!: number;
    items!: GetProgramsIn24HoursDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProgramsIn24HoursDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProgramsIn24HoursDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProgramsIn24HoursDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProgramsIn24HoursDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetProgramsIn24HoursDto {
    totalCount: number;
    items: GetProgramsIn24HoursDto[] | undefined;
}

export class PublishAdScheduliingInput implements IPublishAdScheduliingInput {
    adSchedulingIds!: number[] | undefined;
    deviceIds!: number[] | undefined;
    action!: string | undefined;
    informDevice!: boolean;

    constructor(data?: IPublishAdScheduliingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adSchedulingIds"])) {
                this.adSchedulingIds = [] as any;
                for (let item of _data["adSchedulingIds"])
                    this.adSchedulingIds!.push(item);
            }
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.action = _data["action"];
            this.informDevice = _data["informDevice"];
        }
    }

    static fromJS(data: any): PublishAdScheduliingInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishAdScheduliingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adSchedulingIds)) {
            data["adSchedulingIds"] = [];
            for (let item of this.adSchedulingIds)
                data["adSchedulingIds"].push(item);
        }
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["action"] = this.action;
        data["informDevice"] = this.informDevice;
        return data; 
    }
}

export interface IPublishAdScheduliingInput {
    adSchedulingIds: number[] | undefined;
    deviceIds: number[] | undefined;
    action: string | undefined;
    informDevice: boolean;
}

export enum ScheduleType {
    Public = 0,
    Copy = 1,
    Default = 2,
}

export class GetDeviceSchedulingDto implements IGetDeviceSchedulingDto {
    id!: number;
    adSchedulingId!: number;
    adSchedulingParentId!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    activeTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    iconUrl!: string | undefined;
    type!: ScheduleType;
    playType!: PlayType;
    isUse!: boolean;

    constructor(data?: IGetDeviceSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.adSchedulingId = _data["adSchedulingId"];
            this.adSchedulingParentId = _data["adSchedulingParentId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.activeTime = _data["activeTime"] ? DateTime.fromISO(_data["activeTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.iconUrl = _data["iconUrl"];
            this.type = _data["type"];
            this.playType = _data["playType"];
            this.isUse = _data["isUse"];
        }
    }

    static fromJS(data: any): GetDeviceSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["adSchedulingId"] = this.adSchedulingId;
        data["adSchedulingParentId"] = this.adSchedulingParentId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["activeTime"] = this.activeTime ? this.activeTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["iconUrl"] = this.iconUrl;
        data["type"] = this.type;
        data["playType"] = this.playType;
        data["isUse"] = this.isUse;
        return data; 
    }
}

export interface IGetDeviceSchedulingDto {
    id: number;
    adSchedulingId: number;
    adSchedulingParentId: number | undefined;
    name: string | undefined;
    description: string | undefined;
    activeTime: DateTime | undefined;
    endTime: DateTime | undefined;
    iconUrl: string | undefined;
    type: ScheduleType;
    playType: PlayType;
    isUse: boolean;
}

export class PagedResultDtoOfGetDeviceSchedulingDto implements IPagedResultDtoOfGetDeviceSchedulingDto {
    totalCount!: number;
    items!: GetDeviceSchedulingDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDeviceSchedulingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDeviceSchedulingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDeviceSchedulingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDeviceSchedulingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDeviceSchedulingDto {
    totalCount: number;
    items: GetDeviceSchedulingDto[] | undefined;
}

export class AdsProgramDto implements IAdsProgramDto {
    program!: ProgramDto;
    ads!: AdDto;
    startedTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    transition!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.program = _data["program"] ? ProgramDto.fromJS(_data["program"]) : <any>undefined;
            this.ads = _data["ads"] ? AdDto.fromJS(_data["ads"]) : <any>undefined;
            this.startedTime = _data["startedTime"] ? DateTime.fromISO(_data["startedTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.transition = _data["transition"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["startedTime"] = this.startedTime ? this.startedTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["transition"] = this.transition;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdsProgramDto {
    program: ProgramDto;
    ads: AdDto;
    startedTime: DateTime | undefined;
    endTime: DateTime | undefined;
    transition: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProgramDto implements IProgramDto {
    name!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgramDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProgramDto {
    name: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgramDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfProgramDto implements IPagedResultDtoOfProgramDto {
    totalCount!: number;
    items!: ProgramDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProgramDto {
    totalCount: number;
    items: ProgramDto[] | undefined;
}

export class CreateProgramInput implements ICreateProgramInput {
    name!: string | undefined;
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgramDto[] | undefined;

    constructor(data?: ICreateProgramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProgramInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateProgramInput {
    name: string | undefined;
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgramDto[] | undefined;
}

export class UpdateProgramInput implements IUpdateProgramInput {
    id!: number;
    name!: string | undefined;
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgramDto[] | undefined;

    constructor(data?: IUpdateProgramInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgramDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateProgramInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateProgramInput {
    id: number;
    name: string | undefined;
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgramDto[] | undefined;
}

export class AdPackageBindingDto implements IAdPackageBindingDto {
    adId!: number;
    playTransition!: string | undefined;
    playDuration!: number;
    orderNumber!: number;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;

    constructor(data?: IAdPackageBindingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
        }
    }

    static fromJS(data: any): AdPackageBindingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackageBindingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        return data; 
    }
}

export interface IAdPackageBindingDto {
    adId: number;
    playTransition: string | undefined;
    playDuration: number;
    orderNumber: number;
    startPointName: string | undefined;
    stopPointName: string | undefined;
}

export class AddOrUpdateAdsPackageInput implements IAddOrUpdateAdsPackageInput {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    value!: number;
    isLocationBased!: boolean;
    deviceId!: number | undefined;
    patrolId!: string | undefined;
    patrolName!: string | undefined;
    adPackages!: AdPackageBindingDto[] | undefined;

    constructor(data?: IAddOrUpdateAdsPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.value = _data["value"];
            this.isLocationBased = _data["isLocationBased"];
            this.deviceId = _data["deviceId"];
            this.patrolId = _data["patrolId"];
            this.patrolName = _data["patrolName"];
            if (Array.isArray(_data["adPackages"])) {
                this.adPackages = [] as any;
                for (let item of _data["adPackages"])
                    this.adPackages!.push(AdPackageBindingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateAdsPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAdsPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["value"] = this.value;
        data["isLocationBased"] = this.isLocationBased;
        data["deviceId"] = this.deviceId;
        data["patrolId"] = this.patrolId;
        data["patrolName"] = this.patrolName;
        if (Array.isArray(this.adPackages)) {
            data["adPackages"] = [];
            for (let item of this.adPackages)
                data["adPackages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateAdsPackageInput {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    value: number;
    isLocationBased: boolean;
    deviceId: number | undefined;
    patrolId: string | undefined;
    patrolName: string | undefined;
    adPackages: AdPackageBindingDto[] | undefined;
}

export class GetPackageDto implements IGetPackageDto {
    id!: number;
    name!: string | undefined;
    logoUrl!: string | undefined;
    value!: number;
    description!: string | undefined;
    creationTime!: DateTime;
    sumPlayDuration!: number;
    adsCount!: number;
    isLocationBased!: boolean;
    deviceId!: number | undefined;
    patrolId!: string | undefined;
    patrolName!: string | undefined;

    constructor(data?: IGetPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sumPlayDuration = _data["sumPlayDuration"];
            this.adsCount = _data["adsCount"];
            this.isLocationBased = _data["isLocationBased"];
            this.deviceId = _data["deviceId"];
            this.patrolId = _data["patrolId"];
            this.patrolName = _data["patrolName"];
        }
    }

    static fromJS(data: any): GetPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["value"] = this.value;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sumPlayDuration"] = this.sumPlayDuration;
        data["adsCount"] = this.adsCount;
        data["isLocationBased"] = this.isLocationBased;
        data["deviceId"] = this.deviceId;
        data["patrolId"] = this.patrolId;
        data["patrolName"] = this.patrolName;
        return data; 
    }
}

export interface IGetPackageDto {
    id: number;
    name: string | undefined;
    logoUrl: string | undefined;
    value: number;
    description: string | undefined;
    creationTime: DateTime;
    sumPlayDuration: number;
    adsCount: number;
    isLocationBased: boolean;
    deviceId: number | undefined;
    patrolId: string | undefined;
    patrolName: string | undefined;
}

export class PagedResultDtoOfGetPackageDto implements IPagedResultDtoOfGetPackageDto {
    totalCount!: number;
    items!: GetPackageDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPackageDto {
    totalCount: number;
    items: GetPackageDto[] | undefined;
}

export class AdPlayInfoDto implements IAdPlayInfoDto {
    id!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    resourceType!: string | undefined;

    constructor(data?: IAdPlayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.resourceType = _data["resourceType"];
        }
    }

    static fromJS(data: any): AdPlayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPlayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["resourceType"] = this.resourceType;
        return data; 
    }
}

export interface IAdPlayInfoDto {
    id: number;
    name: string | undefined;
    fileUrl: string | undefined;
    resourceType: string | undefined;
}

export class AdPackageDto implements IAdPackageDto {
    packageId!: number;
    adId!: number;
    ad!: AdPlayInfoDto;
    playTransition!: string | undefined;
    playDuration!: number | undefined;
    orderNumber!: number | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.adId = _data["adId"];
            this.ad = _data["ad"] ? AdPlayInfoDto.fromJS(_data["ad"]) : <any>undefined;
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["adId"] = this.adId;
        data["ad"] = this.ad ? this.ad.toJSON() : <any>undefined;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdPackageDto {
    packageId: number;
    adId: number;
    ad: AdPlayInfoDto;
    playTransition: string | undefined;
    playDuration: number | undefined;
    orderNumber: number | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AdsPackageDto implements IAdsPackageDto {
    id!: number;
    name!: string | undefined;
    logoUrl!: string | undefined;
    value!: number;
    description!: string | undefined;
    creationTime!: DateTime;
    sumPlayDuration!: number;
    adPackages!: AdPackageDto[] | undefined;

    constructor(data?: IAdsPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sumPlayDuration = _data["sumPlayDuration"];
            if (Array.isArray(_data["adPackages"])) {
                this.adPackages = [] as any;
                for (let item of _data["adPackages"])
                    this.adPackages!.push(AdPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdsPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdsPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["value"] = this.value;
        data["description"] = this.description;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sumPlayDuration"] = this.sumPlayDuration;
        if (Array.isArray(this.adPackages)) {
            data["adPackages"] = [];
            for (let item of this.adPackages)
                data["adPackages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdsPackageDto {
    id: number;
    name: string | undefined;
    logoUrl: string | undefined;
    value: number;
    description: string | undefined;
    creationTime: DateTime;
    sumPlayDuration: number;
    adPackages: AdPackageDto[] | undefined;
}

export class PagedResultDtoOfAdPackageDto implements IPagedResultDtoOfAdPackageDto {
    totalCount!: number;
    items!: AdPackageDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAdPackageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdPackageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAdPackageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAdPackageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAdPackageDto {
    totalCount: number;
    items: AdPackageDto[] | undefined;
}

export class UpdateAdPackageInput implements IUpdateAdPackageInput {
    packageId!: number;
    adId!: number;
    playTransition!: string | undefined;
    playDuration!: number | undefined;
    orderNumber!: number | undefined;

    constructor(data?: IUpdateAdPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageId = _data["packageId"];
            this.adId = _data["adId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateAdPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["packageId"] = this.packageId;
        data["adId"] = this.adId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateAdPackageInput {
    packageId: number;
    adId: number;
    playTransition: string | undefined;
    playDuration: number | undefined;
    orderNumber: number | undefined;
}

export class SetAdsToPackageInput implements ISetAdsToPackageInput {
    adIds!: number[] | undefined;
    packageId!: number;

    constructor(data?: ISetAdsToPackageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(item);
            }
            this.packageId = _data["packageId"];
        }
    }

    static fromJS(data: any): SetAdsToPackageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetAdsToPackageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item);
        }
        data["packageId"] = this.packageId;
        return data; 
    }
}

export interface ISetAdsToPackageInput {
    adIds: number[] | undefined;
    packageId: number;
}

export enum FileType {
    None = 0,
    Text = 1,
    Image = 2,
    Video = 3,
    PPT = 4,
    PDF = 5,
    Web = 6,
    Audio = 7,
    Zip = 8,
    View3DS = 9,
    Other = 10,
    Json = 11,
}

export enum TagType {
    Resource = 0,
    Device = 1,
    Product = 2,
    Ads = 3,
    Other = 4,
    Brand = 5,
    Question = 6,
    Counter = 7,
    WechatPublicMessage = 8,
}

export class Tag implements ITag {
    value!: string;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ResourceFileTag implements IResourceFileTag {
    resourceFileId!: number;
    resourceFile!: ResourceFile;
    tagId!: number;
    tag!: Tag;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IResourceFileTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceFileId = _data["resourceFileId"];
            this.resourceFile = _data["resourceFile"] ? ResourceFile.fromJS(_data["resourceFile"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResourceFileTag {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFileTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceFileId"] = this.resourceFileId;
        data["resourceFile"] = this.resourceFile ? this.resourceFile.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IResourceFileTag {
    resourceFileId: number;
    resourceFile: ResourceFile;
    tagId: number;
    tag: Tag;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ResourceFile implements IResourceFile {
    name!: string;
    fileUrl!: string;
    content!: string | undefined;
    type!: FileType;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    resourceTags!: ResourceFileTag[] | undefined;
    size!: number;
    orderNumber!: number;
    width!: number | undefined;
    height!: number | undefined;
    thumbnailUrl!: string | undefined;
    category!: string | undefined;
    md5!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IResourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["resourceTags"])) {
                this.resourceTags = [] as any;
                for (let item of _data["resourceTags"])
                    this.resourceTags!.push(ResourceFileTag.fromJS(item));
            }
            this.size = _data["size"];
            this.orderNumber = _data["orderNumber"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.category = _data["category"];
            this.md5 = _data["md5"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["content"] = this.content;
        data["type"] = this.type;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.resourceTags)) {
            data["resourceTags"] = [];
            for (let item of this.resourceTags)
                data["resourceTags"].push(item.toJSON());
        }
        data["size"] = this.size;
        data["orderNumber"] = this.orderNumber;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["category"] = this.category;
        data["md5"] = this.md5;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IResourceFile {
    name: string;
    fileUrl: string;
    content: string | undefined;
    type: FileType;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    resourceTags: ResourceFileTag[] | undefined;
    size: number;
    orderNumber: number;
    width: number | undefined;
    height: number | undefined;
    thumbnailUrl: string | undefined;
    category: string | undefined;
    md5: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AdsTag implements IAdsTag {
    adsId!: number;
    ads!: Ad;
    tagId!: number;
    tag!: Tag;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adsId = _data["adsId"];
            this.ads = _data["ads"] ? Ad.fromJS(_data["ads"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsTag {
        data = typeof data === 'object' ? data : {};
        let result = new AdsTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adsId"] = this.adsId;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdsTag {
    adsId: number;
    ads: Ad;
    tagId: number;
    tag: Tag;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Program implements IProgram {
    name!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    adsPrograms!: AdsProgram[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgram.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProgram {
    name: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    adsPrograms: AdsProgram[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AdsProgram implements IAdsProgram {
    programId!: number;
    program!: Program;
    adsId!: number;
    ads!: Ad;
    startedTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    transition!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdsProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : <any>undefined;
            this.adsId = _data["adsId"];
            this.ads = _data["ads"] ? Ad.fromJS(_data["ads"]) : <any>undefined;
            this.startedTime = _data["startedTime"] ? DateTime.fromISO(_data["startedTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.transition = _data["transition"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdsProgram {
        data = typeof data === 'object' ? data : {};
        let result = new AdsProgram();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["adsId"] = this.adsId;
        data["ads"] = this.ads ? this.ads.toJSON() : <any>undefined;
        data["startedTime"] = this.startedTime ? this.startedTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["transition"] = this.transition;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdsProgram {
    programId: number;
    program: Program;
    adsId: number;
    ads: Ad;
    startedTime: DateTime | undefined;
    endTime: DateTime | undefined;
    transition: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Ad implements IAd {
    name!: string;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    resourceItemId!: number;
    resourceItem!: ResourceFile;
    usage!: string | undefined;
    type!: AdsType;
    auditStatus!: AuditStatus;
    adsTags!: AdsTag[] | undefined;
    adsPrograms!: AdsProgram[] | undefined;
    productAttributes!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    extraInfo!: string | undefined;
    extensionData!: string | undefined;
    startTime!: DateTime | undefined;
    timeSpan!: string | undefined;
    transition!: string | undefined;
    description!: string | undefined;
    isCustom!: boolean;
    customContent!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.resourceItemId = _data["resourceItemId"];
            this.resourceItem = _data["resourceItem"] ? ResourceFile.fromJS(_data["resourceItem"]) : <any>undefined;
            this.usage = _data["usage"];
            this.type = _data["type"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(AdsTag.fromJS(item));
            }
            if (Array.isArray(_data["adsPrograms"])) {
                this.adsPrograms = [] as any;
                for (let item of _data["adsPrograms"])
                    this.adsPrograms!.push(AdsProgram.fromJS(item));
            }
            this.productAttributes = _data["productAttributes"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.extraInfo = _data["extraInfo"];
            this.extensionData = _data["extensionData"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.timeSpan = _data["timeSpan"];
            this.transition = _data["transition"];
            this.description = _data["description"];
            this.isCustom = _data["isCustom"];
            this.customContent = _data["customContent"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Ad {
        data = typeof data === 'object' ? data : {};
        let result = new Ad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["resourceItemId"] = this.resourceItemId;
        data["resourceItem"] = this.resourceItem ? this.resourceItem.toJSON() : <any>undefined;
        data["usage"] = this.usage;
        data["type"] = this.type;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        if (Array.isArray(this.adsPrograms)) {
            data["adsPrograms"] = [];
            for (let item of this.adsPrograms)
                data["adsPrograms"].push(item.toJSON());
        }
        data["productAttributes"] = this.productAttributes;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["extraInfo"] = this.extraInfo;
        data["extensionData"] = this.extensionData;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["timeSpan"] = this.timeSpan;
        data["transition"] = this.transition;
        data["description"] = this.description;
        data["isCustom"] = this.isCustom;
        data["customContent"] = this.customContent;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAd {
    name: string;
    tenantId: number;
    organizationUnitId: number | undefined;
    resourceItemId: number;
    resourceItem: ResourceFile;
    usage: string | undefined;
    type: AdsType;
    auditStatus: AuditStatus;
    adsTags: AdsTag[] | undefined;
    adsPrograms: AdsProgram[] | undefined;
    productAttributes: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    extraInfo: string | undefined;
    extensionData: string | undefined;
    startTime: DateTime | undefined;
    timeSpan: string | undefined;
    transition: string | undefined;
    description: string | undefined;
    isCustom: boolean;
    customContent: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AdPackage implements IAdPackage {
    adId!: number;
    ad!: Ad;
    packageId!: number;
    playTransition!: string | undefined;
    playDuration!: number;
    orderNumber!: number;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    startPointName!: string | undefined;
    stopPointName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAdPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.ad = _data["ad"] ? Ad.fromJS(_data["ad"]) : <any>undefined;
            this.packageId = _data["packageId"];
            this.playTransition = _data["playTransition"];
            this.playDuration = _data["playDuration"];
            this.orderNumber = _data["orderNumber"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.startPointName = _data["startPointName"];
            this.stopPointName = _data["stopPointName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AdPackage {
        data = typeof data === 'object' ? data : {};
        let result = new AdPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["ad"] = this.ad ? this.ad.toJSON() : <any>undefined;
        data["packageId"] = this.packageId;
        data["playTransition"] = this.playTransition;
        data["playDuration"] = this.playDuration;
        data["orderNumber"] = this.orderNumber;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["startPointName"] = this.startPointName;
        data["stopPointName"] = this.stopPointName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAdPackage {
    adId: number;
    ad: Ad;
    packageId: number;
    playTransition: string | undefined;
    playDuration: number;
    orderNumber: number;
    tenantId: number;
    organizationUnitId: number | undefined;
    startPointName: string | undefined;
    stopPointName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class SetUserAds implements ISetUserAds {
    adIds!: number[] | undefined;
    userId!: number;

    constructor(data?: ISetUserAds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["adIds"])) {
                this.adIds = [] as any;
                for (let item of _data["adIds"])
                    this.adIds!.push(item);
            }
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): SetUserAds {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserAds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.adIds)) {
            data["adIds"] = [];
            for (let item of this.adIds)
                data["adIds"].push(item);
        }
        data["userId"] = this.userId;
        return data; 
    }
}

export interface ISetUserAds {
    adIds: number[] | undefined;
    userId: number;
}

export class UserAd implements IUserAd {
    adId!: number;
    userId!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IUserAd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adId = _data["adId"];
            this.userId = _data["userId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserAd {
        data = typeof data === 'object' ? data : {};
        let result = new UserAd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adId"] = this.adId;
        data["userId"] = this.userId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserAd {
    adId: number;
    userId: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ApplyFormDto implements IApplyFormDto {
    reason!: string | undefined;
    applyStatus!: string | undefined;
    applyType!: string | undefined;
    wanted!: string | undefined;
    resultMessage!: string | undefined;
    applyUserName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyStatus = _data["applyStatus"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            this.resultMessage = _data["resultMessage"];
            this.applyUserName = _data["applyUserName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyStatus"] = this.applyStatus;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        data["resultMessage"] = this.resultMessage;
        data["applyUserName"] = this.applyUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplyFormDto {
    reason: string | undefined;
    applyStatus: string | undefined;
    applyType: string | undefined;
    wanted: string | undefined;
    resultMessage: string | undefined;
    applyUserName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfApplyFormDto implements IPagedResultDtoOfApplyFormDto {
    totalCount!: number;
    items!: ApplyFormDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplyFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApplyFormDto {
    totalCount: number;
    items: ApplyFormDto[] | undefined;
}

export enum ApplyFormType {
    Product = 0,
    Ads = 1,
    App = 2,
    Device = 3,
    Sku = 4,
    Coupon = 5,
}

export enum ApplyWanted {
    Online = 0,
    Offline = 1,
}

export class CreateApplyFormInput implements ICreateApplyFormInput {
    reason!: string | undefined;
    applyType!: ApplyFormType;
    wanted!: ApplyWanted;
    itemids!: number[] | undefined;
    options!: string | undefined;

    constructor(data?: ICreateApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            if (Array.isArray(_data["itemids"])) {
                this.itemids = [] as any;
                for (let item of _data["itemids"])
                    this.itemids!.push(item);
            }
            this.options = _data["options"];
        }
    }

    static fromJS(data: any): CreateApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        if (Array.isArray(this.itemids)) {
            data["itemids"] = [];
            for (let item of this.itemids)
                data["itemids"].push(item);
        }
        data["options"] = this.options;
        return data; 
    }
}

export interface ICreateApplyFormInput {
    reason: string | undefined;
    applyType: ApplyFormType;
    wanted: ApplyWanted;
    itemids: number[] | undefined;
    options: string | undefined;
}

export enum ApplyStatus {
    Applied = 0,
    Cancel = 1,
    Accepted = 2,
    Rejected = 3,
}

export class AuditApplyFormInput implements IAuditApplyFormInput {
    applyFormId!: number;
    applyStatus!: ApplyStatus;
    resultMessage!: string | undefined;

    constructor(data?: IAuditApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applyFormId = _data["applyFormId"];
            this.applyStatus = _data["applyStatus"];
            this.resultMessage = _data["resultMessage"];
        }
    }

    static fromJS(data: any): AuditApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applyFormId"] = this.applyFormId;
        data["applyStatus"] = this.applyStatus;
        data["resultMessage"] = this.resultMessage;
        return data; 
    }
}

export interface IAuditApplyFormInput {
    applyFormId: number;
    applyStatus: ApplyStatus;
    resultMessage: string | undefined;
}

export class IdNamePicDto implements IIdNamePicDto {
    id!: number;
    name!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IIdNamePicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): IdNamePicDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNamePicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IIdNamePicDto {
    id: number;
    name: string | undefined;
    picUrl: string | undefined;
}

export class PagedResultDtoOfIdNamePicDto implements IPagedResultDtoOfIdNamePicDto {
    totalCount!: number;
    items!: IdNamePicDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIdNamePicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdNamePicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIdNamePicDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIdNamePicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIdNamePicDto {
    totalCount: number;
    items: IdNamePicDto[] | undefined;
}

export enum OperatingType {
    Official = 0,
    Test = 1,
}

export enum BussinessType {
    SelfBuyFromOthers = 0,
    SelfBuyFromTronCell = 1,
    RentFromOthers = 2,
    RentFromTronCell = 3,
}

export class DeviceTypeDto implements IDeviceTypeDto {
    name!: string | undefined;
    iconUrl!: string | undefined;
    isDefault!: boolean;
    abilities!: string | undefined;
    controlItems!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.isDefault = _data["isDefault"];
            this.abilities = _data["abilities"];
            this.controlItems = _data["controlItems"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["isDefault"] = this.isDefault;
        data["abilities"] = this.abilities;
        data["controlItems"] = this.controlItems;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceTypeDto {
    name: string | undefined;
    iconUrl: string | undefined;
    isDefault: boolean;
    abilities: string | undefined;
    controlItems: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PeripheralDto implements IPeripheralDto {
    name!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPeripheralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PeripheralDto {
        data = typeof data === 'object' ? data : {};
        let result = new PeripheralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPeripheralDto {
    name: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class DevicePeripheralDto implements IDevicePeripheralDto {
    peripheralId!: number;
    peripheral!: PeripheralDto;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDevicePeripheralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.peripheralId = _data["peripheralId"];
            this.peripheral = _data["peripheral"] ? PeripheralDto.fromJS(_data["peripheral"]) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DevicePeripheralDto {
        data = typeof data === 'object' ? data : {};
        let result = new DevicePeripheralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["peripheralId"] = this.peripheralId;
        data["peripheral"] = this.peripheral ? this.peripheral.toJSON() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDevicePeripheralDto {
    peripheralId: number;
    peripheral: PeripheralDto;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export enum ExternalEnum {
    Platform = 0,
    Taobao = 1,
    Oracle = 2,
    JD = 3,
    BaiSheng = 4,
    Shangpai = 5,
    Weimob = 6,
}

export enum OsTypeEnum {
    Windows = 0,
    Android = 1,
    IOS = 2,
    Linux = 3,
}

export class DeviceDto implements IDeviceDto {
    name!: string | undefined;
    auditStatus!: AuditStatus;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    organizationUnitName!: string | undefined;
    orderNumber!: number;
    imageUrl!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    mac!: string | undefined;
    coverArea!: number | undefined;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    os!: string | undefined;
    address!: string | undefined;
    heartBeatTime!: DateTime | undefined;
    startTime!: DateTime | undefined;
    shutdownTime!: DateTime | undefined;
    isRegistered!: boolean;
    snapshotUrl!: string | undefined;
    snapshotTime!: DateTime | undefined;
    captureImageUrl!: string | undefined;
    captureImageTime!: DateTime | undefined;
    errorStartTime!: DateTime | undefined;
    expiredTime!: DateTime | undefined;
    isLocked!: boolean;
    operatingType!: OperatingType;
    bussinessType!: BussinessType;
    startedUsedTime!: DateTime | undefined;
    heatImageUrl!: string | undefined;
    comments!: string | undefined;
    deviceTypeId!: number | undefined;
    deviceType!: DeviceTypeDto;
    peripherals!: DevicePeripheralDto[] | undefined;
    subKey!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;
    status!: number;
    taobaoRegistTime!: DateTime | undefined;
    registerSource!: string | undefined;
    osType!: OsTypeEnum;
    latestResourceUpdateTime!: DateTime | undefined;
    isSupportAccessToChildDevices!: boolean | undefined;
    isSupportRemoteControl!: boolean | undefined;
    abilities!: string | undefined;
    creationTime!: DateTime | undefined;
    id!: number;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.auditStatus = _data["auditStatus"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.orderNumber = _data["orderNumber"];
            this.imageUrl = _data["imageUrl"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.mac = _data["mac"];
            this.coverArea = _data["coverArea"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
            this.address = _data["address"];
            this.heartBeatTime = _data["heartBeatTime"] ? DateTime.fromISO(_data["heartBeatTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.isRegistered = _data["isRegistered"];
            this.snapshotUrl = _data["snapshotUrl"];
            this.snapshotTime = _data["snapshotTime"] ? DateTime.fromISO(_data["snapshotTime"].toString()) : <any>undefined;
            this.captureImageUrl = _data["captureImageUrl"];
            this.captureImageTime = _data["captureImageTime"] ? DateTime.fromISO(_data["captureImageTime"].toString()) : <any>undefined;
            this.errorStartTime = _data["errorStartTime"] ? DateTime.fromISO(_data["errorStartTime"].toString()) : <any>undefined;
            this.expiredTime = _data["expiredTime"] ? DateTime.fromISO(_data["expiredTime"].toString()) : <any>undefined;
            this.isLocked = _data["isLocked"];
            this.operatingType = _data["operatingType"];
            this.bussinessType = _data["bussinessType"];
            this.startedUsedTime = _data["startedUsedTime"] ? DateTime.fromISO(_data["startedUsedTime"].toString()) : <any>undefined;
            this.heatImageUrl = _data["heatImageUrl"];
            this.comments = _data["comments"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.deviceType = _data["deviceType"] ? DeviceTypeDto.fromJS(_data["deviceType"]) : <any>undefined;
            if (Array.isArray(_data["peripherals"])) {
                this.peripherals = [] as any;
                for (let item of _data["peripherals"])
                    this.peripherals!.push(DevicePeripheralDto.fromJS(item));
            }
            this.subKey = _data["subKey"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.outerId = _data["outerId"];
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.status = _data["status"];
            this.taobaoRegistTime = _data["taobaoRegistTime"] ? DateTime.fromISO(_data["taobaoRegistTime"].toString()) : <any>undefined;
            this.registerSource = _data["registerSource"];
            this.osType = _data["osType"];
            this.latestResourceUpdateTime = _data["latestResourceUpdateTime"] ? DateTime.fromISO(_data["latestResourceUpdateTime"].toString()) : <any>undefined;
            this.isSupportAccessToChildDevices = _data["isSupportAccessToChildDevices"];
            this.isSupportRemoteControl = _data["isSupportRemoteControl"];
            this.abilities = _data["abilities"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["auditStatus"] = this.auditStatus;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["organizationUnitName"] = this.organizationUnitName;
        data["orderNumber"] = this.orderNumber;
        data["imageUrl"] = this.imageUrl;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["mac"] = this.mac;
        data["coverArea"] = this.coverArea;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        data["address"] = this.address;
        data["heartBeatTime"] = this.heartBeatTime ? this.heartBeatTime.toString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["isRegistered"] = this.isRegistered;
        data["snapshotUrl"] = this.snapshotUrl;
        data["snapshotTime"] = this.snapshotTime ? this.snapshotTime.toString() : <any>undefined;
        data["captureImageUrl"] = this.captureImageUrl;
        data["captureImageTime"] = this.captureImageTime ? this.captureImageTime.toString() : <any>undefined;
        data["errorStartTime"] = this.errorStartTime ? this.errorStartTime.toString() : <any>undefined;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["operatingType"] = this.operatingType;
        data["bussinessType"] = this.bussinessType;
        data["startedUsedTime"] = this.startedUsedTime ? this.startedUsedTime.toString() : <any>undefined;
        data["heatImageUrl"] = this.heatImageUrl;
        data["comments"] = this.comments;
        data["deviceTypeId"] = this.deviceTypeId;
        data["deviceType"] = this.deviceType ? this.deviceType.toJSON() : <any>undefined;
        if (Array.isArray(this.peripherals)) {
            data["peripherals"] = [];
            for (let item of this.peripherals)
                data["peripherals"].push(item.toJSON());
        }
        data["subKey"] = this.subKey;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        data["status"] = this.status;
        data["taobaoRegistTime"] = this.taobaoRegistTime ? this.taobaoRegistTime.toString() : <any>undefined;
        data["registerSource"] = this.registerSource;
        data["osType"] = this.osType;
        data["latestResourceUpdateTime"] = this.latestResourceUpdateTime ? this.latestResourceUpdateTime.toString() : <any>undefined;
        data["isSupportAccessToChildDevices"] = this.isSupportAccessToChildDevices;
        data["isSupportRemoteControl"] = this.isSupportRemoteControl;
        data["abilities"] = this.abilities;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceDto {
    name: string | undefined;
    auditStatus: AuditStatus;
    tenantId: number;
    organizationUnitId: number | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    organizationUnitName: string | undefined;
    orderNumber: number;
    imageUrl: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    mac: string | undefined;
    coverArea: number | undefined;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    os: string | undefined;
    address: string | undefined;
    heartBeatTime: DateTime | undefined;
    startTime: DateTime | undefined;
    shutdownTime: DateTime | undefined;
    isRegistered: boolean;
    snapshotUrl: string | undefined;
    snapshotTime: DateTime | undefined;
    captureImageUrl: string | undefined;
    captureImageTime: DateTime | undefined;
    errorStartTime: DateTime | undefined;
    expiredTime: DateTime | undefined;
    isLocked: boolean;
    operatingType: OperatingType;
    bussinessType: BussinessType;
    startedUsedTime: DateTime | undefined;
    heatImageUrl: string | undefined;
    comments: string | undefined;
    deviceTypeId: number | undefined;
    deviceType: DeviceTypeDto;
    peripherals: DevicePeripheralDto[] | undefined;
    subKey: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
    status: number;
    taobaoRegistTime: DateTime | undefined;
    registerSource: string | undefined;
    osType: OsTypeEnum;
    latestResourceUpdateTime: DateTime | undefined;
    isSupportAccessToChildDevices: boolean | undefined;
    isSupportRemoteControl: boolean | undefined;
    abilities: string | undefined;
    creationTime: DateTime | undefined;
    id: number;
}

export class PagedResultDtoOfDeviceDto implements IPagedResultDtoOfDeviceDto {
    totalCount!: number;
    items!: DeviceDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceDto {
    totalCount: number;
    items: DeviceDto[] | undefined;
}

export class CreateAppVersionInput implements ICreateAppVersionInput {
    version!: string | undefined;
    description!: string | undefined;
    releaseDate!: DateTime | undefined;
    editionIds!: number[] | undefined;

    constructor(data?: ICreateAppVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.description = _data["description"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["editionIds"])) {
                this.editionIds = [] as any;
                for (let item of _data["editionIds"])
                    this.editionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAppVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["description"] = this.description;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        if (Array.isArray(this.editionIds)) {
            data["editionIds"] = [];
            for (let item of this.editionIds)
                data["editionIds"].push(item);
        }
        return data; 
    }
}

export interface ICreateAppVersionInput {
    version: string | undefined;
    description: string | undefined;
    releaseDate: DateTime | undefined;
    editionIds: number[] | undefined;
}

export class UpdateAppVersionInput implements IUpdateAppVersionInput {
    id!: number;
    version!: string | undefined;
    description!: string | undefined;
    releaseDate!: DateTime | undefined;
    editionIds!: number[] | undefined;

    constructor(data?: IUpdateAppVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["editionIds"])) {
                this.editionIds = [] as any;
                for (let item of _data["editionIds"])
                    this.editionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAppVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["description"] = this.description;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        if (Array.isArray(this.editionIds)) {
            data["editionIds"] = [];
            for (let item of this.editionIds)
                data["editionIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateAppVersionInput {
    id: number;
    version: string | undefined;
    description: string | undefined;
    releaseDate: DateTime | undefined;
    editionIds: number[] | undefined;
}

export class Edition implements IEdition {
    name!: string;
    displayName!: string;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Edition {
        data = typeof data === 'object' ? data : {};
        let result = new Edition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEdition {
    name: string;
    displayName: string;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AppVersionDto implements IAppVersionDto {
    id!: number;
    version!: string | undefined;
    description!: string | undefined;
    releaseDate!: DateTime;
    editions!: Edition[] | undefined;

    constructor(data?: IAppVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["editions"])) {
                this.editions = [] as any;
                for (let item of _data["editions"])
                    this.editions!.push(Edition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["description"] = this.description;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        if (Array.isArray(this.editions)) {
            data["editions"] = [];
            for (let item of this.editions)
                data["editions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppVersionDto {
    id: number;
    version: string | undefined;
    description: string | undefined;
    releaseDate: DateTime;
    editions: Edition[] | undefined;
}

export class PagedResultDtoOfAppVersionDto implements IPagedResultDtoOfAppVersionDto {
    totalCount!: number;
    items!: AppVersionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAppVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAppVersionDto {
    totalCount: number;
    items: AppVersionDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: DateTime;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? DateTime.fromISO(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: DateTime;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: DateTime;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? DateTime.fromISO(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: DateTime;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export enum ExportMissionStatus {
    Acting = 0,
    Success = 1,
    Failed = 2,
}

export enum DownloadType {
    Excel = 0,
}

export class ExportMissionInput implements IExportMissionInput {
    id!: number | undefined;
    name!: string | undefined;
    missEndTime!: DateTime | undefined;
    status!: ExportMissionStatus;
    type!: DownloadType;
    downloadUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IExportMissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.missEndTime = _data["missEndTime"] ? DateTime.fromISO(_data["missEndTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
            this.downloadUrl = _data["downloadUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExportMissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExportMissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["missEndTime"] = this.missEndTime ? this.missEndTime.toString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["downloadUrl"] = this.downloadUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IExportMissionInput {
    id: number | undefined;
    name: string | undefined;
    missEndTime: DateTime | undefined;
    status: ExportMissionStatus;
    type: DownloadType;
    downloadUrl: string | undefined;
    from: string | undefined;
}

export class ExportTaskDto implements IExportTaskDto {
    id!: number;
    creationTime!: DateTime;
    name!: string | undefined;
    missEndTime!: DateTime | undefined;
    status!: ExportMissionStatus;
    type!: DownloadType;
    downloadUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IExportTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.missEndTime = _data["missEndTime"] ? DateTime.fromISO(_data["missEndTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
            this.downloadUrl = _data["downloadUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExportTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["name"] = this.name;
        data["missEndTime"] = this.missEndTime ? this.missEndTime.toString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["downloadUrl"] = this.downloadUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IExportTaskDto {
    id: number;
    creationTime: DateTime;
    name: string | undefined;
    missEndTime: DateTime | undefined;
    status: ExportMissionStatus;
    type: DownloadType;
    downloadUrl: string | undefined;
    from: string | undefined;
}

export class PagedResultDtoOfExportTaskDto implements IPagedResultDtoOfExportTaskDto {
    totalCount!: number;
    items!: ExportTaskDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExportTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExportTaskDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExportTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExportTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExportTaskDto {
    totalCount: number;
    items: ExportTaskDto[] | undefined;
}

export class BatchTaskLogDto implements IBatchTaskLogDto {
    name!: string | undefined;
    batchType!: string | undefined;
    completedCount!: number;
    totalCount!: number;
    status!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBatchTaskLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.batchType = _data["batchType"];
            this.completedCount = _data["completedCount"];
            this.totalCount = _data["totalCount"];
            this.status = _data["status"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BatchTaskLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchTaskLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["batchType"] = this.batchType;
        data["completedCount"] = this.completedCount;
        data["totalCount"] = this.totalCount;
        data["status"] = this.status;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBatchTaskLogDto {
    name: string | undefined;
    batchType: string | undefined;
    completedCount: number;
    totalCount: number;
    status: string | undefined;
    lastModificationTime: DateTime | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfBatchTaskLogDto implements IPagedResultDtoOfBatchTaskLogDto {
    totalCount!: number;
    items!: BatchTaskLogDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBatchTaskLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatchTaskLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBatchTaskLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBatchTaskLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBatchTaskLogDto {
    totalCount: number;
    items: BatchTaskLogDto[] | undefined;
}

export class UploadToTaobaoBehaviorInput implements IUploadToTaobaoBehaviorInput {
    action!: string | undefined;
    taobaoDeviceId!: string | undefined;
    tenantId!: number;
    thingId!: string | undefined;
    collectionTime!: DateTime;

    constructor(data?: IUploadToTaobaoBehaviorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.taobaoDeviceId = _data["taobaoDeviceId"];
            this.tenantId = _data["tenantId"];
            this.thingId = _data["thingId"];
            this.collectionTime = _data["collectionTime"] ? DateTime.fromISO(_data["collectionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UploadToTaobaoBehaviorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadToTaobaoBehaviorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["tenantId"] = this.tenantId;
        data["thingId"] = this.thingId;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IUploadToTaobaoBehaviorInput {
    action: string | undefined;
    taobaoDeviceId: string | undefined;
    tenantId: number;
    thingId: string | undefined;
    collectionTime: DateTime;
}

export class EntityFileDto implements IEntityFileDto {
    entityId!: number;
    resourceId!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    category!: string | undefined;
    fromType!: string | undefined;
    type!: string | undefined;
    created!: DateTime | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IEntityFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.resourceId = _data["resourceId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["resourceId"] = this.resourceId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toString() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityFileDto {
    entityId: number;
    resourceId: number;
    name: string | undefined;
    fileUrl: string | undefined;
    category: string | undefined;
    fromType: string | undefined;
    type: string | undefined;
    created: DateTime | undefined;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BrandDto implements IBrandDto {
    code!: string | undefined;
    orderNumber!: number;
    name!: string | undefined;
    logoUrl!: string | undefined;
    b_BrandCategories!: IdNameDto[] | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    itemImagesOrVideos!: EntityFileDto[] | undefined;
    slogan!: string | undefined;
    brandTags!: IdNameDto[] | undefined;
    auditStatus!: AuditStatus;
    theme!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            if (Array.isArray(_data["b_BrandCategories"])) {
                this.b_BrandCategories = [] as any;
                for (let item of _data["b_BrandCategories"])
                    this.b_BrandCategories!.push(IdNameDto.fromJS(item));
            }
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileDto.fromJS(item));
            }
            this.slogan = _data["slogan"];
            if (Array.isArray(_data["brandTags"])) {
                this.brandTags = [] as any;
                for (let item of _data["brandTags"])
                    this.brandTags!.push(IdNameDto.fromJS(item));
            }
            this.auditStatus = _data["auditStatus"];
            this.theme = _data["theme"];
            this.extensionData = _data["extensionData"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        if (Array.isArray(this.b_BrandCategories)) {
            data["b_BrandCategories"] = [];
            for (let item of this.b_BrandCategories)
                data["b_BrandCategories"].push(item.toJSON());
        }
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["slogan"] = this.slogan;
        if (Array.isArray(this.brandTags)) {
            data["brandTags"] = [];
            for (let item of this.brandTags)
                data["brandTags"].push(item.toJSON());
        }
        data["auditStatus"] = this.auditStatus;
        data["theme"] = this.theme;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrandDto {
    code: string | undefined;
    orderNumber: number;
    name: string | undefined;
    logoUrl: string | undefined;
    b_BrandCategories: IdNameDto[] | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    itemImagesOrVideos: EntityFileDto[] | undefined;
    slogan: string | undefined;
    brandTags: IdNameDto[] | undefined;
    auditStatus: AuditStatus;
    theme: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfBrandDto implements IPagedResultDtoOfBrandDto {
    totalCount!: number;
    items!: BrandDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBrandDto {
    totalCount: number;
    items: BrandDto[] | undefined;
}

export class UpdateBrandInput implements IUpdateBrandInput {
    id!: number;
    code!: string;
    orderNumber!: number;
    name!: string;
    theme!: string | undefined;
    extensionData!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    slogan!: string | undefined;
    tagIds!: number[] | undefined;
    categorys!: number[] | undefined;

    constructor(data?: IUpdateBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.theme = _data["theme"];
            this.extensionData = _data["extensionData"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            this.slogan = _data["slogan"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["theme"] = this.theme;
        data["extensionData"] = this.extensionData;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        data["slogan"] = this.slogan;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        return data; 
    }
}

export interface IUpdateBrandInput {
    id: number;
    code: string;
    orderNumber: number;
    name: string;
    theme: string | undefined;
    extensionData: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    slogan: string | undefined;
    tagIds: number[] | undefined;
    categorys: number[] | undefined;
}

export class CreateBrandInput implements ICreateBrandInput {
    code!: string;
    orderNumber!: number;
    name!: string;
    theme!: string | undefined;
    extensionData!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    slogan!: string | undefined;
    tagIds!: number[] | undefined;
    categorys!: number[] | undefined;

    constructor(data?: ICreateBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.theme = _data["theme"];
            this.extensionData = _data["extensionData"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            this.slogan = _data["slogan"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["theme"] = this.theme;
        data["extensionData"] = this.extensionData;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        data["slogan"] = this.slogan;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        return data; 
    }
}

export interface ICreateBrandInput {
    code: string;
    orderNumber: number;
    name: string;
    theme: string | undefined;
    extensionData: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    slogan: string | undefined;
    tagIds: number[] | undefined;
    categorys: number[] | undefined;
}

export class PagedResultDtoOfEntityFileDto implements IPagedResultDtoOfEntityFileDto {
    totalCount!: number;
    items!: EntityFileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityFileDto {
    totalCount: number;
    items: EntityFileDto[] | undefined;
}

export class CreateEntityResourceInput implements ICreateEntityResourceInput {
    fileUrl!: string;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    orderNumber!: number;
    fromType!: string | undefined;

    constructor(data?: ICreateEntityResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateEntityResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntityResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateEntityResourceInput {
    fileUrl: string;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    entityId: number;
    orderNumber: number;
    fromType: string | undefined;
}

export class UpdateEntityResourceInput implements IUpdateEntityResourceInput {
    id!: number;
    fileUrl!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    orderNumber!: number;
    fromType!: string | undefined;

    constructor(data?: IUpdateEntityResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileUrl = _data["fileUrl"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): UpdateEntityResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileUrl"] = this.fileUrl;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IUpdateEntityResourceInput {
    id: number;
    fileUrl: string | undefined;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    orderNumber: number;
    fromType: string | undefined;
}

export class SetBrandTagsDto implements ISetBrandTagsDto {
    tagIds!: number[] | undefined;
    brandIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetBrandTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["brandIds"])) {
                this.brandIds = [] as any;
                for (let item of _data["brandIds"])
                    this.brandIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetBrandTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetBrandTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.brandIds)) {
            data["brandIds"] = [];
            for (let item of this.brandIds)
                data["brandIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetBrandTagsDto {
    tagIds: number[] | undefined;
    brandIds: number[] | undefined;
    action: string | undefined;
}

export class OnlineOrOffLineBrandInput implements IOnlineOrOffLineBrandInput {
    isIncludeProduct!: boolean;
    wanted!: ApplyWanted;
    isAllBrands!: boolean;
    brandIds!: number[] | undefined;

    constructor(data?: IOnlineOrOffLineBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isIncludeProduct = _data["isIncludeProduct"];
            this.wanted = _data["wanted"];
            this.isAllBrands = _data["isAllBrands"];
            if (Array.isArray(_data["brandIds"])) {
                this.brandIds = [] as any;
                for (let item of _data["brandIds"])
                    this.brandIds!.push(item);
            }
        }
    }

    static fromJS(data: any): OnlineOrOffLineBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new OnlineOrOffLineBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isIncludeProduct"] = this.isIncludeProduct;
        data["wanted"] = this.wanted;
        data["isAllBrands"] = this.isAllBrands;
        if (Array.isArray(this.brandIds)) {
            data["brandIds"] = [];
            for (let item of this.brandIds)
                data["brandIds"].push(item);
        }
        return data; 
    }
}

export interface IOnlineOrOffLineBrandInput {
    isIncludeProduct: boolean;
    wanted: ApplyWanted;
    isAllBrands: boolean;
    brandIds: number[] | undefined;
}

export class AddOrUpdateBrandCategoryInput implements IAddOrUpdateBrandCategoryInput {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    parentCode!: string | undefined;
    code!: string | undefined;
    name!: string;
    picUrl!: string | undefined;
    sortOrder!: number;
    fromType!: string | undefined;

    constructor(data?: IAddOrUpdateBrandCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
            this.sortOrder = _data["sortOrder"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): AddOrUpdateBrandCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateBrandCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["sortOrder"] = this.sortOrder;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IAddOrUpdateBrandCategoryInput {
    tenantId: number;
    organizationUnitId: number | undefined;
    parentCode: string | undefined;
    code: string | undefined;
    name: string;
    picUrl: string | undefined;
    sortOrder: number;
    fromType: string | undefined;
}

export class BrandCategoryTreeItemDto implements IBrandCategoryTreeItemDto {
    iconUrl!: string | undefined;
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    imageUrl!: string | undefined;
    productCount!: number;
    children!: BrandCategoryTreeItemDto[] | undefined;

    constructor(data?: IBrandCategoryTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconUrl = _data["iconUrl"];
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            this.imageUrl = _data["imageUrl"];
            this.productCount = _data["productCount"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(BrandCategoryTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandCategoryTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandCategoryTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconUrl"] = this.iconUrl;
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        data["imageUrl"] = this.imageUrl;
        data["productCount"] = this.productCount;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrandCategoryTreeItemDto {
    iconUrl: string | undefined;
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    imageUrl: string | undefined;
    productCount: number;
    children: BrandCategoryTreeItemDto[] | undefined;
}

export class BrandCategoryDto implements IBrandCategoryDto {
    organizationUnitId!: number | undefined;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number | undefined;
    parentCategoryName!: string | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrandCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrandCategoryDto {
    organizationUnitId: number | undefined;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number | undefined;
    parentCategoryName: string | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfBrandCategoryDto implements IPagedResultDtoOfBrandCategoryDto {
    totalCount!: number;
    items!: BrandCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBrandCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBrandCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBrandCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBrandCategoryDto {
    totalCount: number;
    items: BrandCategoryDto[] | undefined;
}

export class CreateBrandCategoryInput implements ICreateBrandCategoryInput {
    categoryCode!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: ICreateBrandCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateBrandCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateBrandCategoryInput {
    categoryCode: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class UpdateBrandCategoryInput implements IUpdateBrandCategoryInput {
    id!: number;
    categoryCode!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IUpdateBrandCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): UpdateBrandCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IUpdateBrandCategoryInput {
    id: number;
    categoryCode: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: DateTime;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? DateTime.fromISO(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: DateTime;
    friends: FriendDto[] | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: DateTime;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: DateTime;
    sharedMessageId: string | undefined;
    id: number;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class CouponOutDto implements ICouponOutDto {
    id!: number;
    creationTime!: DateTime;
    amount!: number;
    title!: string | undefined;
    pictures!: string | undefined;
    start_time!: DateTime;
    end_time!: DateTime;
    url!: string | undefined;
    auditStatus!: AuditStatus;
    code!: string | undefined;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: ICouponOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.title = _data["title"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? DateTime.fromISO(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? DateTime.fromISO(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CouponOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["amount"] = this.amount;
        data["title"] = this.title;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICouponOutDto {
    id: number;
    creationTime: DateTime;
    amount: number;
    title: string | undefined;
    pictures: string | undefined;
    start_time: DateTime;
    end_time: DateTime;
    url: string | undefined;
    auditStatus: AuditStatus;
    code: string | undefined;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class PagedResultDtoOfCouponOutDto implements IPagedResultDtoOfCouponOutDto {
    totalCount!: number;
    items!: CouponOutDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCouponOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CouponOutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCouponOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCouponOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCouponOutDto {
    totalCount: number;
    items: CouponOutDto[] | undefined;
}

export class CreateCouponInput implements ICreateCouponInput {
    amount!: number;
    spreadId!: string | undefined;
    title!: string;
    outerId!: string | undefined;
    pictures!: string | undefined;
    start_time!: DateTime;
    end_time!: DateTime;
    url!: string | undefined;
    auditStatus!: AuditStatus;
    code!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ICreateCouponInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? DateTime.fromISO(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? DateTime.fromISO(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateCouponInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateCouponInput {
    amount: number;
    spreadId: string | undefined;
    title: string;
    outerId: string | undefined;
    pictures: string | undefined;
    start_time: DateTime;
    end_time: DateTime;
    url: string | undefined;
    auditStatus: AuditStatus;
    code: string | undefined;
    organizationUnitId: number | undefined;
}

export class CouponDto implements ICouponDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    outerId!: number;
    amount!: number;
    spreadId!: string | undefined;
    title!: string | undefined;
    pictures!: string | undefined;
    start_time!: DateTime;
    end_time!: DateTime;
    url!: string | undefined;
    auditStatus!: AuditStatus;
    code!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.outerId = _data["outerId"];
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? DateTime.fromISO(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? DateTime.fromISO(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["outerId"] = this.outerId;
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICouponDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    outerId: number;
    amount: number;
    spreadId: string | undefined;
    title: string | undefined;
    pictures: string | undefined;
    start_time: DateTime;
    end_time: DateTime;
    url: string | undefined;
    auditStatus: AuditStatus;
    code: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UpdateCouponInput implements IUpdateCouponInput {
    id!: number;
    amount!: number;
    spreadId!: string | undefined;
    title!: string;
    outerId!: string | undefined;
    pictures!: string | undefined;
    start_time!: DateTime;
    end_time!: DateTime;
    url!: string | undefined;
    auditStatus!: AuditStatus;
    code!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUpdateCouponInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? DateTime.fromISO(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? DateTime.fromISO(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateCouponInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCouponInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateCouponInput {
    id: number;
    amount: number;
    spreadId: string | undefined;
    title: string;
    outerId: string | undefined;
    pictures: string | undefined;
    start_time: DateTime;
    end_time: DateTime;
    url: string | undefined;
    auditStatus: AuditStatus;
    code: string | undefined;
    organizationUnitId: number | undefined;
}

export enum TicketType {
    Voucher = 0,
    Discount = 1,
}

export enum TakeType {
    UserTake = 0,
    ManagerGrant = 1,
    RegisterAutoGrant = 2,
    GameAutoGrant = 3,
}

export class TicketUseCondition implements ITicketUseCondition {
    amount!: number | undefined;
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketUseCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketUseCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUseCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketUseCondition {
    amount: number | undefined;
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class CreateCouponByTicketInput implements ICreateCouponByTicketInput {
    id!: number;
    creationTime!: DateTime;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    avaliableDays!: number | undefined;
    expireTime!: DateTime | undefined;
    isTaked!: boolean;
    description!: string | undefined;
    ticketType!: TicketType;
    takeType!: TakeType;
    value!: number;
    useCondition!: TicketUseCondition;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;
    ticketStatus!: AuditStatus;

    constructor(data?: ICreateCouponByTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.expireTime = _data["expireTime"] ? DateTime.fromISO(_data["expireTime"].toString()) : <any>undefined;
            this.isTaked = _data["isTaked"];
            this.description = _data["description"];
            this.ticketType = _data["ticketType"];
            this.takeType = _data["takeType"];
            this.value = _data["value"];
            this.useCondition = _data["useCondition"] ? TicketUseCondition.fromJS(_data["useCondition"]) : <any>undefined;
            if (Array.isArray(_data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of _data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
            this.ticketStatus = _data["ticketStatus"];
        }
    }

    static fromJS(data: any): CreateCouponByTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponByTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["expireTime"] = this.expireTime ? this.expireTime.toString() : <any>undefined;
        data["isTaked"] = this.isTaked;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface ICreateCouponByTicketInput {
    id: number;
    creationTime: DateTime;
    name: string | undefined;
    displayName: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    avaliableDays: number | undefined;
    expireTime: DateTime | undefined;
    isTaked: boolean;
    description: string | undefined;
    ticketType: TicketType;
    takeType: TakeType;
    value: number;
    useCondition: TicketUseCondition;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
    ticketStatus: AuditStatus;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data; 
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data; 
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data; 
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data; 
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateString = _data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export enum DeviceStatus {
    Stopped = 0,
    Running = 1,
}

export class TenantDeviceOutput implements ITenantDeviceOutput {
    tenantName!: string | undefined;
    name!: string | undefined;
    auditStatus!: AuditStatus;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    organizationUnitName!: string | undefined;
    orderNumber!: number;
    imageUrl!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    mac!: string | undefined;
    coverArea!: number | undefined;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    os!: string | undefined;
    address!: string | undefined;
    heartBeatTime!: DateTime | undefined;
    startTime!: DateTime | undefined;
    shutdownTime!: DateTime | undefined;
    isRegistered!: boolean;
    snapshotUrl!: string | undefined;
    snapshotTime!: DateTime | undefined;
    captureImageUrl!: string | undefined;
    captureImageTime!: DateTime | undefined;
    errorStartTime!: DateTime | undefined;
    expiredTime!: DateTime | undefined;
    isLocked!: boolean;
    operatingType!: OperatingType;
    bussinessType!: BussinessType;
    startedUsedTime!: DateTime | undefined;
    heatImageUrl!: string | undefined;
    comments!: string | undefined;
    deviceTypeId!: number | undefined;
    deviceType!: DeviceTypeDto;
    peripherals!: DevicePeripheralDto[] | undefined;
    subKey!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;
    status!: number;
    taobaoRegistTime!: DateTime | undefined;
    registerSource!: string | undefined;
    osType!: OsTypeEnum;
    latestResourceUpdateTime!: DateTime | undefined;
    isSupportAccessToChildDevices!: boolean | undefined;
    isSupportRemoteControl!: boolean | undefined;
    abilities!: string | undefined;
    creationTime!: DateTime | undefined;
    id!: number;

    constructor(data?: ITenantDeviceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.name = _data["name"];
            this.auditStatus = _data["auditStatus"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.orderNumber = _data["orderNumber"];
            this.imageUrl = _data["imageUrl"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.mac = _data["mac"];
            this.coverArea = _data["coverArea"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
            this.address = _data["address"];
            this.heartBeatTime = _data["heartBeatTime"] ? DateTime.fromISO(_data["heartBeatTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.isRegistered = _data["isRegistered"];
            this.snapshotUrl = _data["snapshotUrl"];
            this.snapshotTime = _data["snapshotTime"] ? DateTime.fromISO(_data["snapshotTime"].toString()) : <any>undefined;
            this.captureImageUrl = _data["captureImageUrl"];
            this.captureImageTime = _data["captureImageTime"] ? DateTime.fromISO(_data["captureImageTime"].toString()) : <any>undefined;
            this.errorStartTime = _data["errorStartTime"] ? DateTime.fromISO(_data["errorStartTime"].toString()) : <any>undefined;
            this.expiredTime = _data["expiredTime"] ? DateTime.fromISO(_data["expiredTime"].toString()) : <any>undefined;
            this.isLocked = _data["isLocked"];
            this.operatingType = _data["operatingType"];
            this.bussinessType = _data["bussinessType"];
            this.startedUsedTime = _data["startedUsedTime"] ? DateTime.fromISO(_data["startedUsedTime"].toString()) : <any>undefined;
            this.heatImageUrl = _data["heatImageUrl"];
            this.comments = _data["comments"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.deviceType = _data["deviceType"] ? DeviceTypeDto.fromJS(_data["deviceType"]) : <any>undefined;
            if (Array.isArray(_data["peripherals"])) {
                this.peripherals = [] as any;
                for (let item of _data["peripherals"])
                    this.peripherals!.push(DevicePeripheralDto.fromJS(item));
            }
            this.subKey = _data["subKey"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.outerId = _data["outerId"];
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.status = _data["status"];
            this.taobaoRegistTime = _data["taobaoRegistTime"] ? DateTime.fromISO(_data["taobaoRegistTime"].toString()) : <any>undefined;
            this.registerSource = _data["registerSource"];
            this.osType = _data["osType"];
            this.latestResourceUpdateTime = _data["latestResourceUpdateTime"] ? DateTime.fromISO(_data["latestResourceUpdateTime"].toString()) : <any>undefined;
            this.isSupportAccessToChildDevices = _data["isSupportAccessToChildDevices"];
            this.isSupportRemoteControl = _data["isSupportRemoteControl"];
            this.abilities = _data["abilities"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDeviceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDeviceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["name"] = this.name;
        data["auditStatus"] = this.auditStatus;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["organizationUnitName"] = this.organizationUnitName;
        data["orderNumber"] = this.orderNumber;
        data["imageUrl"] = this.imageUrl;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["mac"] = this.mac;
        data["coverArea"] = this.coverArea;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        data["address"] = this.address;
        data["heartBeatTime"] = this.heartBeatTime ? this.heartBeatTime.toString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["isRegistered"] = this.isRegistered;
        data["snapshotUrl"] = this.snapshotUrl;
        data["snapshotTime"] = this.snapshotTime ? this.snapshotTime.toString() : <any>undefined;
        data["captureImageUrl"] = this.captureImageUrl;
        data["captureImageTime"] = this.captureImageTime ? this.captureImageTime.toString() : <any>undefined;
        data["errorStartTime"] = this.errorStartTime ? this.errorStartTime.toString() : <any>undefined;
        data["expiredTime"] = this.expiredTime ? this.expiredTime.toString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["operatingType"] = this.operatingType;
        data["bussinessType"] = this.bussinessType;
        data["startedUsedTime"] = this.startedUsedTime ? this.startedUsedTime.toString() : <any>undefined;
        data["heatImageUrl"] = this.heatImageUrl;
        data["comments"] = this.comments;
        data["deviceTypeId"] = this.deviceTypeId;
        data["deviceType"] = this.deviceType ? this.deviceType.toJSON() : <any>undefined;
        if (Array.isArray(this.peripherals)) {
            data["peripherals"] = [];
            for (let item of this.peripherals)
                data["peripherals"].push(item.toJSON());
        }
        data["subKey"] = this.subKey;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        data["status"] = this.status;
        data["taobaoRegistTime"] = this.taobaoRegistTime ? this.taobaoRegistTime.toString() : <any>undefined;
        data["registerSource"] = this.registerSource;
        data["osType"] = this.osType;
        data["latestResourceUpdateTime"] = this.latestResourceUpdateTime ? this.latestResourceUpdateTime.toString() : <any>undefined;
        data["isSupportAccessToChildDevices"] = this.isSupportAccessToChildDevices;
        data["isSupportRemoteControl"] = this.isSupportRemoteControl;
        data["abilities"] = this.abilities;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantDeviceOutput {
    tenantName: string | undefined;
    name: string | undefined;
    auditStatus: AuditStatus;
    tenantId: number;
    organizationUnitId: number | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    organizationUnitName: string | undefined;
    orderNumber: number;
    imageUrl: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    mac: string | undefined;
    coverArea: number | undefined;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    os: string | undefined;
    address: string | undefined;
    heartBeatTime: DateTime | undefined;
    startTime: DateTime | undefined;
    shutdownTime: DateTime | undefined;
    isRegistered: boolean;
    snapshotUrl: string | undefined;
    snapshotTime: DateTime | undefined;
    captureImageUrl: string | undefined;
    captureImageTime: DateTime | undefined;
    errorStartTime: DateTime | undefined;
    expiredTime: DateTime | undefined;
    isLocked: boolean;
    operatingType: OperatingType;
    bussinessType: BussinessType;
    startedUsedTime: DateTime | undefined;
    heatImageUrl: string | undefined;
    comments: string | undefined;
    deviceTypeId: number | undefined;
    deviceType: DeviceTypeDto;
    peripherals: DevicePeripheralDto[] | undefined;
    subKey: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
    status: number;
    taobaoRegistTime: DateTime | undefined;
    registerSource: string | undefined;
    osType: OsTypeEnum;
    latestResourceUpdateTime: DateTime | undefined;
    isSupportAccessToChildDevices: boolean | undefined;
    isSupportRemoteControl: boolean | undefined;
    abilities: string | undefined;
    creationTime: DateTime | undefined;
    id: number;
}

export class PagedResultDtoOfTenantDeviceOutput implements IPagedResultDtoOfTenantDeviceOutput {
    totalCount!: number;
    items!: TenantDeviceOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDeviceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDeviceOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDeviceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDeviceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantDeviceOutput {
    totalCount: number;
    items: TenantDeviceOutput[] | undefined;
}

export class CreateDeviceInput implements ICreateDeviceInput {
    name!: string;
    orderNumber!: number;
    mac!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    os!: string | undefined;
    address!: string | undefined;
    startTime!: DateTime | undefined;
    shutdownTime!: DateTime | undefined;
    isLocked!: boolean;
    comments!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    isSupportAccessToChildDevices!: boolean;
    isSupportRemoteControl!: boolean;
    deviceTypeId!: number | undefined;
    peripheralIds!: number[] | undefined;
    categoryIds!: number[] | undefined;
    hardwareCode!: string | undefined;
    osType!: OsTypeEnum;
    organizationUnitId!: number | undefined;
    abilities!: string | undefined;
    subKey!: string | undefined;

    constructor(data?: ICreateDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.mac = _data["mac"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
            this.address = _data["address"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.isLocked = _data["isLocked"];
            this.comments = _data["comments"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.outerId = _data["outerId"];
            this.isSupportAccessToChildDevices = _data["isSupportAccessToChildDevices"];
            this.isSupportRemoteControl = _data["isSupportRemoteControl"];
            this.deviceTypeId = _data["deviceTypeId"];
            if (Array.isArray(_data["peripheralIds"])) {
                this.peripheralIds = [] as any;
                for (let item of _data["peripheralIds"])
                    this.peripheralIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.hardwareCode = _data["hardwareCode"];
            this.osType = _data["osType"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.abilities = _data["abilities"];
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): CreateDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["mac"] = this.mac;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        data["address"] = this.address;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["comments"] = this.comments;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["isSupportAccessToChildDevices"] = this.isSupportAccessToChildDevices;
        data["isSupportRemoteControl"] = this.isSupportRemoteControl;
        data["deviceTypeId"] = this.deviceTypeId;
        if (Array.isArray(this.peripheralIds)) {
            data["peripheralIds"] = [];
            for (let item of this.peripheralIds)
                data["peripheralIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["hardwareCode"] = this.hardwareCode;
        data["osType"] = this.osType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["abilities"] = this.abilities;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface ICreateDeviceInput {
    name: string;
    orderNumber: number;
    mac: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    os: string | undefined;
    address: string | undefined;
    startTime: DateTime | undefined;
    shutdownTime: DateTime | undefined;
    isLocked: boolean;
    comments: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    isSupportAccessToChildDevices: boolean;
    isSupportRemoteControl: boolean;
    deviceTypeId: number | undefined;
    peripheralIds: number[] | undefined;
    categoryIds: number[] | undefined;
    hardwareCode: string | undefined;
    osType: OsTypeEnum;
    organizationUnitId: number | undefined;
    abilities: string | undefined;
    subKey: string | undefined;
}

export class CreateDeviceFromScanCodeInput implements ICreateDeviceFromScanCodeInput {
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    name!: string;
    mac!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    hardwareCode!: string | undefined;
    outerId!: string | undefined;
    registerSource!: string | undefined;
    os!: string;
    subKey!: string | undefined;

    constructor(data?: ICreateDeviceFromScanCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.hardwareCode = _data["hardwareCode"];
            this.outerId = _data["outerId"];
            this.registerSource = _data["registerSource"];
            this.os = _data["os"];
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): CreateDeviceFromScanCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceFromScanCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["hardwareCode"] = this.hardwareCode;
        data["outerId"] = this.outerId;
        data["registerSource"] = this.registerSource;
        data["os"] = this.os;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface ICreateDeviceFromScanCodeInput {
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    name: string;
    mac: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    hardwareCode: string | undefined;
    outerId: string | undefined;
    registerSource: string | undefined;
    os: string;
    subKey: string | undefined;
}

export class BindDeviceFromScanCodeInput implements IBindDeviceFromScanCodeInput {
    deviceId!: number;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    name!: string;
    mac!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    hardwareCode!: string | undefined;
    outerId!: string | undefined;
    registerSource!: string | undefined;
    os!: string;
    subKey!: string | undefined;

    constructor(data?: IBindDeviceFromScanCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.hardwareCode = _data["hardwareCode"];
            this.outerId = _data["outerId"];
            this.registerSource = _data["registerSource"];
            this.os = _data["os"];
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): BindDeviceFromScanCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindDeviceFromScanCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["hardwareCode"] = this.hardwareCode;
        data["outerId"] = this.outerId;
        data["registerSource"] = this.registerSource;
        data["os"] = this.os;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface IBindDeviceFromScanCodeInput {
    deviceId: number;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    name: string;
    mac: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    hardwareCode: string | undefined;
    outerId: string | undefined;
    registerSource: string | undefined;
    os: string;
    subKey: string | undefined;
}

export class UpdateDeviceInput implements IUpdateDeviceInput {
    name!: string | undefined;
    orderNumber!: number;
    mac!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    os!: string | undefined;
    address!: string | undefined;
    startTime!: DateTime | undefined;
    shutdownTime!: DateTime | undefined;
    isLocked!: boolean;
    comments!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    outerId!: string | undefined;
    deviceTypeId!: number | undefined;
    peripheralIds!: number[] | undefined;
    categoryIds!: number[] | undefined;
    hardwareCode!: string | undefined;
    osType!: OsTypeEnum;
    isSupportAccessToChildDevices!: boolean;
    isSupportRemoteControl!: boolean;
    abilities!: string | undefined;
    id!: number;

    constructor(data?: IUpdateDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.mac = _data["mac"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
            this.address = _data["address"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.isLocked = _data["isLocked"];
            this.comments = _data["comments"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.outerId = _data["outerId"];
            this.deviceTypeId = _data["deviceTypeId"];
            if (Array.isArray(_data["peripheralIds"])) {
                this.peripheralIds = [] as any;
                for (let item of _data["peripheralIds"])
                    this.peripheralIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.hardwareCode = _data["hardwareCode"];
            this.osType = _data["osType"];
            this.isSupportAccessToChildDevices = _data["isSupportAccessToChildDevices"];
            this.isSupportRemoteControl = _data["isSupportRemoteControl"];
            this.abilities = _data["abilities"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["mac"] = this.mac;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        data["address"] = this.address;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["comments"] = this.comments;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["outerId"] = this.outerId;
        data["deviceTypeId"] = this.deviceTypeId;
        if (Array.isArray(this.peripheralIds)) {
            data["peripheralIds"] = [];
            for (let item of this.peripheralIds)
                data["peripheralIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["hardwareCode"] = this.hardwareCode;
        data["osType"] = this.osType;
        data["isSupportAccessToChildDevices"] = this.isSupportAccessToChildDevices;
        data["isSupportRemoteControl"] = this.isSupportRemoteControl;
        data["abilities"] = this.abilities;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUpdateDeviceInput {
    name: string | undefined;
    orderNumber: number;
    mac: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    os: string | undefined;
    address: string | undefined;
    startTime: DateTime | undefined;
    shutdownTime: DateTime | undefined;
    isLocked: boolean;
    comments: string | undefined;
    onlineTrafficTarget: string | undefined;
    outerId: string | undefined;
    deviceTypeId: number | undefined;
    peripheralIds: number[] | undefined;
    categoryIds: number[] | undefined;
    hardwareCode: string | undefined;
    osType: OsTypeEnum;
    isSupportAccessToChildDevices: boolean;
    isSupportRemoteControl: boolean;
    abilities: string | undefined;
    id: number;
}

export class AdOutDto implements IAdOutDto {
    id!: number;
    creationTime!: DateTime;
    ageScope!: string | undefined;
    auditStatus!: AuditStatus;
    fileUrl!: string | undefined;
    name!: string | undefined;
    adsTags!: IdNameDto[] | undefined;
    resourceType!: string | undefined;
    organizationUnitId!: number | undefined;
    isMine!: boolean;
    isCustom!: boolean;

    constructor(data?: IAdOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.ageScope = _data["ageScope"];
            this.auditStatus = _data["auditStatus"];
            this.fileUrl = _data["fileUrl"];
            this.name = _data["name"];
            if (Array.isArray(_data["adsTags"])) {
                this.adsTags = [] as any;
                for (let item of _data["adsTags"])
                    this.adsTags!.push(IdNameDto.fromJS(item));
            }
            this.resourceType = _data["resourceType"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isMine = _data["isMine"];
            this.isCustom = _data["isCustom"];
        }
    }

    static fromJS(data: any): AdOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["ageScope"] = this.ageScope;
        data["auditStatus"] = this.auditStatus;
        data["fileUrl"] = this.fileUrl;
        data["name"] = this.name;
        if (Array.isArray(this.adsTags)) {
            data["adsTags"] = [];
            for (let item of this.adsTags)
                data["adsTags"].push(item.toJSON());
        }
        data["resourceType"] = this.resourceType;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isMine"] = this.isMine;
        data["isCustom"] = this.isCustom;
        return data; 
    }
}

export interface IAdOutDto {
    id: number;
    creationTime: DateTime;
    ageScope: string | undefined;
    auditStatus: AuditStatus;
    fileUrl: string | undefined;
    name: string | undefined;
    adsTags: IdNameDto[] | undefined;
    resourceType: string | undefined;
    organizationUnitId: number | undefined;
    isMine: boolean;
    isCustom: boolean;
}

export class PagedResultDtoOfAdOutDto implements IPagedResultDtoOfAdOutDto {
    totalCount!: number;
    items!: AdOutDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAdOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdOutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAdOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAdOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAdOutDto {
    totalCount: number;
    items: AdOutDto[] | undefined;
}

export class DeviceSoftwareDto implements IDeviceSoftwareDto {
    id!: number;
    creationTime!: DateTime | undefined;
    name!: string | undefined;
    code!: string | undefined;
    isDefault!: boolean;
    hostingStatus!: string | undefined;
    materialPacketUrl!: string | undefined;
    extensionData!: string | undefined;
    softwareId!: number;
    largeImageUrl!: string | undefined;
    alias!: string | undefined;
    dispatchedId!: number;
    envType!: string | undefined;
    endTime!: DateTime | undefined;
    type!: string | undefined;
    isExpired!: boolean;

    constructor(data?: IDeviceSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.isDefault = _data["isDefault"];
            this.hostingStatus = _data["hostingStatus"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.extensionData = _data["extensionData"];
            this.softwareId = _data["softwareId"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.alias = _data["alias"];
            this.dispatchedId = _data["dispatchedId"];
            this.envType = _data["envType"];
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): DeviceSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["isDefault"] = this.isDefault;
        data["hostingStatus"] = this.hostingStatus;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["extensionData"] = this.extensionData;
        data["softwareId"] = this.softwareId;
        data["largeImageUrl"] = this.largeImageUrl;
        data["alias"] = this.alias;
        data["dispatchedId"] = this.dispatchedId;
        data["envType"] = this.envType;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["type"] = this.type;
        data["isExpired"] = this.isExpired;
        return data; 
    }
}

export interface IDeviceSoftwareDto {
    id: number;
    creationTime: DateTime | undefined;
    name: string | undefined;
    code: string | undefined;
    isDefault: boolean;
    hostingStatus: string | undefined;
    materialPacketUrl: string | undefined;
    extensionData: string | undefined;
    softwareId: number;
    largeImageUrl: string | undefined;
    alias: string | undefined;
    dispatchedId: number;
    envType: string | undefined;
    endTime: DateTime | undefined;
    type: string | undefined;
    isExpired: boolean;
}

export class PagedResultDtoOfDeviceSoftwareDto implements IPagedResultDtoOfDeviceSoftwareDto {
    totalCount!: number;
    items!: DeviceSoftwareDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceSoftwareDto {
    totalCount: number;
    items: DeviceSoftwareDto[] | undefined;
}

export enum ShopFreightBindingType {
    Calculate = 0,
    Fixed = 1,
}

export class SkuOnlineStoreInfoDto implements ISkuOnlineStoreInfoDto {
    id!: number;
    skuId!: number;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    sku_ID!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: ISkuOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): SkuOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ISkuOnlineStoreInfoDto {
    id: number;
    skuId: number;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    sku_ID: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class SkuFileDto implements ISkuFileDto {
    id!: number;
    skuId!: number;
    resourceId!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    category!: string | undefined;
    fromType!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    type!: string | undefined;
    created!: DateTime | undefined;

    constructor(data?: ISkuFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.resourceId = _data["resourceId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["resourceId"] = this.resourceId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toString() : <any>undefined;
        return data; 
    }
}

export interface ISkuFileDto {
    id: number;
    skuId: number;
    resourceId: number;
    name: string | undefined;
    fileUrl: string | undefined;
    category: string | undefined;
    fromType: string | undefined;
    usage: string | undefined;
    description: string | undefined;
    type: string | undefined;
    created: DateTime | undefined;
}

export class Sku_PropertyValueDto implements ISku_PropertyValueDto {
    propertyId!: number;
    propertyValueId!: number;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISku_PropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyValueId = _data["propertyValueId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Sku_PropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new Sku_PropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyValueId"] = this.propertyValueId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISku_PropertyValueDto {
    propertyId: number;
    propertyValueId: number;
    name: string | undefined;
    value: string | undefined;
}

export enum RedeemType {
    None = 0,
    Full = 1,
    Partial = 2,
}

export class RedeemRule implements IRedeemRule {
    pointRedeemable!: boolean;
    redeemType!: RedeemType;
    redeemAmount!: number;
    cashAmount!: number;

    constructor(data?: IRedeemRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pointRedeemable = _data["pointRedeemable"];
            this.redeemType = _data["redeemType"];
            this.redeemAmount = _data["redeemAmount"];
            this.cashAmount = _data["cashAmount"];
        }
    }

    static fromJS(data: any): RedeemRule {
        data = typeof data === 'object' ? data : {};
        let result = new RedeemRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pointRedeemable"] = this.pointRedeemable;
        data["redeemType"] = this.redeemType;
        data["redeemAmount"] = this.redeemAmount;
        data["cashAmount"] = this.cashAmount;
        return data; 
    }
}

export interface IRedeemRule {
    pointRedeemable: boolean;
    redeemType: RedeemType;
    redeemAmount: number;
    cashAmount: number;
}

export class AwardRule implements IAwardRule {
    pointAwardable!: boolean;
    awardAmount!: number;

    constructor(data?: IAwardRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pointAwardable = _data["pointAwardable"];
            this.awardAmount = _data["awardAmount"];
        }
    }

    static fromJS(data: any): AwardRule {
        data = typeof data === 'object' ? data : {};
        let result = new AwardRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pointAwardable"] = this.pointAwardable;
        data["awardAmount"] = this.awardAmount;
        return data; 
    }
}

export interface IAwardRule {
    pointAwardable: boolean;
    awardAmount: number;
}

export class ProductPointRule implements IProductPointRule {
    redeemRule!: RedeemRule;
    awardRule!: AwardRule;

    constructor(data?: IProductPointRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redeemRule = _data["redeemRule"] ? RedeemRule.fromJS(_data["redeemRule"]) : <any>undefined;
            this.awardRule = _data["awardRule"] ? AwardRule.fromJS(_data["awardRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductPointRule {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redeemRule"] = this.redeemRule ? this.redeemRule.toJSON() : <any>undefined;
        data["awardRule"] = this.awardRule ? this.awardRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductPointRule {
    redeemRule: RedeemRule;
    awardRule: AwardRule;
}

export class SkuDto implements ISkuDto {
    id!: number;
    sku_id!: string | undefined;
    quantity!: number;
    propsName!: string | undefined;
    title!: string | undefined;
    price!: string | undefined;
    qrCodeUrl!: string | undefined;
    keywords!: string | undefined;
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    skuTags!: IdNameDto[] | undefined;
    isMine!: boolean;
    onlineStoreInfos!: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos!: SkuFileDto[] | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preSkuId!: number;
    nextSkuId!: number;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    productId!: number;
    skuCategories!: IdNameDto[] | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;
    weight!: number;

    constructor(data?: ISkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(SkuFileDto.fromJS(item));
            }
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preSkuId = _data["preSkuId"];
            this.nextSkuId = _data["nextSkuId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.productId = _data["productId"];
            if (Array.isArray(_data["skuCategories"])) {
                this.skuCategories = [] as any;
                for (let item of _data["skuCategories"])
                    this.skuCategories!.push(IdNameDto.fromJS(item));
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): SkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preSkuId"] = this.preSkuId;
        data["nextSkuId"] = this.nextSkuId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["productId"] = this.productId;
        if (Array.isArray(this.skuCategories)) {
            data["skuCategories"] = [];
            for (let item of this.skuCategories)
                data["skuCategories"].push(item.toJSON());
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface ISkuDto {
    id: number;
    sku_id: string | undefined;
    quantity: number;
    propsName: string | undefined;
    title: string | undefined;
    price: string | undefined;
    qrCodeUrl: string | undefined;
    keywords: string | undefined;
    auditStatus: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    orderNumber: number;
    skuTags: IdNameDto[] | undefined;
    isMine: boolean;
    onlineStoreInfos: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos: SkuFileDto[] | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    barcode: string | undefined;
    starLevel: number | undefined;
    preSkuId: number;
    nextSkuId: number;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    productId: number;
    skuCategories: IdNameDto[] | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
    weight: number;
}

export enum OnlineStore {
    MyStore = 0,
    Taobao = 1,
    JD = 2,
    Suning = 3,
    Shangpai = 4,
    Baisheng_Openshop = 5,
    Amazon = 6,
    Amazonedi = 7,
    Yihaodian = 8,
    Dangdang = 9,
    Baisheng_Encm = 10,
    Vjia = 11,
    Yougou = 12,
    Yintai = 13,
    Jumei = 14,
    Weigou = 15,
    M18 = 16,
    Baisheng_Ishop = 17,
    Taobao_Fenxiao = 18,
    Baisheng_Icrm = 19,
    Baisheng_M6 = 20,
    Koudaitong = 21,
    Feiniu = 22,
    Feiniu_zd = 23,
    Suning_hwg = 24,
    Jingdong_qqg = 25,
    Weimeng = 26,
    Magento = 27,
    Icbc = 28,
    Juanpi = 29,
    Xiaodian = 30,
    Zhe800 = 31,
    Kaola = 32,
    Beibei = 33,
    Paipai = 34,
    Baidu = 35,
    Chuchujie = 36,
    Guomei = 37,
    Mogujie = 38,
    Alibaba = 39,
    Cbc = 40,
    Hichao = 41,
    Mengdian = 42,
    Mia = 43,
    Renren = 44,
    Aliexpress = 45,
    Shangpin = 46,
    Okbuy = 47,
    Pinduoduo = 48,
    Qiake = 49,
    Wangyi = 50,
    Lefeng = 51,
    EBay = 52,
    Xindan = 53,
    Weipinhui = 54,
    Weipinhui_jit = 55,
    ECSHOP = 56,
    ZhinengmendianPad = 57,
    ProductApp = 58,
    Youhuo = 59,
    Shimao = 60,
    Zhenpin = 61,
    Yunji = 62,
    Haiziwang = 63,
    Siku = 64,
    Suning_temai = 65,
    Yike = 66,
}

export class ProductOnlineStoreInfoDto implements IProductOnlineStoreInfoDto {
    id!: number;
    productId!: number;
    storeId!: string | undefined;
    type!: OnlineStore;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    pid!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: IProductOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.storeId = _data["storeId"];
            this.type = _data["type"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): ProductOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["storeId"] = this.storeId;
        data["type"] = this.type;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IProductOnlineStoreInfoDto {
    id: number;
    productId: number;
    storeId: string | undefined;
    type: OnlineStore;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    pid: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class PropertyValueDto implements IPropertyValueDto {
    id!: number;
    propertyId!: number;
    propertyName!: string | undefined;
    value!: string | undefined;
    description!: string | undefined;
    defaultImage!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.defaultImage = _data["defaultImage"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): PropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["value"] = this.value;
        data["description"] = this.description;
        data["defaultImage"] = this.defaultImage;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IPropertyValueDto {
    id: number;
    propertyId: number;
    propertyName: string | undefined;
    value: string | undefined;
    description: string | undefined;
    defaultImage: string | undefined;
    iconUrl: string | undefined;
}

export class PropertyDto implements IPropertyDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    name!: string;
    isDefaultDecideImage!: boolean;
    isForSale!: boolean;
    fromType!: string | undefined;
    propertyValues!: PropertyValueDto[] | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueDto.fromJS(item));
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    name: string;
    isDefaultDecideImage: boolean;
    isForSale: boolean;
    fromType: string | undefined;
    propertyValues: PropertyValueDto[] | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductDto implements IProductDto {
    id!: number;
    itemId!: string | undefined;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    quantity!: number;
    propsName!: string | undefined;
    title!: string | undefined;
    subTitle!: string | undefined;
    price!: number;
    qrCodeUrl!: string | undefined;
    keywords!: string | undefined;
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    likeCount!: number;
    description!: string | undefined;
    created!: DateTime | undefined;
    lastUpdated!: DateTime | undefined;
    orderNumber!: number;
    p_ProductCategories!: IdNameDto[] | undefined;
    skus!: SkuDto[] | undefined;
    itemImagesOrVideos!: EntityFileDto[] | undefined;
    productTags!: IdNameDto[] | undefined;
    onlineStoreInfos!: ProductOnlineStoreInfoDto[] | undefined;
    skuProperties!: PropertyDto[] | undefined;
    sumPropsName!: string | undefined;
    sellerId!: string | undefined;
    visualImagePropertyId!: number | undefined;
    promPrice!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preProductId!: number;
    nextProductId!: number;
    brand!: IdNameDto;
    creationTime!: DateTime;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.created = _data["created"] ? DateTime.fromISO(_data["created"].toString()) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? DateTime.fromISO(_data["lastUpdated"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["p_ProductCategories"])) {
                this.p_ProductCategories = [] as any;
                for (let item of _data["p_ProductCategories"])
                    this.p_ProductCategories!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileDto.fromJS(item));
            }
            if (Array.isArray(_data["productTags"])) {
                this.productTags = [] as any;
                for (let item of _data["productTags"])
                    this.productTags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(ProductOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["skuProperties"])) {
                this.skuProperties = [] as any;
                for (let item of _data["skuProperties"])
                    this.skuProperties!.push(PropertyDto.fromJS(item));
            }
            this.sumPropsName = _data["sumPropsName"];
            this.sellerId = _data["sellerId"];
            this.visualImagePropertyId = _data["visualImagePropertyId"];
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preProductId = _data["preProductId"];
            this.nextProductId = _data["nextProductId"];
            this.brand = _data["brand"] ? IdNameDto.fromJS(_data["brand"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toString() : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.p_ProductCategories)) {
            data["p_ProductCategories"] = [];
            for (let item of this.p_ProductCategories)
                data["p_ProductCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.productTags)) {
            data["productTags"] = [];
            for (let item of this.productTags)
                data["productTags"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.skuProperties)) {
            data["skuProperties"] = [];
            for (let item of this.skuProperties)
                data["skuProperties"].push(item.toJSON());
        }
        data["sumPropsName"] = this.sumPropsName;
        data["sellerId"] = this.sellerId;
        data["visualImagePropertyId"] = this.visualImagePropertyId;
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preProductId"] = this.preProductId;
        data["nextProductId"] = this.nextProductId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductDto {
    id: number;
    itemId: string | undefined;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    quantity: number;
    propsName: string | undefined;
    title: string | undefined;
    subTitle: string | undefined;
    price: number;
    qrCodeUrl: string | undefined;
    keywords: string | undefined;
    auditStatus: string | undefined;
    picUrl: string | undefined;
    likeCount: number;
    description: string | undefined;
    created: DateTime | undefined;
    lastUpdated: DateTime | undefined;
    orderNumber: number;
    p_ProductCategories: IdNameDto[] | undefined;
    skus: SkuDto[] | undefined;
    itemImagesOrVideos: EntityFileDto[] | undefined;
    productTags: IdNameDto[] | undefined;
    onlineStoreInfos: ProductOnlineStoreInfoDto[] | undefined;
    skuProperties: PropertyDto[] | undefined;
    sumPropsName: string | undefined;
    sellerId: string | undefined;
    visualImagePropertyId: number | undefined;
    promPrice: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    barcode: string | undefined;
    starLevel: number | undefined;
    preProductId: number;
    nextProductId: number;
    brand: IdNameDto;
    creationTime: DateTime;
    isMine: boolean;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class PagedResultDtoOfProductDto implements IPagedResultDtoOfProductDto {
    totalCount!: number;
    items!: ProductDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductDto {
    totalCount: number;
    items: ProductDto[] | undefined;
}

export class DeviceSkusDto implements IDeviceSkusDto {
    id!: number;
    quantity!: number;
    title!: string | undefined;
    price!: number;
    promPrice!: number;
    price2!: number | undefined;
    keywords!: string | undefined;
    auditStatus!: AuditStatus;
    picUrl!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    salesVolume!: number;
    starLevel!: number | undefined;
    creationTime!: DateTime;
    skuTags!: IdNameDto[] | undefined;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    isDefault!: boolean;

    constructor(data?: IDeviceSkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.salesVolume = _data["salesVolume"];
            this.starLevel = _data["starLevel"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): DeviceSkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["salesVolume"] = this.salesVolume;
        data["starLevel"] = this.starLevel;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IDeviceSkusDto {
    id: number;
    quantity: number;
    title: string | undefined;
    price: number;
    promPrice: number;
    price2: number | undefined;
    keywords: string | undefined;
    auditStatus: AuditStatus;
    picUrl: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    salesVolume: number;
    starLevel: number | undefined;
    creationTime: DateTime;
    skuTags: IdNameDto[] | undefined;
    isMine: boolean;
    organizationUnitId: number | undefined;
    isDefault: boolean;
}

export class PagedResultDtoOfDeviceSkusDto implements IPagedResultDtoOfDeviceSkusDto {
    totalCount!: number;
    items!: DeviceSkusDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceSkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSkusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceSkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceSkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceSkusDto {
    totalCount: number;
    items: DeviceSkusDto[] | undefined;
}

export class ProuctListOutPut implements IProuctListOutPut {
    id!: number;
    itemId!: string | undefined;
    title!: string | undefined;
    price!: number;
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;
    productCategories!: IdNamePicDto[] | undefined;
    productTags!: IdNamePicDto[] | undefined;
    salesVolume!: number;
    quantity!: number;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProuctListOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["productCategories"])) {
                this.productCategories = [] as any;
                for (let item of _data["productCategories"])
                    this.productCategories!.push(IdNamePicDto.fromJS(item));
            }
            if (Array.isArray(_data["productTags"])) {
                this.productTags = [] as any;
                for (let item of _data["productTags"])
                    this.productTags!.push(IdNamePicDto.fromJS(item));
            }
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProuctListOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new ProuctListOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        if (Array.isArray(this.productCategories)) {
            data["productCategories"] = [];
            for (let item of this.productCategories)
                data["productCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productTags)) {
            data["productTags"] = [];
            for (let item of this.productTags)
                data["productTags"].push(item.toJSON());
        }
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProuctListOutPut {
    id: number;
    itemId: string | undefined;
    title: string | undefined;
    price: number;
    auditStatus: string | undefined;
    picUrl: string | undefined;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
    productCategories: IdNamePicDto[] | undefined;
    productTags: IdNamePicDto[] | undefined;
    salesVolume: number;
    quantity: number;
    isMine: boolean;
    organizationUnitId: number | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class PagedResultDtoOfProuctListOutPut implements IPagedResultDtoOfProuctListOutPut {
    totalCount!: number;
    items!: ProuctListOutPut[] | undefined;

    constructor(data?: IPagedResultDtoOfProuctListOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProuctListOutPut.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProuctListOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProuctListOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProuctListOutPut {
    totalCount: number;
    items: ProuctListOutPut[] | undefined;
}

export class TreeItemDto implements ITreeItemDto {
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    deviceTypeId!: number | undefined;
    children!: TreeItemDto[] | undefined;

    constructor(data?: ITreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            this.deviceTypeId = _data["deviceTypeId"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        data["deviceTypeId"] = this.deviceTypeId;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITreeItemDto {
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    deviceTypeId: number | undefined;
    children: TreeItemDto[] | undefined;
}

export class PublishDeviceInput implements IPublishDeviceInput {
    deviceIds!: number[] | undefined;
    storeId!: number;

    constructor(data?: IPublishDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): PublishDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IPublishDeviceInput {
    deviceIds: number[] | undefined;
    storeId: number;
}

export class RecycleDeviceInput implements IRecycleDeviceInput {
    deviceIds!: number[] | undefined;

    constructor(data?: IRecycleDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RecycleDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new RecycleDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        return data; 
    }
}

export interface IRecycleDeviceInput {
    deviceIds: number[] | undefined;
}

export class DeviceMirrorPublishInput implements IDeviceMirrorPublishInput {
    sourceId!: number;
    targetIds!: number[];
    features!: string[];

    constructor(data?: IDeviceMirrorPublishInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.targetIds = [];
            this.features = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceId = _data["sourceId"];
            if (Array.isArray(_data["targetIds"])) {
                this.targetIds = [] as any;
                for (let item of _data["targetIds"])
                    this.targetIds!.push(item);
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceMirrorPublishInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceMirrorPublishInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        if (Array.isArray(this.targetIds)) {
            data["targetIds"] = [];
            for (let item of this.targetIds)
                data["targetIds"].push(item);
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item);
        }
        return data; 
    }
}

export interface IDeviceMirrorPublishInput {
    sourceId: number;
    targetIds: number[];
    features: string[];
}

export class UpdateThirdDeivceCodeInput implements IUpdateThirdDeivceCodeInput {
    deviceId!: number;
    code!: string | undefined;
    platformType!: ExternalEnum;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;

    constructor(data?: IUpdateThirdDeivceCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.code = _data["code"];
            this.platformType = _data["platformType"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
        }
    }

    static fromJS(data: any): UpdateThirdDeivceCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateThirdDeivceCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["code"] = this.code;
        data["platformType"] = this.platformType;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        return data; 
    }
}

export interface IUpdateThirdDeivceCodeInput {
    deviceId: number;
    code: string | undefined;
    platformType: ExternalEnum;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
}

export class AddSmartStoreDeviceToExtraPlatformInput implements IAddSmartStoreDeviceToExtraPlatformInput {
    deviceId!: number;
    platformType!: ExternalEnum;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    externalAccessTokenInfoId!: number | undefined;

    constructor(data?: IAddSmartStoreDeviceToExtraPlatformInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.platformType = _data["platformType"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
        }
    }

    static fromJS(data: any): AddSmartStoreDeviceToExtraPlatformInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddSmartStoreDeviceToExtraPlatformInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["platformType"] = this.platformType;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        return data; 
    }
}

export interface IAddSmartStoreDeviceToExtraPlatformInput {
    deviceId: number;
    platformType: ExternalEnum;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    externalAccessTokenInfoId: number | undefined;
}

export class ExtraPlatformDeviceDto implements IExtraPlatformDeviceDto {
    platformType!: ExternalEnum;
    extraStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    extraDeviceId!: string | undefined;
    extraRegistTime!: DateTime;

    constructor(data?: IExtraPlatformDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformType = _data["platformType"];
            this.extraStoreId = _data["extraStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.extraRegistTime = _data["extraRegistTime"] ? DateTime.fromISO(_data["extraRegistTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtraPlatformDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraPlatformDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformType"] = this.platformType;
        data["extraStoreId"] = this.extraStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["extraDeviceId"] = this.extraDeviceId;
        data["extraRegistTime"] = this.extraRegistTime ? this.extraRegistTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IExtraPlatformDeviceDto {
    platformType: ExternalEnum;
    extraStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    extraDeviceId: string | undefined;
    extraRegistTime: DateTime;
}

export class SkuSimpleDto implements ISkuSimpleDto {
    sku_id!: string | undefined;
    title!: string | undefined;
    price!: string | undefined;
    promPrice!: string | undefined;
    qrCodeUrl!: string | undefined;
    keywords!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    productId!: number;
    quantity!: number;
    starLevel!: number | undefined;
    auditStatus!: AuditStatus;
    salesVolume!: number;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    barcode!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISkuSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku_id = _data["sku_id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.starLevel = _data["starLevel"];
            this.auditStatus = _data["auditStatus"];
            this.salesVolume = _data["salesVolume"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.barcode = _data["barcode"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkuSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku_id"] = this.sku_id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["starLevel"] = this.starLevel;
        data["auditStatus"] = this.auditStatus;
        data["salesVolume"] = this.salesVolume;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["barcode"] = this.barcode;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISkuSimpleDto {
    sku_id: string | undefined;
    title: string | undefined;
    price: string | undefined;
    promPrice: string | undefined;
    qrCodeUrl: string | undefined;
    keywords: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    productId: number;
    quantity: number;
    starLevel: number | undefined;
    auditStatus: AuditStatus;
    salesVolume: number;
    isMine: boolean;
    organizationUnitId: number | undefined;
    barcode: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSkuSimpleDto implements IPagedResultDtoOfSkuSimpleDto {
    totalCount!: number;
    items!: SkuSimpleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSkuSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSkuSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSkuSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSkuSimpleDto {
    totalCount: number;
    items: SkuSimpleDto[] | undefined;
}

export class DeviceActionInput implements IDeviceActionInput {
    deviceId!: number;
    actionName!: string;
    appId!: string | undefined;
    actionContent!: string | undefined;

    constructor(data?: IDeviceActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.actionName = _data["actionName"];
            this.appId = _data["appId"];
            this.actionContent = _data["actionContent"];
        }
    }

    static fromJS(data: any): DeviceActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["actionName"] = this.actionName;
        data["appId"] = this.appId;
        data["actionContent"] = this.actionContent;
        return data; 
    }
}

export interface IDeviceActionInput {
    deviceId: number;
    actionName: string;
    appId: string | undefined;
    actionContent: string | undefined;
}

export class DevicesActionInput implements IDevicesActionInput {
    deviceIds!: number[];
    actionName!: string;
    appId!: string | undefined;
    actionContent!: string | undefined;

    constructor(data?: IDevicesActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.deviceIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.actionName = _data["actionName"];
            this.appId = _data["appId"];
            this.actionContent = _data["actionContent"];
        }
    }

    static fromJS(data: any): DevicesActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new DevicesActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["actionName"] = this.actionName;
        data["appId"] = this.appId;
        data["actionContent"] = this.actionContent;
        return data; 
    }
}

export interface IDevicesActionInput {
    deviceIds: number[];
    actionName: string;
    appId: string | undefined;
    actionContent: string | undefined;
}

export class DevicesActionInputWithSubkey implements IDevicesActionInputWithSubkey {
    actionName!: string;
    subKey!: string | undefined;
    from!: string | undefined;
    actionContent!: string | undefined;

    constructor(data?: IDevicesActionInputWithSubkey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionName = _data["actionName"];
            this.subKey = _data["subKey"];
            this.from = _data["from"];
            this.actionContent = _data["actionContent"];
        }
    }

    static fromJS(data: any): DevicesActionInputWithSubkey {
        data = typeof data === 'object' ? data : {};
        let result = new DevicesActionInputWithSubkey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionName"] = this.actionName;
        data["subKey"] = this.subKey;
        data["from"] = this.from;
        data["actionContent"] = this.actionContent;
        return data; 
    }
}

export interface IDevicesActionInputWithSubkey {
    actionName: string;
    subKey: string | undefined;
    from: string | undefined;
    actionContent: string | undefined;
}

export class DeviceCategoryDto implements IDeviceCategoryDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    name!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceCategoryDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    name: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfDeviceCategoryDto implements IPagedResultDtoOfDeviceCategoryDto {
    totalCount!: number;
    items!: DeviceCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceCategoryDto {
    totalCount: number;
    items: DeviceCategoryDto[] | undefined;
}

export class CreateDeviceCategoryInput implements ICreateDeviceCategoryInput {
    name!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreateDeviceCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreateDeviceCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreateDeviceCategoryInput {
    name: string | undefined;
    iconUrl: string | undefined;
}

export class UpdateDeviceCategoryInput implements IUpdateDeviceCategoryInput {
    id!: number;
    name!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdateDeviceCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdateDeviceCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdateDeviceCategoryInput {
    id: number;
    name: string | undefined;
    iconUrl: string | undefined;
}

export class SelectDtoOfInt32 implements ISelectDtoOfInt32 {
    selectKey!: number;
    selectValue!: string | undefined;

    constructor(data?: ISelectDtoOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.selectKey = _data["selectKey"];
            this.selectValue = _data["selectValue"];
        }
    }

    static fromJS(data: any): SelectDtoOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new SelectDtoOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["selectKey"] = this.selectKey;
        data["selectValue"] = this.selectValue;
        return data; 
    }
}

export interface ISelectDtoOfInt32 {
    selectKey: number;
    selectValue: string | undefined;
}

export class CreateDeviceExtraInput implements ICreateDeviceExtraInput {
    deviceId!: number;
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;
    externalAccessTokenInfoId!: number | undefined;

    constructor(data?: ICreateDeviceExtraInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
        }
    }

    static fromJS(data: any): CreateDeviceExtraInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceExtraInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        return data; 
    }
}

export interface ICreateDeviceExtraInput {
    deviceId: number;
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
    externalAccessTokenInfoId: number | undefined;
}

export class DeviceExtraDto implements IDeviceExtraDto {
    tenantId!: number;
    deviceId!: number;
    deviceName!: string | undefined;
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceExtraDto {
    tenantId: number;
    deviceId: number;
    deviceName: string | undefined;
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UpdateDeviceExtraInput implements IUpdateDeviceExtraInput {
    id!: number;
    deviceId!: number;
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;
    externalAccessTokenInfoId!: number | undefined;

    constructor(data?: IUpdateDeviceExtraInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
            this.externalAccessTokenInfoId = _data["externalAccessTokenInfoId"];
        }
    }

    static fromJS(data: any): UpdateDeviceExtraInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceExtraInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        data["externalAccessTokenInfoId"] = this.externalAccessTokenInfoId;
        return data; 
    }
}

export interface IUpdateDeviceExtraInput {
    id: number;
    deviceId: number;
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
    externalAccessTokenInfoId: number | undefined;
}

export class PagedResultDtoOfDeviceExtraDto implements IPagedResultDtoOfDeviceExtraDto {
    totalCount!: number;
    items!: DeviceExtraDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceExtraDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceExtraDto {
    totalCount: number;
    items: DeviceExtraDto[] | undefined;
}

export class DeviceHeatMapViewModel implements IDeviceHeatMapViewModel {
    collectionTime!: DateTime;
    snapShotUrl!: string | undefined;
    heatMapValues!: string[][] | undefined;

    constructor(data?: IDeviceHeatMapViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionTime = _data["collectionTime"] ? DateTime.fromISO(_data["collectionTime"].toString()) : <any>undefined;
            this.snapShotUrl = _data["snapShotUrl"];
            if (Array.isArray(_data["heatMapValues"])) {
                this.heatMapValues = [] as any;
                for (let item of _data["heatMapValues"])
                    this.heatMapValues!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceHeatMapViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeatMapViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toString() : <any>undefined;
        data["snapShotUrl"] = this.snapShotUrl;
        if (Array.isArray(this.heatMapValues)) {
            data["heatMapValues"] = [];
            for (let item of this.heatMapValues)
                data["heatMapValues"].push(item);
        }
        return data; 
    }
}

export interface IDeviceHeatMapViewModel {
    collectionTime: DateTime;
    snapShotUrl: string | undefined;
    heatMapValues: string[][] | undefined;
}

export class PagedResultDtoOfDeviceTypeDto implements IPagedResultDtoOfDeviceTypeDto {
    totalCount!: number;
    items!: DeviceTypeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceTypeDto {
    totalCount: number;
    items: DeviceTypeDto[] | undefined;
}

export class CreateDeviceTypeInput implements ICreateDeviceTypeInput {
    name!: string | undefined;
    iconUrl!: string | undefined;
    abilities!: string | undefined;
    controlItems!: string | undefined;

    constructor(data?: ICreateDeviceTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.abilities = _data["abilities"];
            this.controlItems = _data["controlItems"];
        }
    }

    static fromJS(data: any): CreateDeviceTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["abilities"] = this.abilities;
        data["controlItems"] = this.controlItems;
        return data; 
    }
}

export interface ICreateDeviceTypeInput {
    name: string | undefined;
    iconUrl: string | undefined;
    abilities: string | undefined;
    controlItems: string | undefined;
}

export class UpdateDeviceTypeInput implements IUpdateDeviceTypeInput {
    id!: number;
    name!: string | undefined;
    iconUrl!: string | undefined;
    abilities!: string | undefined;
    controlItems!: string | undefined;

    constructor(data?: IUpdateDeviceTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.abilities = _data["abilities"];
            this.controlItems = _data["controlItems"];
        }
    }

    static fromJS(data: any): UpdateDeviceTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["abilities"] = this.abilities;
        data["controlItems"] = this.controlItems;
        return data; 
    }
}

export interface IUpdateDeviceTypeInput {
    id: number;
    name: string | undefined;
    iconUrl: string | undefined;
    abilities: string | undefined;
    controlItems: string | undefined;
}

export class NameValueAbilities implements INameValueAbilities {
    abilities!: string | undefined;
    controlItems!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueAbilities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.abilities = _data["abilities"];
            this.controlItems = _data["controlItems"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueAbilities {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueAbilities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["abilities"] = this.abilities;
        data["controlItems"] = this.controlItems;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueAbilities {
    abilities: string | undefined;
    controlItems: string | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class ListResultDtoOfNameValueAbilities implements IListResultDtoOfNameValueAbilities {
    items!: NameValueAbilities[] | undefined;

    constructor(data?: IListResultDtoOfNameValueAbilities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueAbilities.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueAbilities {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueAbilities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueAbilities {
    items: NameValueAbilities[] | undefined;
}

export class DynamicEntityPropertyDto implements IDynamicEntityPropertyDto {
    entityFullName!: string | undefined;
    dynamicPropertyName!: string | undefined;
    dynamicPropertyId!: number;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
            this.dynamicPropertyName = _data["dynamicPropertyName"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        data["dynamicPropertyName"] = this.dynamicPropertyName;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicEntityPropertyDto {
    entityFullName: string | undefined;
    dynamicPropertyName: string | undefined;
    dynamicPropertyId: number;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyDto implements IListResultDtoOfDynamicEntityPropertyDto {
    items!: DynamicEntityPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicEntityPropertyDto {
    items: DynamicEntityPropertyDto[] | undefined;
}

export class GetAllEntitiesHasDynamicPropertyOutput implements IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName!: string | undefined;

    constructor(data?: IGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
        }
    }

    static fromJS(data: any): GetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        return data; 
    }
}

export interface IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName: string | undefined;
}

export class ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput implements IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items!: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllEntitiesHasDynamicPropertyOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;
}

export class DynamicEntityPropertyValueDto implements IDynamicEntityPropertyValueDto {
    value!: string | undefined;
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicEntityPropertyValueDto {
    value: string | undefined;
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicEntityPropertyValueDto implements IListResultDtoOfDynamicEntityPropertyValueDto {
    items!: DynamicEntityPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicEntityPropertyValueDto {
    items: DynamicEntityPropertyValueDto[] | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class GetAllDynamicEntityPropertyValuesOutputItem implements IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId!: number;
    propertyName!: string | undefined;
    inputType!: IInputType;
    selectedValues!: string[] | undefined;
    allValuesInputTypeHas!: string[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.propertyName = _data["propertyName"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(item);
            }
            if (Array.isArray(_data["allValuesInputTypeHas"])) {
                this.allValuesInputTypeHas = [] as any;
                for (let item of _data["allValuesInputTypeHas"])
                    this.allValuesInputTypeHas!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["propertyName"] = this.propertyName;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item);
        }
        if (Array.isArray(this.allValuesInputTypeHas)) {
            data["allValuesInputTypeHas"] = [];
            for (let item of this.allValuesInputTypeHas)
                data["allValuesInputTypeHas"].push(item);
        }
        return data; 
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId: number;
    propertyName: string | undefined;
    inputType: IInputType;
    selectedValues: string[] | undefined;
    allValuesInputTypeHas: string[] | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutput implements IGetAllDynamicEntityPropertyValuesOutput {
    items!: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllDynamicEntityPropertyValuesOutputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutput {
    items: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    values!: string[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface IInsertOrUpdateAllValuesInputItem {
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    values: string[] | undefined;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
    items!: InsertOrUpdateAllValuesInputItem[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInsertOrUpdateAllValuesInput {
    items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class CleanValuesInput implements ICleanValuesInput {
    dynamicEntityPropertyId!: number;
    entityId!: string | undefined;

    constructor(data?: ICleanValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): CleanValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CleanValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["entityId"] = this.entityId;
        return data; 
    }
}

export interface ICleanValuesInput {
    dynamicEntityPropertyId: number;
    entityId: string | undefined;
}

export class DynamicPropertyDto implements IDynamicPropertyDto {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyDto {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ListResultDtoOfDynamicPropertyDto implements IListResultDtoOfDynamicPropertyDto {
    items!: DynamicPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicPropertyDto {
    items: DynamicPropertyDto[] | undefined;
}

export class DynamicPropertyValueDto implements IDynamicPropertyValueDto {
    value!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyValueDto {
    value: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    id: number;
}

export class ListResultDtoOfDynamicPropertyValueDto implements IListResultDtoOfDynamicPropertyValueDto {
    items!: DynamicPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfDynamicPropertyValueDto {
    items: DynamicPropertyValueDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class ExternalPadResDto implements IExternalPadResDto {
    bgImage!: string | undefined;
    bgFrame!: string | undefined;
    logo!: string | undefined;
    navBar!: string | undefined;
    deviceSelect!: string | undefined;
    deviceUnSelect!: string | undefined;
    navBotBar!: string | undefined;
    noImage!: string | undefined;
    mainColor!: string | undefined;
    loginButton!: string | undefined;
    confirmButton!: string | undefined;
    groupUnSelect!: string | undefined;
    groupSelect!: string | undefined;
    topbarBg!: string | undefined;
    searchSubmit!: string | undefined;
    searchButton!: string | undefined;
    filterSelect!: string | undefined;
    filterUnSelect!: string | undefined;
    clearButton!: string | undefined;
    navScanIcon!: string | undefined;
    wqcodeScannerLine!: string | undefined;
    changeOuIcon!: string | undefined;
    exitIcon!: string | undefined;
    deviceIcon!: string | undefined;
    defaultProfilePic!: string | undefined;
    publishToDeviceButton!: string | undefined;
    publishToDeviceIcon!: string | undefined;
    qrcodeImage!: string | undefined;

    constructor(data?: IExternalPadResDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bgImage = _data["bgImage"];
            this.bgFrame = _data["bgFrame"];
            this.logo = _data["logo"];
            this.navBar = _data["navBar"];
            this.deviceSelect = _data["deviceSelect"];
            this.deviceUnSelect = _data["deviceUnSelect"];
            this.navBotBar = _data["navBotBar"];
            this.noImage = _data["noImage"];
            this.mainColor = _data["mainColor"];
            this.loginButton = _data["loginButton"];
            this.confirmButton = _data["confirmButton"];
            this.groupUnSelect = _data["groupUnSelect"];
            this.groupSelect = _data["groupSelect"];
            this.topbarBg = _data["topbarBg"];
            this.searchSubmit = _data["searchSubmit"];
            this.searchButton = _data["searchButton"];
            this.filterSelect = _data["filterSelect"];
            this.filterUnSelect = _data["filterUnSelect"];
            this.clearButton = _data["clearButton"];
            this.navScanIcon = _data["navScanIcon"];
            this.wqcodeScannerLine = _data["wqcodeScannerLine"];
            this.changeOuIcon = _data["changeOuIcon"];
            this.exitIcon = _data["exitIcon"];
            this.deviceIcon = _data["deviceIcon"];
            this.defaultProfilePic = _data["defaultProfilePic"];
            this.publishToDeviceButton = _data["publishToDeviceButton"];
            this.publishToDeviceIcon = _data["publishToDeviceIcon"];
            this.qrcodeImage = _data["qrcodeImage"];
        }
    }

    static fromJS(data: any): ExternalPadResDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPadResDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bgImage"] = this.bgImage;
        data["bgFrame"] = this.bgFrame;
        data["logo"] = this.logo;
        data["navBar"] = this.navBar;
        data["deviceSelect"] = this.deviceSelect;
        data["deviceUnSelect"] = this.deviceUnSelect;
        data["navBotBar"] = this.navBotBar;
        data["noImage"] = this.noImage;
        data["mainColor"] = this.mainColor;
        data["loginButton"] = this.loginButton;
        data["confirmButton"] = this.confirmButton;
        data["groupUnSelect"] = this.groupUnSelect;
        data["groupSelect"] = this.groupSelect;
        data["topbarBg"] = this.topbarBg;
        data["searchSubmit"] = this.searchSubmit;
        data["searchButton"] = this.searchButton;
        data["filterSelect"] = this.filterSelect;
        data["filterUnSelect"] = this.filterUnSelect;
        data["clearButton"] = this.clearButton;
        data["navScanIcon"] = this.navScanIcon;
        data["wqcodeScannerLine"] = this.wqcodeScannerLine;
        data["changeOuIcon"] = this.changeOuIcon;
        data["exitIcon"] = this.exitIcon;
        data["deviceIcon"] = this.deviceIcon;
        data["defaultProfilePic"] = this.defaultProfilePic;
        data["publishToDeviceButton"] = this.publishToDeviceButton;
        data["publishToDeviceIcon"] = this.publishToDeviceIcon;
        data["qrcodeImage"] = this.qrcodeImage;
        return data; 
    }
}

export interface IExternalPadResDto {
    bgImage: string | undefined;
    bgFrame: string | undefined;
    logo: string | undefined;
    navBar: string | undefined;
    deviceSelect: string | undefined;
    deviceUnSelect: string | undefined;
    navBotBar: string | undefined;
    noImage: string | undefined;
    mainColor: string | undefined;
    loginButton: string | undefined;
    confirmButton: string | undefined;
    groupUnSelect: string | undefined;
    groupSelect: string | undefined;
    topbarBg: string | undefined;
    searchSubmit: string | undefined;
    searchButton: string | undefined;
    filterSelect: string | undefined;
    filterUnSelect: string | undefined;
    clearButton: string | undefined;
    navScanIcon: string | undefined;
    wqcodeScannerLine: string | undefined;
    changeOuIcon: string | undefined;
    exitIcon: string | undefined;
    deviceIcon: string | undefined;
    defaultProfilePic: string | undefined;
    publishToDeviceButton: string | undefined;
    publishToDeviceIcon: string | undefined;
    qrcodeImage: string | undefined;
}

export class ExternalSkuDto implements IExternalSkuDto {
    id!: number;
    sku_id!: string | undefined;
    productId!: number;
    title!: string | undefined;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    categoryIds!: number[] | undefined;
    keywords!: string | undefined;
    tagIds!: number[] | undefined;
    quantity!: number;
    price!: number;
    price2!: number;
    prom_Price!: number;
    ageScope!: string | undefined;
    gender!: string | undefined;
    barcode!: string | undefined;
    salesVolume!: number;
    orderNumber!: number;
    starLevel!: number;
    isRealSku!: boolean;
    description!: string | undefined;
    auditStatus!: AuditStatus;
    rfideCount!: number;

    constructor(data?: IExternalSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.productId = _data["productId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.prom_Price = _data["prom_Price"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.starLevel = _data["starLevel"];
            this.isRealSku = _data["isRealSku"];
            this.description = _data["description"];
            this.auditStatus = _data["auditStatus"];
            this.rfideCount = _data["rfideCount"];
        }
    }

    static fromJS(data: any): ExternalSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["productId"] = this.productId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["prom_Price"] = this.prom_Price;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["starLevel"] = this.starLevel;
        data["isRealSku"] = this.isRealSku;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        data["rfideCount"] = this.rfideCount;
        return data; 
    }
}

export interface IExternalSkuDto {
    id: number;
    sku_id: string | undefined;
    productId: number;
    title: string | undefined;
    subTitle: string | undefined;
    picUrl: string | undefined;
    categoryIds: number[] | undefined;
    keywords: string | undefined;
    tagIds: number[] | undefined;
    quantity: number;
    price: number;
    price2: number;
    prom_Price: number;
    ageScope: string | undefined;
    gender: string | undefined;
    barcode: string | undefined;
    salesVolume: number;
    orderNumber: number;
    starLevel: number;
    isRealSku: boolean;
    description: string | undefined;
    auditStatus: AuditStatus;
    rfideCount: number;
}

export class PagedResultDtoOfExternalSkuDto implements IPagedResultDtoOfExternalSkuDto {
    totalCount!: number;
    items!: ExternalSkuDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalSkuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalSkuDto {
    totalCount: number;
    items: ExternalSkuDto[] | undefined;
}

export class ExternalResourceDto implements IExternalResourceDto {
    id!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    fromType!: string | undefined;
    content!: string | undefined;
    usage!: string | undefined;

    constructor(data?: IExternalResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.fromType = _data["fromType"];
            this.content = _data["content"];
            this.usage = _data["usage"];
        }
    }

    static fromJS(data: any): ExternalResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["fromType"] = this.fromType;
        data["content"] = this.content;
        data["usage"] = this.usage;
        return data; 
    }
}

export interface IExternalResourceDto {
    id: number;
    name: string | undefined;
    fileUrl: string | undefined;
    fromType: string | undefined;
    content: string | undefined;
    usage: string | undefined;
}

export class ExternalOnlineInfoDto implements IExternalOnlineInfoDto {
    thingId!: number;
    onlineStoreName!: string | undefined;
    qrcode!: string | undefined;

    constructor(data?: IExternalOnlineInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): ExternalOnlineInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalOnlineInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IExternalOnlineInfoDto {
    thingId: number;
    onlineStoreName: string | undefined;
    qrcode: string | undefined;
}

export class ExternalProductDto_ExternalSKuDto implements IExternalProductDto_ExternalSKuDto {
    id!: number;
    sku_id!: string | undefined;
    rfidCode!: string | undefined;
    barcode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    price!: number;
    price2!: number;
    promPrice!: number;
    quantity!: number;
    tagIds!: number[] | undefined;
    picUrl!: string | undefined;
    propsName!: string | undefined;
    onlineInfos!: ExternalOnlineInfoDto[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    orderNumber!: number;
    salesVolume!: number;
    starLevel!: number;
    likeCount!: number;
    description!: string | undefined;
    auditStatus!: AuditStatus;

    constructor(data?: IExternalProductDto_ExternalSKuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.rfidCode = _data["rfidCode"];
            this.barcode = _data["barcode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.picUrl = _data["picUrl"];
            this.propsName = _data["propsName"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(ExternalOnlineInfoDto.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.orderNumber = _data["orderNumber"];
            this.salesVolume = _data["salesVolume"];
            this.starLevel = _data["starLevel"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.auditStatus = _data["auditStatus"];
        }
    }

    static fromJS(data: any): ExternalProductDto_ExternalSKuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProductDto_ExternalSKuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["rfidCode"] = this.rfidCode;
        data["barcode"] = this.barcode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["picUrl"] = this.picUrl;
        data["propsName"] = this.propsName;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["orderNumber"] = this.orderNumber;
        data["salesVolume"] = this.salesVolume;
        data["starLevel"] = this.starLevel;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        return data; 
    }
}

export interface IExternalProductDto_ExternalSKuDto {
    id: number;
    sku_id: string | undefined;
    rfidCode: string | undefined;
    barcode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    price: number;
    price2: number;
    promPrice: number;
    quantity: number;
    tagIds: number[] | undefined;
    picUrl: string | undefined;
    propsName: string | undefined;
    onlineInfos: ExternalOnlineInfoDto[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    orderNumber: number;
    salesVolume: number;
    starLevel: number;
    likeCount: number;
    description: string | undefined;
    auditStatus: AuditStatus;
}

export class ExternalProductDecideImageDto implements IExternalProductDecideImageDto {
    propertyName!: string | undefined;
    imageUrl!: string | undefined;

    constructor(data?: IExternalProductDecideImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): ExternalProductDecideImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProductDecideImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IExternalProductDecideImageDto {
    propertyName: string | undefined;
    imageUrl: string | undefined;
}

export class ExternalProductDto implements IExternalProductDto {
    id!: number;
    itemId!: string | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    itemImagesOrVideos!: ExternalResourceDto[] | undefined;
    categoryIds!: number[] | undefined;
    keywords!: string | undefined;
    tagIds!: number[] | undefined;
    num!: number;
    price!: number;
    price2!: number;
    promPrice!: number;
    ageScope!: string | undefined;
    gender!: string | undefined;
    onlineInfos!: ExternalOnlineInfoDto[] | undefined;
    barcode!: string | undefined;
    salesVolume!: number;
    likeCount!: number;
    skus!: ExternalProductDto_ExternalSKuDto[] | undefined;
    propImgs!: ExternalProductDecideImageDto[] | undefined;
    description!: string | undefined;
    orderNumber!: number;
    starLevel!: number | undefined;

    constructor(data?: IExternalProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(ExternalResourceDto.fromJS(item));
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.num = _data["num"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(ExternalOnlineInfoDto.fromJS(item));
            }
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.likeCount = _data["likeCount"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(ExternalProductDto_ExternalSKuDto.fromJS(item));
            }
            if (Array.isArray(_data["propImgs"])) {
                this.propImgs = [] as any;
                for (let item of _data["propImgs"])
                    this.propImgs!.push(ExternalProductDecideImageDto.fromJS(item));
            }
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.starLevel = _data["starLevel"];
        }
    }

    static fromJS(data: any): ExternalProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["num"] = this.num;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["likeCount"] = this.likeCount;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.propImgs)) {
            data["propImgs"] = [];
            for (let item of this.propImgs)
                data["propImgs"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["starLevel"] = this.starLevel;
        return data; 
    }
}

export interface IExternalProductDto {
    id: number;
    itemId: string | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    subTitle: string | undefined;
    picUrl: string | undefined;
    itemImagesOrVideos: ExternalResourceDto[] | undefined;
    categoryIds: number[] | undefined;
    keywords: string | undefined;
    tagIds: number[] | undefined;
    num: number;
    price: number;
    price2: number;
    promPrice: number;
    ageScope: string | undefined;
    gender: string | undefined;
    onlineInfos: ExternalOnlineInfoDto[] | undefined;
    barcode: string | undefined;
    salesVolume: number;
    likeCount: number;
    skus: ExternalProductDto_ExternalSKuDto[] | undefined;
    propImgs: ExternalProductDecideImageDto[] | undefined;
    description: string | undefined;
    orderNumber: number;
    starLevel: number | undefined;
}

export class ExternalProductCategoryDto implements IExternalProductCategoryDto {
    id!: number;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IExternalProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): ExternalProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IExternalProductCategoryDto {
    id: number;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class PagedResultDtoOfExternalProductCategoryDto implements IPagedResultDtoOfExternalProductCategoryDto {
    totalCount!: number;
    items!: ExternalProductCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalProductCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalProductCategoryDto {
    totalCount: number;
    items: ExternalProductCategoryDto[] | undefined;
}

export class ExternalDeviceDto implements IExternalDeviceDto {
    id!: number;
    name!: string | undefined;
    mac!: string | undefined;
    deviceTypeName!: string | undefined;
    address!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    os!: string | undefined;
    shutdownTime!: DateTime | undefined;
    subKey!: string | undefined;

    constructor(data?: IExternalDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): ExternalDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface IExternalDeviceDto {
    id: number;
    name: string | undefined;
    mac: string | undefined;
    deviceTypeName: string | undefined;
    address: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    os: string | undefined;
    shutdownTime: DateTime | undefined;
    subKey: string | undefined;
}

export class PagedResultDtoOfExternalDeviceDto implements IPagedResultDtoOfExternalDeviceDto {
    totalCount!: number;
    items!: ExternalDeviceDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalDeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalDeviceDto {
    totalCount: number;
    items: ExternalDeviceDto[] | undefined;
}

export class ExternalAccessDto implements IExternalAccessDto {
    id!: number;
    taobao_user_id!: string | undefined;
    taobao_user_nick!: string | undefined;
    access_token!: string | undefined;
    expires_in!: DateTime;
    lastModificationTime!: DateTime | undefined;
    creationTime!: DateTime;
    userName!: string | undefined;
    password!: string | undefined;
    url!: string | undefined;
    fromType!: string | undefined;
    openPlatfromName!: string | undefined;

    constructor(data?: IExternalAccessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taobao_user_id = _data["taobao_user_id"];
            this.taobao_user_nick = _data["taobao_user_nick"];
            this.access_token = _data["access_token"];
            this.expires_in = _data["expires_in"] ? DateTime.fromISO(_data["expires_in"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.url = _data["url"];
            this.fromType = _data["fromType"];
            this.openPlatfromName = _data["openPlatfromName"];
        }
    }

    static fromJS(data: any): ExternalAccessDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAccessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taobao_user_id"] = this.taobao_user_id;
        data["taobao_user_nick"] = this.taobao_user_nick;
        data["access_token"] = this.access_token;
        data["expires_in"] = this.expires_in ? this.expires_in.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["url"] = this.url;
        data["fromType"] = this.fromType;
        data["openPlatfromName"] = this.openPlatfromName;
        return data; 
    }
}

export interface IExternalAccessDto {
    id: number;
    taobao_user_id: string | undefined;
    taobao_user_nick: string | undefined;
    access_token: string | undefined;
    expires_in: DateTime;
    lastModificationTime: DateTime | undefined;
    creationTime: DateTime;
    userName: string | undefined;
    password: string | undefined;
    url: string | undefined;
    fromType: string | undefined;
    openPlatfromName: string | undefined;
}

export class PagedResultDtoOfExternalAccessDto implements IPagedResultDtoOfExternalAccessDto {
    totalCount!: number;
    items!: ExternalAccessDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalAccessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalAccessDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalAccessDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalAccessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalAccessDto {
    totalCount: number;
    items: ExternalAccessDto[] | undefined;
}

export class CreateExternalAccessInput implements ICreateExternalAccessInput {
    taobao_user_nick!: string | undefined;
    access_token!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    url!: string | undefined;
    fromType!: string | undefined;
    taobao_user_id!: string | undefined;
    taobaoCredentialUrl!: string | undefined;

    constructor(data?: ICreateExternalAccessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taobao_user_nick = _data["taobao_user_nick"];
            this.access_token = _data["access_token"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.url = _data["url"];
            this.fromType = _data["fromType"];
            this.taobao_user_id = _data["taobao_user_id"];
            this.taobaoCredentialUrl = _data["taobaoCredentialUrl"];
        }
    }

    static fromJS(data: any): CreateExternalAccessInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExternalAccessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taobao_user_nick"] = this.taobao_user_nick;
        data["access_token"] = this.access_token;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["url"] = this.url;
        data["fromType"] = this.fromType;
        data["taobao_user_id"] = this.taobao_user_id;
        data["taobaoCredentialUrl"] = this.taobaoCredentialUrl;
        return data; 
    }
}

export interface ICreateExternalAccessInput {
    taobao_user_nick: string | undefined;
    access_token: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    url: string | undefined;
    fromType: string | undefined;
    taobao_user_id: string | undefined;
    taobaoCredentialUrl: string | undefined;
}

export class UpdateExternalAccessInput implements IUpdateExternalAccessInput {
    id!: number;
    taobao_user_nick!: string | undefined;
    access_token!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    url!: string | undefined;
    fromType!: string | undefined;
    taobao_user_id!: string | undefined;
    taobaoCredentialUrl!: string | undefined;

    constructor(data?: IUpdateExternalAccessInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taobao_user_nick = _data["taobao_user_nick"];
            this.access_token = _data["access_token"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.url = _data["url"];
            this.fromType = _data["fromType"];
            this.taobao_user_id = _data["taobao_user_id"];
            this.taobaoCredentialUrl = _data["taobaoCredentialUrl"];
        }
    }

    static fromJS(data: any): UpdateExternalAccessInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalAccessInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taobao_user_nick"] = this.taobao_user_nick;
        data["access_token"] = this.access_token;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["url"] = this.url;
        data["fromType"] = this.fromType;
        data["taobao_user_id"] = this.taobao_user_id;
        data["taobaoCredentialUrl"] = this.taobaoCredentialUrl;
        return data; 
    }
}

export interface IUpdateExternalAccessInput {
    id: number;
    taobao_user_nick: string | undefined;
    access_token: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    url: string | undefined;
    fromType: string | undefined;
    taobao_user_id: string | undefined;
    taobaoCredentialUrl: string | undefined;
}

export class AddOrUpdateAccessTokenInput implements IAddOrUpdateAccessTokenInput {
    id!: number | undefined;
    access_token!: string | undefined;
    fromType!: string | undefined;
    refresh_token!: string | undefined;
    token_type!: string | undefined;
    taobaoOpenPlatformId!: number | undefined;
    tenantId!: number;
    business_id!: string | undefined;
    public_account_id!: string | undefined;
    onlineStoreUrl!: string | undefined;
    name!: string | undefined;
    avatarUrl!: string | undefined;

    constructor(data?: IAddOrUpdateAccessTokenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.access_token = _data["access_token"];
            this.fromType = _data["fromType"];
            this.refresh_token = _data["refresh_token"];
            this.token_type = _data["token_type"];
            this.taobaoOpenPlatformId = _data["taobaoOpenPlatformId"];
            this.tenantId = _data["tenantId"];
            this.business_id = _data["business_id"];
            this.public_account_id = _data["public_account_id"];
            this.onlineStoreUrl = _data["onlineStoreUrl"];
            this.name = _data["name"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): AddOrUpdateAccessTokenInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateAccessTokenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["access_token"] = this.access_token;
        data["fromType"] = this.fromType;
        data["refresh_token"] = this.refresh_token;
        data["token_type"] = this.token_type;
        data["taobaoOpenPlatformId"] = this.taobaoOpenPlatformId;
        data["tenantId"] = this.tenantId;
        data["business_id"] = this.business_id;
        data["public_account_id"] = this.public_account_id;
        data["onlineStoreUrl"] = this.onlineStoreUrl;
        data["name"] = this.name;
        data["avatarUrl"] = this.avatarUrl;
        return data; 
    }
}

export interface IAddOrUpdateAccessTokenInput {
    id: number | undefined;
    access_token: string | undefined;
    fromType: string | undefined;
    refresh_token: string | undefined;
    token_type: string | undefined;
    taobaoOpenPlatformId: number | undefined;
    tenantId: number;
    business_id: string | undefined;
    public_account_id: string | undefined;
    onlineStoreUrl: string | undefined;
    name: string | undefined;
    avatarUrl: string | undefined;
}

export class ExternalAddOrUpdateCoupon implements IExternalAddOrUpdateCoupon {
    code!: string;
    title!: string;
    pictures!: string;
    start_Time!: DateTime;
    end_Time!: DateTime;
    url!: string;
    auditStatus!: number;
    description!: string | undefined;
    amount!: number;

    constructor(data?: IExternalAddOrUpdateCoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.title = _data["title"];
            this.pictures = _data["pictures"];
            this.start_Time = _data["start_Time"] ? DateTime.fromISO(_data["start_Time"].toString()) : <any>undefined;
            this.end_Time = _data["end_Time"] ? DateTime.fromISO(_data["end_Time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ExternalAddOrUpdateCoupon {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAddOrUpdateCoupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["title"] = this.title;
        data["pictures"] = this.pictures;
        data["start_Time"] = this.start_Time ? this.start_Time.toString() : <any>undefined;
        data["end_Time"] = this.end_Time ? this.end_Time.toString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IExternalAddOrUpdateCoupon {
    code: string;
    title: string;
    pictures: string;
    start_Time: DateTime;
    end_Time: DateTime;
    url: string;
    auditStatus: number;
    description: string | undefined;
    amount: number;
}

export class ExternalDeleteCouponsInput implements IExternalDeleteCouponsInput {
    codes!: string[] | undefined;

    constructor(data?: IExternalDeleteCouponsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalDeleteCouponsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDeleteCouponsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        return data; 
    }
}

export interface IExternalDeleteCouponsInput {
    codes: string[] | undefined;
}

export class ExternalPositionDto implements IExternalPositionDto {
    state!: string | undefined;
    area!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    county!: string | undefined;
    location!: string | undefined;
    zipCode!: string | undefined;
    longitude!: number | undefined;
    latitude!: number | undefined;

    constructor(data?: IExternalPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.area = _data["area"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.location = _data["location"];
            this.zipCode = _data["zipCode"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): ExternalPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["area"] = this.area;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["location"] = this.location;
        data["zipCode"] = this.zipCode;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data; 
    }
}

export interface IExternalPositionDto {
    state: string | undefined;
    area: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    location: string | undefined;
    zipCode: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
}

export class ExternalStoreDto implements IExternalStoreDto {
    id!: number;
    storeNo!: string | undefined;
    name!: string | undefined;
    logoUrl!: string | undefined;
    position!: ExternalPositionDto;
    email!: string | undefined;
    webUrl!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    description!: string | undefined;

    constructor(data?: IExternalStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeNo = _data["storeNo"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.position = _data["position"] ? ExternalPositionDto.fromJS(_data["position"]) : <any>undefined;
            this.email = _data["email"];
            this.webUrl = _data["webUrl"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ExternalStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeNo"] = this.storeNo;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["webUrl"] = this.webUrl;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }
}

export interface IExternalStoreDto {
    id: number;
    storeNo: string | undefined;
    name: string | undefined;
    logoUrl: string | undefined;
    position: ExternalPositionDto;
    email: string | undefined;
    webUrl: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfExternalStoreDto implements IPagedResultDtoOfExternalStoreDto {
    totalCount!: number;
    items!: ExternalStoreDto[] | undefined;

    constructor(data?: IPagedResultDtoOfExternalStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalStoreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfExternalStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfExternalStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfExternalStoreDto {
    totalCount: number;
    items: ExternalStoreDto[] | undefined;
}

export class ExternalAddOrUpdateStoreModel implements IExternalAddOrUpdateStoreModel {
    storeNo!: string;
    name!: string;
    province!: string | undefined;
    city!: string | undefined;
    area!: string | undefined;
    address!: string | undefined;
    webAddressUrl!: string | undefined;
    openingTime!: DateTime;
    closedTime!: DateTime;
    qrCodeExtraInfo!: string | undefined;
    description!: string | undefined;

    constructor(data?: IExternalAddOrUpdateStoreModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeNo = _data["storeNo"];
            this.name = _data["name"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.area = _data["area"];
            this.address = _data["address"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ExternalAddOrUpdateStoreModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAddOrUpdateStoreModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeNo"] = this.storeNo;
        data["name"] = this.name;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["address"] = this.address;
        data["webAddressUrl"] = this.webAddressUrl;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["description"] = this.description;
        return data; 
    }
}

export interface IExternalAddOrUpdateStoreModel {
    storeNo: string;
    name: string;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    address: string | undefined;
    webAddressUrl: string | undefined;
    openingTime: DateTime;
    closedTime: DateTime;
    qrCodeExtraInfo: string | undefined;
    description: string | undefined;
}

export class ItemIdsInput implements IItemIdsInput {
    tenantId!: number;
    fromType!: string | undefined;
    itemIds!: string[] | undefined;

    constructor(data?: IItemIdsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ItemIdsInput {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        return data; 
    }
}

export interface IItemIdsInput {
    tenantId: number;
    fromType: string | undefined;
    itemIds: string[] | undefined;
}

export class ItemIdsDto implements IItemIdsDto {
    itemIds!: string[] | undefined;

    constructor(data?: IItemIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ItemIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        return data; 
    }
}

export interface IItemIdsDto {
    itemIds: string[] | undefined;
}

export class AddOrUpdateOnlineInfosInput implements IAddOrUpdateOnlineInfosInput {
    onlineStoreName!: string | undefined;
    onlineType!: number | undefined;
    qrcode!: string | undefined;
    onlinePrice!: number | undefined;
    onlineQuantity!: number | undefined;
    onlineThingId!: string | undefined;

    constructor(data?: IAddOrUpdateOnlineInfosInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineType = _data["onlineType"];
            this.qrcode = _data["qrcode"];
            this.onlinePrice = _data["onlinePrice"];
            this.onlineQuantity = _data["onlineQuantity"];
            this.onlineThingId = _data["onlineThingId"];
        }
    }

    static fromJS(data: any): AddOrUpdateOnlineInfosInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOnlineInfosInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineType"] = this.onlineType;
        data["qrcode"] = this.qrcode;
        data["onlinePrice"] = this.onlinePrice;
        data["onlineQuantity"] = this.onlineQuantity;
        data["onlineThingId"] = this.onlineThingId;
        return data; 
    }
}

export interface IAddOrUpdateOnlineInfosInput {
    onlineStoreName: string | undefined;
    onlineType: number | undefined;
    qrcode: string | undefined;
    onlinePrice: number | undefined;
    onlineQuantity: number | undefined;
    onlineThingId: string | undefined;
}

export class ResViewModel implements IResViewModel {
    name!: string | undefined;
    resUrl!: string | undefined;
    usage!: string | undefined;
    orderNumber!: number;

    constructor(data?: IResViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.resUrl = _data["resUrl"];
            this.usage = _data["usage"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): ResViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["resUrl"] = this.resUrl;
        data["usage"] = this.usage;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IResViewModel {
    name: string | undefined;
    resUrl: string | undefined;
    usage: string | undefined;
    orderNumber: number;
}

export class SkuPropertyInput implements ISkuPropertyInput {
    name!: string | undefined;
    nameIcon!: string | undefined;
    value!: string | undefined;
    valueIcon!: string | undefined;
    type!: number;

    constructor(data?: ISkuPropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.nameIcon = _data["nameIcon"];
            this.value = _data["value"];
            this.valueIcon = _data["valueIcon"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SkuPropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuPropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["nameIcon"] = this.nameIcon;
        data["value"] = this.value;
        data["valueIcon"] = this.valueIcon;
        data["type"] = this.type;
        return data; 
    }
}

export interface ISkuPropertyInput {
    name: string | undefined;
    nameIcon: string | undefined;
    value: string | undefined;
    valueIcon: string | undefined;
    type: number;
}

export class AddOrUpdateSkuInputV2 implements IAddOrUpdateSkuInputV2 {
    skuId!: string;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    price!: number;
    price2!: number | undefined;
    suitablePeople!: string | undefined;
    promPrice!: number | undefined;
    salesVolume!: number;
    quantity!: number;
    properties!: SkuPropertyInput[] | undefined;
    tags!: string | undefined;
    picUrl!: string | undefined;
    platformPicUrl!: string | undefined;
    onlineInfos!: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList!: ResViewModel[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    colorId!: string | undefined;
    colorName!: string | undefined;
    fromType!: string | undefined;
    is3D!: boolean;
    keywords!: string | undefined;
    material3DUrl!: string | undefined;
    starLevel!: number | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IAddOrUpdateSkuInputV2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.suitablePeople = _data["suitablePeople"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(SkuPropertyInput.fromJS(item));
            }
            this.tags = _data["tags"];
            this.picUrl = _data["picUrl"];
            this.platformPicUrl = _data["platformPicUrl"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(AddOrUpdateOnlineInfosInput.fromJS(item));
            }
            if (Array.isArray(_data["resUrlList"])) {
                this.resUrlList = [] as any;
                for (let item of _data["resUrlList"])
                    this.resUrlList!.push(ResViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.colorId = _data["colorId"];
            this.colorName = _data["colorName"];
            this.fromType = _data["fromType"];
            this.is3D = _data["is3D"];
            this.keywords = _data["keywords"];
            this.material3DUrl = _data["material3DUrl"];
            this.starLevel = _data["starLevel"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddOrUpdateSkuInputV2 {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSkuInputV2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["suitablePeople"] = this.suitablePeople;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["tags"] = this.tags;
        data["picUrl"] = this.picUrl;
        data["platformPicUrl"] = this.platformPicUrl;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.resUrlList)) {
            data["resUrlList"] = [];
            for (let item of this.resUrlList)
                data["resUrlList"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["colorId"] = this.colorId;
        data["colorName"] = this.colorName;
        data["fromType"] = this.fromType;
        data["is3D"] = this.is3D;
        data["keywords"] = this.keywords;
        data["material3DUrl"] = this.material3DUrl;
        data["starLevel"] = this.starLevel;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddOrUpdateSkuInputV2 {
    skuId: string;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    price: number;
    price2: number | undefined;
    suitablePeople: string | undefined;
    promPrice: number | undefined;
    salesVolume: number;
    quantity: number;
    properties: SkuPropertyInput[] | undefined;
    tags: string | undefined;
    picUrl: string | undefined;
    platformPicUrl: string | undefined;
    onlineInfos: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList: ResViewModel[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    colorId: string | undefined;
    colorName: string | undefined;
    fromType: string | undefined;
    is3D: boolean;
    keywords: string | undefined;
    material3DUrl: string | undefined;
    starLevel: number | undefined;
    pointRule: ProductPointRule;
}

export class CreateProductCommentInput implements ICreateProductCommentInput {
    userName!: string | undefined;
    avatorUrl!: string | undefined;
    content!: string | undefined;
    productId!: number;
    commentDateTime!: DateTime | undefined;
    orderNumber!: number;

    constructor(data?: ICreateProductCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.productId = _data["productId"];
            this.commentDateTime = _data["commentDateTime"] ? DateTime.fromISO(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): CreateProductCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["productId"] = this.productId;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface ICreateProductCommentInput {
    userName: string | undefined;
    avatorUrl: string | undefined;
    content: string | undefined;
    productId: number;
    commentDateTime: DateTime | undefined;
    orderNumber: number;
}

export enum SyncScopeEnum {
    Full = 0,
    LocalBasicAdd = 1,
    LocalBasicUpdate = 2,
}

export class AddOrUpdateProductInputV2 implements IAddOrUpdateProductInputV2 {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    itemId!: string;
    itemSize!: string | undefined;
    itemWeight!: number;
    largeScreenImageUrl!: string | undefined;
    platformPicUrl!: string | undefined;
    material3DUrl!: string | undefined;
    listTime!: DateTime | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    onlineInfos!: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList!: ResViewModel[] | undefined;
    categorys!: string | undefined;
    categoryCodes!: string | undefined;
    keywords!: string | undefined;
    tags!: string | undefined;
    quantity!: number;
    fromType!: string | undefined;
    price!: number;
    price2!: number | undefined;
    promPrice!: number;
    salesVolume!: number;
    orderNumber!: number;
    barcode!: string | undefined;
    sellerId!: string | undefined;
    videoUrl!: string | undefined;
    auditStatus!: number;
    skuList!: AddOrUpdateSkuInputV2[] | undefined;
    comments!: CreateProductCommentInput[] | undefined;
    detailUrl!: string | undefined;
    features!: string | undefined;
    hasDiscount!: boolean;
    hasShowcase!: boolean;
    is3D!: boolean;
    isXinpin!: boolean;
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    brandCode!: string | undefined;
    syncType!: SyncScopeEnum;
    syncFields!: string | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IAddOrUpdateProductInputV2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.itemId = _data["itemId"];
            this.itemSize = _data["itemSize"];
            this.itemWeight = _data["itemWeight"];
            this.largeScreenImageUrl = _data["largeScreenImageUrl"];
            this.platformPicUrl = _data["platformPicUrl"];
            this.material3DUrl = _data["material3DUrl"];
            this.listTime = _data["listTime"] ? DateTime.fromISO(_data["listTime"].toString()) : <any>undefined;
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(AddOrUpdateOnlineInfosInput.fromJS(item));
            }
            if (Array.isArray(_data["resUrlList"])) {
                this.resUrlList = [] as any;
                for (let item of _data["resUrlList"])
                    this.resUrlList!.push(ResViewModel.fromJS(item));
            }
            this.categorys = _data["categorys"];
            this.categoryCodes = _data["categoryCodes"];
            this.keywords = _data["keywords"];
            this.tags = _data["tags"];
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.sellerId = _data["sellerId"];
            this.videoUrl = _data["videoUrl"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["skuList"])) {
                this.skuList = [] as any;
                for (let item of _data["skuList"])
                    this.skuList!.push(AddOrUpdateSkuInputV2.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CreateProductCommentInput.fromJS(item));
            }
            this.detailUrl = _data["detailUrl"];
            this.features = _data["features"];
            this.hasDiscount = _data["hasDiscount"];
            this.hasShowcase = _data["hasShowcase"];
            this.is3D = _data["is3D"];
            this.isXinpin = _data["isXinpin"];
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.brandCode = _data["brandCode"];
            this.syncType = _data["syncType"];
            this.syncFields = _data["syncFields"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddOrUpdateProductInputV2 {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductInputV2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["itemId"] = this.itemId;
        data["itemSize"] = this.itemSize;
        data["itemWeight"] = this.itemWeight;
        data["largeScreenImageUrl"] = this.largeScreenImageUrl;
        data["platformPicUrl"] = this.platformPicUrl;
        data["material3DUrl"] = this.material3DUrl;
        data["listTime"] = this.listTime ? this.listTime.toString() : <any>undefined;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.resUrlList)) {
            data["resUrlList"] = [];
            for (let item of this.resUrlList)
                data["resUrlList"].push(item.toJSON());
        }
        data["categorys"] = this.categorys;
        data["categoryCodes"] = this.categoryCodes;
        data["keywords"] = this.keywords;
        data["tags"] = this.tags;
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["sellerId"] = this.sellerId;
        data["videoUrl"] = this.videoUrl;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.skuList)) {
            data["skuList"] = [];
            for (let item of this.skuList)
                data["skuList"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["detailUrl"] = this.detailUrl;
        data["features"] = this.features;
        data["hasDiscount"] = this.hasDiscount;
        data["hasShowcase"] = this.hasShowcase;
        data["is3D"] = this.is3D;
        data["isXinpin"] = this.isXinpin;
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["brandCode"] = this.brandCode;
        data["syncType"] = this.syncType;
        data["syncFields"] = this.syncFields;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddOrUpdateProductInputV2 {
    tenantId: number;
    organizationUnitId: number | undefined;
    itemId: string;
    itemSize: string | undefined;
    itemWeight: number;
    largeScreenImageUrl: string | undefined;
    platformPicUrl: string | undefined;
    material3DUrl: string | undefined;
    listTime: DateTime | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string;
    subTitle: string | undefined;
    picUrl: string | undefined;
    onlineInfos: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList: ResViewModel[] | undefined;
    categorys: string | undefined;
    categoryCodes: string | undefined;
    keywords: string | undefined;
    tags: string | undefined;
    quantity: number;
    fromType: string | undefined;
    price: number;
    price2: number | undefined;
    promPrice: number;
    salesVolume: number;
    orderNumber: number;
    barcode: string | undefined;
    sellerId: string | undefined;
    videoUrl: string | undefined;
    auditStatus: number;
    skuList: AddOrUpdateSkuInputV2[] | undefined;
    comments: CreateProductCommentInput[] | undefined;
    detailUrl: string | undefined;
    features: string | undefined;
    hasDiscount: boolean;
    hasShowcase: boolean;
    is3D: boolean;
    isXinpin: boolean;
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    brandCode: string | undefined;
    syncType: SyncScopeEnum;
    syncFields: string | undefined;
    pointRule: ProductPointRule;
}

export class AddOrUpdateSkuInput implements IAddOrUpdateSkuInput {
    skuId!: string;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    price!: number | undefined;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number | undefined;
    quantity!: number | undefined;
    properties!: SkuPropertyInput[] | undefined;
    tags!: string | undefined;
    picUrl!: string | undefined;
    onlineInfos!: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList!: ResViewModel[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    starLevel!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IAddOrUpdateSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(SkuPropertyInput.fromJS(item));
            }
            this.tags = _data["tags"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(AddOrUpdateOnlineInfosInput.fromJS(item));
            }
            if (Array.isArray(_data["resUrlList"])) {
                this.resUrlList = [] as any;
                for (let item of _data["resUrlList"])
                    this.resUrlList!.push(ResViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddOrUpdateSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["tags"] = this.tags;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.resUrlList)) {
            data["resUrlList"] = [];
            for (let item of this.resUrlList)
                data["resUrlList"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddOrUpdateSkuInput {
    skuId: string;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    price: number | undefined;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number | undefined;
    quantity: number | undefined;
    properties: SkuPropertyInput[] | undefined;
    tags: string | undefined;
    picUrl: string | undefined;
    onlineInfos: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList: ResViewModel[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    starLevel: number | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRule: ProductPointRule;
}

export class AddOrUpdateProductInput implements IAddOrUpdateProductInput {
    itemId!: string;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    onlineInfos!: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList!: ResViewModel[] | undefined;
    categorys!: string | undefined;
    keywords!: string | undefined;
    tags!: string | undefined;
    quantity!: number | undefined;
    fromType!: string | undefined;
    price!: number | undefined;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    auditStatus!: number;
    skuList!: AddOrUpdateSkuInput[] | undefined;
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    brandCode!: string | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IAddOrUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["onlineInfos"])) {
                this.onlineInfos = [] as any;
                for (let item of _data["onlineInfos"])
                    this.onlineInfos!.push(AddOrUpdateOnlineInfosInput.fromJS(item));
            }
            if (Array.isArray(_data["resUrlList"])) {
                this.resUrlList = [] as any;
                for (let item of _data["resUrlList"])
                    this.resUrlList!.push(ResViewModel.fromJS(item));
            }
            this.categorys = _data["categorys"];
            this.keywords = _data["keywords"];
            this.tags = _data["tags"];
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["skuList"])) {
                this.skuList = [] as any;
                for (let item of _data["skuList"])
                    this.skuList!.push(AddOrUpdateSkuInput.fromJS(item));
            }
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.brandCode = _data["brandCode"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddOrUpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.onlineInfos)) {
            data["onlineInfos"] = [];
            for (let item of this.onlineInfos)
                data["onlineInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.resUrlList)) {
            data["resUrlList"] = [];
            for (let item of this.resUrlList)
                data["resUrlList"].push(item.toJSON());
        }
        data["categorys"] = this.categorys;
        data["keywords"] = this.keywords;
        data["tags"] = this.tags;
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.skuList)) {
            data["skuList"] = [];
            for (let item of this.skuList)
                data["skuList"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["brandCode"] = this.brandCode;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAddOrUpdateProductInput {
    itemId: string;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    subTitle: string | undefined;
    picUrl: string | undefined;
    onlineInfos: AddOrUpdateOnlineInfosInput[] | undefined;
    resUrlList: ResViewModel[] | undefined;
    categorys: string | undefined;
    keywords: string | undefined;
    tags: string | undefined;
    quantity: number | undefined;
    fromType: string | undefined;
    price: number | undefined;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number | undefined;
    orderNumber: number;
    barcode: string | undefined;
    auditStatus: number;
    skuList: AddOrUpdateSkuInput[] | undefined;
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    brandCode: string | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRule: ProductPointRule;
}

export class StoreQuantity implements IStoreQuantity {
    storeId!: string | undefined;
    quentity!: number;

    constructor(data?: IStoreQuantity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.quentity = _data["quentity"];
        }
    }

    static fromJS(data: any): StoreQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new StoreQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["quentity"] = this.quentity;
        return data; 
    }
}

export interface IStoreQuantity {
    storeId: string | undefined;
    quentity: number;
}

export class StoreStorage implements IStoreStorage {
    thingId!: string | undefined;
    barcode!: string | undefined;
    type!: number;
    storeQuantities!: StoreQuantity[] | undefined;

    constructor(data?: IStoreStorage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.barcode = _data["barcode"];
            this.type = _data["type"];
            if (Array.isArray(_data["storeQuantities"])) {
                this.storeQuantities = [] as any;
                for (let item of _data["storeQuantities"])
                    this.storeQuantities!.push(StoreQuantity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreStorage {
        data = typeof data === 'object' ? data : {};
        let result = new StoreStorage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["barcode"] = this.barcode;
        data["type"] = this.type;
        if (Array.isArray(this.storeQuantities)) {
            data["storeQuantities"] = [];
            for (let item of this.storeQuantities)
                data["storeQuantities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStoreStorage {
    thingId: string | undefined;
    barcode: string | undefined;
    type: number;
    storeQuantities: StoreQuantity[] | undefined;
}

export class UpdateStoreStorageInput implements IUpdateStoreStorageInput {
    storeStorages!: StoreStorage[] | undefined;

    constructor(data?: IUpdateStoreStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeStorages"])) {
                this.storeStorages = [] as any;
                for (let item of _data["storeStorages"])
                    this.storeStorages!.push(StoreStorage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateStoreStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeStorages)) {
            data["storeStorages"] = [];
            for (let item of this.storeStorages)
                data["storeStorages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateStoreStorageInput {
    storeStorages: StoreStorage[] | undefined;
}

export class AddOrUpdateSkuByItemIdInput implements IAddOrUpdateSkuByItemIdInput {
    itemId!: string | undefined;
    skus!: AddOrUpdateSkuInput[] | undefined;

    constructor(data?: IAddOrUpdateSkuByItemIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(AddOrUpdateSkuInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateSkuByItemIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSkuByItemIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateSkuByItemIdInput {
    itemId: string | undefined;
    skus: AddOrUpdateSkuInput[] | undefined;
}

export class DeleteItemsInput implements IDeleteItemsInput {
    itemIds!: string[] | undefined;

    constructor(data?: IDeleteItemsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteItemsInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteItemsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        return data; 
    }
}

export interface IDeleteItemsInput {
    itemIds: string[] | undefined;
}

export class KeepItemsInput implements IKeepItemsInput {
    itemIds!: string[] | undefined;
    fromType!: string | undefined;
    tenantId!: number;

    constructor(data?: IKeepItemsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
            this.fromType = _data["fromType"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): KeepItemsInput {
        data = typeof data === 'object' ? data : {};
        let result = new KeepItemsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        data["fromType"] = this.fromType;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IKeepItemsInput {
    itemIds: string[] | undefined;
    fromType: string | undefined;
    tenantId: number;
}

export class DeleteSkusInput implements IDeleteSkusInput {
    skuIds!: string[] | undefined;

    constructor(data?: IDeleteSkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteSkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteSkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        return data; 
    }
}

export interface IDeleteSkusInput {
    skuIds: string[] | undefined;
}

export class ExternalUpdateSkuBaseInfoInput implements IExternalUpdateSkuBaseInfoInput {
    skuId!: string;
    price!: number;
    price2!: number;
    promPrice!: number;
    salesVolume!: number;
    quantity!: number;
    tags!: string | undefined;
    picUrl!: string | undefined;
    auditStatus!: number;
    orderNumber!: number;

    constructor(data?: IExternalUpdateSkuBaseInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.tags = _data["tags"];
            this.picUrl = _data["picUrl"];
            this.auditStatus = _data["auditStatus"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): ExternalUpdateSkuBaseInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalUpdateSkuBaseInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["tags"] = this.tags;
        data["picUrl"] = this.picUrl;
        data["auditStatus"] = this.auditStatus;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IExternalUpdateSkuBaseInfoInput {
    skuId: string;
    price: number;
    price2: number;
    promPrice: number;
    salesVolume: number;
    quantity: number;
    tags: string | undefined;
    picUrl: string | undefined;
    auditStatus: number;
    orderNumber: number;
}

export class ExternalUpdateProductBaseInfoInput implements IExternalUpdateProductBaseInfoInput {
    itemId!: string;
    picUrl!: string | undefined;
    tags!: string | undefined;
    quantity!: number;
    price!: number;
    price2!: number;
    promPrice!: number;
    salesVolume!: number;
    orderNumber!: number;
    auditStatus!: number;
    skuList!: ExternalUpdateSkuBaseInfoInput[] | undefined;

    constructor(data?: IExternalUpdateProductBaseInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.picUrl = _data["picUrl"];
            this.tags = _data["tags"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["skuList"])) {
                this.skuList = [] as any;
                for (let item of _data["skuList"])
                    this.skuList!.push(ExternalUpdateSkuBaseInfoInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalUpdateProductBaseInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalUpdateProductBaseInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["picUrl"] = this.picUrl;
        data["tags"] = this.tags;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.skuList)) {
            data["skuList"] = [];
            for (let item of this.skuList)
                data["skuList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalUpdateProductBaseInfoInput {
    itemId: string;
    picUrl: string | undefined;
    tags: string | undefined;
    quantity: number;
    price: number;
    price2: number;
    promPrice: number;
    salesVolume: number;
    orderNumber: number;
    auditStatus: number;
    skuList: ExternalUpdateSkuBaseInfoInput[] | undefined;
}

export class SetSkuOnOrOffModel implements ISetSkuOnOrOffModel {
    skuIds!: string[] | undefined;
    off!: number;

    constructor(data?: ISetSkuOnOrOffModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.off = _data["off"];
        }
    }

    static fromJS(data: any): SetSkuOnOrOffModel {
        data = typeof data === 'object' ? data : {};
        let result = new SetSkuOnOrOffModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["off"] = this.off;
        return data; 
    }
}

export interface ISetSkuOnOrOffModel {
    skuIds: string[] | undefined;
    off: number;
}

export class ExternalSetSkuOnOrOffModel implements IExternalSetSkuOnOrOffModel {
    itemIds!: string[] | undefined;
    off!: number;
    includeSku!: boolean;

    constructor(data?: IExternalSetSkuOnOrOffModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
            this.off = _data["off"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): ExternalSetSkuOnOrOffModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSetSkuOnOrOffModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        data["off"] = this.off;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IExternalSetSkuOnOrOffModel {
    itemIds: string[] | undefined;
    off: number;
    includeSku: boolean;
}

export class ExternalPublishSpuToStoreOrDevices implements IExternalPublishSpuToStoreOrDevices {
    itemIds!: string[] | undefined;
    storeOrDeviceList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IExternalPublishSpuToStoreOrDevices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
            if (Array.isArray(_data["storeOrDeviceList"])) {
                this.storeOrDeviceList = [] as any;
                for (let item of _data["storeOrDeviceList"])
                    this.storeOrDeviceList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): ExternalPublishSpuToStoreOrDevices {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPublishSpuToStoreOrDevices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        if (Array.isArray(this.storeOrDeviceList)) {
            data["storeOrDeviceList"] = [];
            for (let item of this.storeOrDeviceList)
                data["storeOrDeviceList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IExternalPublishSpuToStoreOrDevices {
    itemIds: string[] | undefined;
    storeOrDeviceList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
}

export class UpdateSkuInput implements IUpdateSkuInput {
    id!: number;
    productId!: number;
    sku_id!: string | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    price!: number;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number;
    quantity!: number;
    picUrl!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    tags!: number[] | undefined;
    propertyValueIds!: number[] | undefined;
    starLevel!: number | undefined;
    keywords!: string | undefined;
    pointRule!: ProductPointRule;
    weight!: number | undefined;

    constructor(data?: IUpdateSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.sku_id = _data["sku_id"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["propertyValueIds"])) {
                this.propertyValueIds = [] as any;
                for (let item of _data["propertyValueIds"])
                    this.propertyValueIds!.push(item);
            }
            this.starLevel = _data["starLevel"];
            this.keywords = _data["keywords"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): UpdateSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["sku_id"] = this.sku_id;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.propertyValueIds)) {
            data["propertyValueIds"] = [];
            for (let item of this.propertyValueIds)
                data["propertyValueIds"].push(item);
        }
        data["starLevel"] = this.starLevel;
        data["keywords"] = this.keywords;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface IUpdateSkuInput {
    id: number;
    productId: number;
    sku_id: string | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    price: number;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number;
    quantity: number;
    picUrl: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    tags: number[] | undefined;
    propertyValueIds: number[] | undefined;
    starLevel: number | undefined;
    keywords: string | undefined;
    pointRule: ProductPointRule;
    weight: number | undefined;
}

export class SkuModel implements ISkuModel {
    skuId!: number;
    price!: number | undefined;
    price2!: number | undefined;
    promPrice!: number | undefined;

    constructor(data?: ISkuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
        }
    }

    static fromJS(data: any): SkuModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        return data; 
    }
}

export interface ISkuModel {
    skuId: number;
    price: number | undefined;
    price2: number | undefined;
    promPrice: number | undefined;
}

export class ProductModel implements IProductModel {
    productId!: string | undefined;
    price!: number | undefined;
    price2!: number | undefined;
    promPrice!: number | undefined;
    skus!: SkuModel[] | undefined;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductModel {
    productId: string | undefined;
    price: number | undefined;
    price2: number | undefined;
    promPrice: number | undefined;
    skus: SkuModel[] | undefined;
}

export class ExternalPublishSpuToDevicesOrStoresOrOus implements IExternalPublishSpuToDevicesOrStoresOrOus {
    deviceOrStoreOrOuList!: IdTypeDto[] | undefined;
    items!: ProductModel[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IExternalPublishSpuToDevicesOrStoresOrOus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceOrStoreOrOuList"])) {
                this.deviceOrStoreOrOuList = [] as any;
                for (let item of _data["deviceOrStoreOrOuList"])
                    this.deviceOrStoreOrOuList!.push(IdTypeDto.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductModel.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): ExternalPublishSpuToDevicesOrStoresOrOus {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPublishSpuToDevicesOrStoresOrOus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceOrStoreOrOuList)) {
            data["deviceOrStoreOrOuList"] = [];
            for (let item of this.deviceOrStoreOrOuList)
                data["deviceOrStoreOrOuList"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IExternalPublishSpuToDevicesOrStoresOrOus {
    deviceOrStoreOrOuList: IdTypeDto[] | undefined;
    items: ProductModel[] | undefined;
    action: string | undefined;
    includeSku: boolean;
}

export class ExternalPublishSkuToStoreOrDevices implements IExternalPublishSkuToStoreOrDevices {
    skuIds!: string[] | undefined;
    storeOrDeviceList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IExternalPublishSkuToStoreOrDevices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            if (Array.isArray(_data["storeOrDeviceList"])) {
                this.storeOrDeviceList = [] as any;
                for (let item of _data["storeOrDeviceList"])
                    this.storeOrDeviceList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): ExternalPublishSkuToStoreOrDevices {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPublishSkuToStoreOrDevices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        if (Array.isArray(this.storeOrDeviceList)) {
            data["storeOrDeviceList"] = [];
            for (let item of this.storeOrDeviceList)
                data["storeOrDeviceList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IExternalPublishSkuToStoreOrDevices {
    skuIds: string[] | undefined;
    storeOrDeviceList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
}

export class ExternalPublishSkuToDevicesOrStoresOrOus implements IExternalPublishSkuToDevicesOrStoresOrOus {
    skuIds!: string[] | undefined;
    deviceOrStoreOrOuList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IExternalPublishSkuToDevicesOrStoresOrOus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            if (Array.isArray(_data["deviceOrStoreOrOuList"])) {
                this.deviceOrStoreOrOuList = [] as any;
                for (let item of _data["deviceOrStoreOrOuList"])
                    this.deviceOrStoreOrOuList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): ExternalPublishSkuToDevicesOrStoresOrOus {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalPublishSkuToDevicesOrStoresOrOus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        if (Array.isArray(this.deviceOrStoreOrOuList)) {
            data["deviceOrStoreOrOuList"] = [];
            for (let item of this.deviceOrStoreOrOuList)
                data["deviceOrStoreOrOuList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IExternalPublishSkuToDevicesOrStoresOrOus {
    skuIds: string[] | undefined;
    deviceOrStoreOrOuList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
}

export class ExternaMatchSkuModel implements IExternaMatchSkuModel {
    skuId!: string;
    isMain!: boolean;
    reason!: string | undefined;

    constructor(data?: IExternaMatchSkuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.isMain = _data["isMain"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ExternaMatchSkuModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternaMatchSkuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["isMain"] = this.isMain;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IExternaMatchSkuModel {
    skuId: string;
    isMain: boolean;
    reason: string | undefined;
}

export class ExternalAddOrUpdateMatchInfoModel implements IExternalAddOrUpdateMatchInfoModel {
    code!: string;
    title!: string;
    picUrl!: string;
    orderNumber!: number;
    skuList!: ExternaMatchSkuModel[] | undefined;
    from!: string | undefined;

    constructor(data?: IExternalAddOrUpdateMatchInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuList"])) {
                this.skuList = [] as any;
                for (let item of _data["skuList"])
                    this.skuList!.push(ExternaMatchSkuModel.fromJS(item));
            }
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExternalAddOrUpdateMatchInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAddOrUpdateMatchInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuList)) {
            data["skuList"] = [];
            for (let item of this.skuList)
                data["skuList"].push(item.toJSON());
        }
        data["from"] = this.from;
        return data; 
    }
}

export interface IExternalAddOrUpdateMatchInfoModel {
    code: string;
    title: string;
    picUrl: string;
    orderNumber: number;
    skuList: ExternaMatchSkuModel[] | undefined;
    from: string | undefined;
}

export class ExternalDeleteMatchInfoModel implements IExternalDeleteMatchInfoModel {
    matchCodes!: string[] | undefined;

    constructor(data?: IExternalDeleteMatchInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matchCodes"])) {
                this.matchCodes = [] as any;
                for (let item of _data["matchCodes"])
                    this.matchCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalDeleteMatchInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDeleteMatchInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matchCodes)) {
            data["matchCodes"] = [];
            for (let item of this.matchCodes)
                data["matchCodes"].push(item);
        }
        return data; 
    }
}

export interface IExternalDeleteMatchInfoModel {
    matchCodes: string[] | undefined;
}

export class ExternalLikeInfoSkuModel implements IExternalLikeInfoSkuModel {
    skuId!: string;
    isMain!: boolean;
    reason!: string | undefined;

    constructor(data?: IExternalLikeInfoSkuModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.isMain = _data["isMain"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): ExternalLikeInfoSkuModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLikeInfoSkuModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["isMain"] = this.isMain;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IExternalLikeInfoSkuModel {
    skuId: string;
    isMain: boolean;
    reason: string | undefined;
}

export class ExternalAddOrUpdateLikeInfoModel implements IExternalAddOrUpdateLikeInfoModel {
    code!: string;
    name!: string;
    image!: string | undefined;
    orderNumber!: number;
    skuList!: ExternalLikeInfoSkuModel[] | undefined;
    from!: string | undefined;

    constructor(data?: IExternalAddOrUpdateLikeInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuList"])) {
                this.skuList = [] as any;
                for (let item of _data["skuList"])
                    this.skuList!.push(ExternalLikeInfoSkuModel.fromJS(item));
            }
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExternalAddOrUpdateLikeInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAddOrUpdateLikeInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["image"] = this.image;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuList)) {
            data["skuList"] = [];
            for (let item of this.skuList)
                data["skuList"].push(item.toJSON());
        }
        data["from"] = this.from;
        return data; 
    }
}

export interface IExternalAddOrUpdateLikeInfoModel {
    code: string;
    name: string;
    image: string | undefined;
    orderNumber: number;
    skuList: ExternalLikeInfoSkuModel[] | undefined;
    from: string | undefined;
}

export class ExternalDeleteLikeInfoModel implements IExternalDeleteLikeInfoModel {
    likeCodes!: string[] | undefined;

    constructor(data?: IExternalDeleteLikeInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["likeCodes"])) {
                this.likeCodes = [] as any;
                for (let item of _data["likeCodes"])
                    this.likeCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalDeleteLikeInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDeleteLikeInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.likeCodes)) {
            data["likeCodes"] = [];
            for (let item of this.likeCodes)
                data["likeCodes"].push(item);
        }
        return data; 
    }
}

export interface IExternalDeleteLikeInfoModel {
    likeCodes: string[] | undefined;
}

export class ExternalAddOrUpdateBrandInput implements IExternalAddOrUpdateBrandInput {
    code!: string;
    orderNumber!: number;
    name!: string;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    slogan!: string | undefined;

    constructor(data?: IExternalAddOrUpdateBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            this.slogan = _data["slogan"];
        }
    }

    static fromJS(data: any): ExternalAddOrUpdateBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAddOrUpdateBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        data["slogan"] = this.slogan;
        return data; 
    }
}

export interface IExternalAddOrUpdateBrandInput {
    code: string;
    orderNumber: number;
    name: string;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    slogan: string | undefined;
}

export class ExternalDeleteBrandInput implements IExternalDeleteBrandInput {
    codes!: string[] | undefined;

    constructor(data?: IExternalDeleteBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalDeleteBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalDeleteBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        return data; 
    }
}

export interface IExternalDeleteBrandInput {
    codes: string[] | undefined;
}

export enum FileArea {
    Common = 0,
    Users = 1,
    Apps = 2,
    Products = 3,
    Matchs = 4,
    Likes = 5,
    Ads = 6,
    Coupon = 7,
    Peripheral = 8,
    DeviceCategory = 9,
    ProductCategory = 10,
    DeviceType = 11,
    Staffs = 12,
    Devices = 13,
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class TinyFileOutput implements ITinyFileOutput {
    resourceId!: number | undefined;
    fileUri!: string | undefined;
    thumbnailUri!: string | undefined;
    code!: number;
    message!: string | undefined;
    details!: string | undefined;
    validationErrors!: ValidationErrorInfo[] | undefined;

    constructor(data?: ITinyFileOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.fileUri = _data["fileUri"];
            this.thumbnailUri = _data["thumbnailUri"];
            this.code = _data["code"];
            this.message = _data["message"];
            this.details = _data["details"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TinyFileOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TinyFileOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["fileUri"] = this.fileUri;
        data["thumbnailUri"] = this.thumbnailUri;
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITinyFileOutput {
    resourceId: number | undefined;
    fileUri: string | undefined;
    thumbnailUri: string | undefined;
    code: number;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export enum GroupKPIScaleEnum {
    Year = 0,
    Month = 1,
    Week = 2,
    Day = 3,
}

export class GroupKPIDto implements IGroupKPIDto {
    organizationUnitId!: number | undefined;
    ouName!: string | undefined;
    ouOuterId!: string | undefined;
    scaleTime!: DateTime;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGroupKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.ouName = _data["ouName"];
            this.ouOuterId = _data["ouOuterId"];
            this.scaleTime = _data["scaleTime"] ? DateTime.fromISO(_data["scaleTime"].toString()) : <any>undefined;
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["ouName"] = this.ouName;
        data["ouOuterId"] = this.ouOuterId;
        data["scaleTime"] = this.scaleTime ? this.scaleTime.toString() : <any>undefined;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGroupKPIDto {
    organizationUnitId: number | undefined;
    ouName: string | undefined;
    ouOuterId: string | undefined;
    scaleTime: DateTime;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfGroupKPIDto implements IPagedResultDtoOfGroupKPIDto {
    totalCount!: number;
    items!: GroupKPIDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGroupKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupKPIDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGroupKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGroupKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGroupKPIDto {
    totalCount: number;
    items: GroupKPIDto[] | undefined;
}

export class CreateGroupKpiDtoInput implements ICreateGroupKpiDtoInput {
    organizationUnitId!: number | undefined;
    scaleTime!: string | undefined;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;

    constructor(data?: ICreateGroupKpiDtoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.scaleTime = _data["scaleTime"];
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateGroupKpiDtoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupKpiDtoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["scaleTime"] = this.scaleTime;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateGroupKpiDtoInput {
    organizationUnitId: number | undefined;
    scaleTime: string | undefined;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
}

export class UpdateGroupKpiDtoInput implements IUpdateGroupKpiDtoInput {
    id!: number;
    organizationUnitId!: number | undefined;
    scaleTime!: string | undefined;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;

    constructor(data?: IUpdateGroupKpiDtoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.scaleTime = _data["scaleTime"];
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateGroupKpiDtoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupKpiDtoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["organizationUnitId"] = this.organizationUnitId;
        data["scaleTime"] = this.scaleTime;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateGroupKpiDtoInput {
    id: number;
    organizationUnitId: number | undefined;
    scaleTime: string | undefined;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data; 
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: DateTime;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: DateTime;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? DateTime.fromISO(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: DateTime;
    recentTenants: RecentTenant[] | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: DateTime;
    subscriptionEndDateEnd!: DateTime;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? DateTime.fromISO(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? DateTime.fromISO(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: DateTime;
    subscriptionEndDateEnd: DateTime;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: DateTime;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: DateTime;
    amount: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data; 
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data; 
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data; 
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data; 
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data; 
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        return data; 
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data; 
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data; 
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data; 
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class ImportAdResultDto implements IImportAdResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportAdResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportAdResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAdResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportAdResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportDeviceResultDto implements IImportDeviceResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportDeviceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportDeviceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportDeviceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportDeviceResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportResultDto implements IImportResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportLikeResultDto implements IImportLikeResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportLikeResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportLikeResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportLikeResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportLikeResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportMatchResultDto implements IImportMatchResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportMatchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportMatchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportMatchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportMatchResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportStoreResultDto implements IImportStoreResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportStoreResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportStoreResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportStoreResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportStoreResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportResultBaseDto implements IImportResultBaseDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportResultBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportResultBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportResultBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportResultBaseDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class ImportProductResultDto implements IImportProductResultDto {
    importResult!: string | undefined;
    canNotFindImages!: string[] | undefined;
    canNotFindSpus!: string[] | undefined;
    canNotFindSkus!: string[] | undefined;
    succeedCode!: string[] | undefined;
    importState!: boolean;

    constructor(data?: IImportProductResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importResult = _data["importResult"];
            if (Array.isArray(_data["canNotFindImages"])) {
                this.canNotFindImages = [] as any;
                for (let item of _data["canNotFindImages"])
                    this.canNotFindImages!.push(item);
            }
            if (Array.isArray(_data["canNotFindSpus"])) {
                this.canNotFindSpus = [] as any;
                for (let item of _data["canNotFindSpus"])
                    this.canNotFindSpus!.push(item);
            }
            if (Array.isArray(_data["canNotFindSkus"])) {
                this.canNotFindSkus = [] as any;
                for (let item of _data["canNotFindSkus"])
                    this.canNotFindSkus!.push(item);
            }
            if (Array.isArray(_data["succeedCode"])) {
                this.succeedCode = [] as any;
                for (let item of _data["succeedCode"])
                    this.succeedCode!.push(item);
            }
            this.importState = _data["importState"];
        }
    }

    static fromJS(data: any): ImportProductResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportProductResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importResult"] = this.importResult;
        if (Array.isArray(this.canNotFindImages)) {
            data["canNotFindImages"] = [];
            for (let item of this.canNotFindImages)
                data["canNotFindImages"].push(item);
        }
        if (Array.isArray(this.canNotFindSpus)) {
            data["canNotFindSpus"] = [];
            for (let item of this.canNotFindSpus)
                data["canNotFindSpus"].push(item);
        }
        if (Array.isArray(this.canNotFindSkus)) {
            data["canNotFindSkus"] = [];
            for (let item of this.canNotFindSkus)
                data["canNotFindSkus"].push(item);
        }
        if (Array.isArray(this.succeedCode)) {
            data["succeedCode"] = [];
            for (let item of this.succeedCode)
                data["succeedCode"].push(item);
        }
        data["importState"] = this.importState;
        return data; 
    }
}

export interface IImportProductResultDto {
    importResult: string | undefined;
    canNotFindImages: string[] | undefined;
    canNotFindSpus: string[] | undefined;
    canNotFindSkus: string[] | undefined;
    succeedCode: string[] | undefined;
    importState: boolean;
}

export class CheckResult implements ICheckResult {
    success!: boolean;
    errorMessage!: string | undefined;

    constructor(data?: ICheckResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CheckResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface ICheckResult {
    success: boolean;
    errorMessage: string | undefined;
}

export class CreateIndependentDeploymentInput implements ICreateIndependentDeploymentInput {
    customer!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: ICreateIndependentDeploymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customer = _data["customer"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): CreateIndependentDeploymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIndependentDeploymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ICreateIndependentDeploymentInput {
    customer: string | undefined;
    phoneNumber: string | undefined;
}

export class UpdateIndependentDeploymentInput implements IUpdateIndependentDeploymentInput {
    id!: number;
    customer!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IUpdateIndependentDeploymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateIndependentDeploymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIndependentDeploymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IUpdateIndependentDeploymentInput {
    id: number;
    customer: string | undefined;
    phoneNumber: string | undefined;
}

export class IndependentDeploymentDto implements IIndependentDeploymentDto {
    id!: number;
    customer!: string | undefined;
    phoneNumber!: string | undefined;
    independentDeploymentCount!: number;

    constructor(data?: IIndependentDeploymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"];
            this.phoneNumber = _data["phoneNumber"];
            this.independentDeploymentCount = _data["independentDeploymentCount"];
        }
    }

    static fromJS(data: any): IndependentDeploymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndependentDeploymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer;
        data["phoneNumber"] = this.phoneNumber;
        data["independentDeploymentCount"] = this.independentDeploymentCount;
        return data; 
    }
}

export interface IIndependentDeploymentDto {
    id: number;
    customer: string | undefined;
    phoneNumber: string | undefined;
    independentDeploymentCount: number;
}

export class PagedResultDtoOfIndependentDeploymentDto implements IPagedResultDtoOfIndependentDeploymentDto {
    totalCount!: number;
    items!: IndependentDeploymentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIndependentDeploymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IndependentDeploymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIndependentDeploymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIndependentDeploymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIndependentDeploymentDto {
    totalCount: number;
    items: IndependentDeploymentDto[] | undefined;
}

export class IndependentDeploymentInfoDto implements IIndependentDeploymentInfoDto {
    id!: number;
    limitTenantsCount!: number | undefined;
    currentTenantsCount!: number;
    supportEndTime!: DateTime | undefined;
    host!: string | undefined;

    constructor(data?: IIndependentDeploymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.limitTenantsCount = _data["limitTenantsCount"];
            this.currentTenantsCount = _data["currentTenantsCount"];
            this.supportEndTime = _data["supportEndTime"] ? DateTime.fromISO(_data["supportEndTime"].toString()) : <any>undefined;
            this.host = _data["host"];
        }
    }

    static fromJS(data: any): IndependentDeploymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndependentDeploymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["limitTenantsCount"] = this.limitTenantsCount;
        data["currentTenantsCount"] = this.currentTenantsCount;
        data["supportEndTime"] = this.supportEndTime ? this.supportEndTime.toString() : <any>undefined;
        data["host"] = this.host;
        return data; 
    }
}

export interface IIndependentDeploymentInfoDto {
    id: number;
    limitTenantsCount: number | undefined;
    currentTenantsCount: number;
    supportEndTime: DateTime | undefined;
    host: string | undefined;
}

export class PagedResultDtoOfIndependentDeploymentInfoDto implements IPagedResultDtoOfIndependentDeploymentInfoDto {
    totalCount!: number;
    items!: IndependentDeploymentInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIndependentDeploymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IndependentDeploymentInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIndependentDeploymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIndependentDeploymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIndependentDeploymentInfoDto {
    totalCount: number;
    items: IndependentDeploymentInfoDto[] | undefined;
}

export class AddOrUpdateIndependentDeploymentInfoInput implements IAddOrUpdateIndependentDeploymentInfoInput {
    id!: number | undefined;
    independentDeploymentId!: number;
    limitTenantsCount!: number | undefined;
    currentTenantsCount!: number;
    supportEndTime!: DateTime | undefined;
    host!: string | undefined;

    constructor(data?: IAddOrUpdateIndependentDeploymentInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.independentDeploymentId = _data["independentDeploymentId"];
            this.limitTenantsCount = _data["limitTenantsCount"];
            this.currentTenantsCount = _data["currentTenantsCount"];
            this.supportEndTime = _data["supportEndTime"] ? DateTime.fromISO(_data["supportEndTime"].toString()) : <any>undefined;
            this.host = _data["host"];
        }
    }

    static fromJS(data: any): AddOrUpdateIndependentDeploymentInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateIndependentDeploymentInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["independentDeploymentId"] = this.independentDeploymentId;
        data["limitTenantsCount"] = this.limitTenantsCount;
        data["currentTenantsCount"] = this.currentTenantsCount;
        data["supportEndTime"] = this.supportEndTime ? this.supportEndTime.toString() : <any>undefined;
        data["host"] = this.host;
        return data; 
    }
}

export interface IAddOrUpdateIndependentDeploymentInfoInput {
    id: number | undefined;
    independentDeploymentId: number;
    limitTenantsCount: number | undefined;
    currentTenantsCount: number;
    supportEndTime: DateTime | undefined;
    host: string | undefined;
}

export class DeployedTenantDto implements IDeployedTenantDto {
    id!: number;
    tenantId!: number;
    tenancyName!: string | undefined;
    limitDevicesCount!: number | undefined;
    currentDevicesCount!: number;

    constructor(data?: IDeployedTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.limitDevicesCount = _data["limitDevicesCount"];
            this.currentDevicesCount = _data["currentDevicesCount"];
        }
    }

    static fromJS(data: any): DeployedTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeployedTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["limitDevicesCount"] = this.limitDevicesCount;
        data["currentDevicesCount"] = this.currentDevicesCount;
        return data; 
    }
}

export interface IDeployedTenantDto {
    id: number;
    tenantId: number;
    tenancyName: string | undefined;
    limitDevicesCount: number | undefined;
    currentDevicesCount: number;
}

export class PagedResultDtoOfDeployedTenantDto implements IPagedResultDtoOfDeployedTenantDto {
    totalCount!: number;
    items!: DeployedTenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeployedTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeployedTenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeployedTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeployedTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeployedTenantDto {
    totalCount: number;
    items: DeployedTenantDto[] | undefined;
}

export class AddOrUpdateDeployedTenant implements IAddOrUpdateDeployedTenant {
    id!: number | undefined;
    independentDeploymentInfoId!: number;
    tenantId!: number;
    tenancyName!: string | undefined;
    limitDevicesCount!: number | undefined;
    currentDevicesCount!: number;

    constructor(data?: IAddOrUpdateDeployedTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.independentDeploymentInfoId = _data["independentDeploymentInfoId"];
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.limitDevicesCount = _data["limitDevicesCount"];
            this.currentDevicesCount = _data["currentDevicesCount"];
        }
    }

    static fromJS(data: any): AddOrUpdateDeployedTenant {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateDeployedTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["independentDeploymentInfoId"] = this.independentDeploymentInfoId;
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["limitDevicesCount"] = this.limitDevicesCount;
        data["currentDevicesCount"] = this.currentDevicesCount;
        return data; 
    }
}

export interface IAddOrUpdateDeployedTenant {
    id: number | undefined;
    independentDeploymentInfoId: number;
    tenantId: number;
    tenancyName: string | undefined;
    limitDevicesCount: number | undefined;
    currentDevicesCount: number;
}

export class DeployedDeviceDto implements IDeployedDeviceDto {
    id!: number;
    deviceId!: number;
    deviceName!: string | undefined;

    constructor(data?: IDeployedDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
        }
    }

    static fromJS(data: any): DeployedDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeployedDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        return data; 
    }
}

export interface IDeployedDeviceDto {
    id: number;
    deviceId: number;
    deviceName: string | undefined;
}

export class PagedResultDtoOfDeployedDeviceDto implements IPagedResultDtoOfDeployedDeviceDto {
    totalCount!: number;
    items!: DeployedDeviceDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeployedDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeployedDeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeployedDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeployedDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeployedDeviceDto {
    totalCount: number;
    items: DeployedDeviceDto[] | undefined;
}

export class AddOrUpdateDeployedTenantDeviceInput implements IAddOrUpdateDeployedTenantDeviceInput {
    id!: number | undefined;
    deployedTenantId!: number;
    deviceId!: number;
    deviceName!: string | undefined;

    constructor(data?: IAddOrUpdateDeployedTenantDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deployedTenantId = _data["deployedTenantId"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
        }
    }

    static fromJS(data: any): AddOrUpdateDeployedTenantDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateDeployedTenantDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deployedTenantId"] = this.deployedTenantId;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        return data; 
    }
}

export interface IAddOrUpdateDeployedTenantDeviceInput {
    id: number | undefined;
    deployedTenantId: number;
    deviceId: number;
    deviceName: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: DateTime;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: DateTime;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class LikeItemDto implements ILikeItemDto {
    id!: number;
    likeInfoId!: number;
    skuId!: number;
    skuPicUrl!: string | undefined;
    skuTitle!: string | undefined;
    salesVolume!: number;
    quantity!: number;
    price!: string | undefined;
    reason!: string | undefined;
    isMain!: boolean;
    auditStatus!: AuditStatus;
    creationTime!: DateTime;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: ILikeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.likeInfoId = _data["likeInfoId"];
            this.skuId = _data["skuId"];
            this.skuPicUrl = _data["skuPicUrl"];
            this.skuTitle = _data["skuTitle"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
            this.auditStatus = _data["auditStatus"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): LikeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["likeInfoId"] = this.likeInfoId;
        data["skuId"] = this.skuId;
        data["skuPicUrl"] = this.skuPicUrl;
        data["skuTitle"] = this.skuTitle;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        data["auditStatus"] = this.auditStatus;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ILikeItemDto {
    id: number;
    likeInfoId: number;
    skuId: number;
    skuPicUrl: string | undefined;
    skuTitle: string | undefined;
    salesVolume: number;
    quantity: number;
    price: string | undefined;
    reason: string | undefined;
    isMain: boolean;
    auditStatus: AuditStatus;
    creationTime: DateTime;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class LikeInfoDto implements ILikeInfoDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    code!: string;
    orderNumber!: number;
    likeItems!: LikeItemDto[] | undefined;
    name!: string | undefined;
    image!: string | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ILikeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["likeItems"])) {
                this.likeItems = [] as any;
                for (let item of _data["likeItems"])
                    this.likeItems!.push(LikeItemDto.fromJS(item));
            }
            this.name = _data["name"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LikeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.likeItems)) {
            data["likeItems"] = [];
            for (let item of this.likeItems)
                data["likeItems"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["image"] = this.image;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILikeInfoDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    code: string;
    orderNumber: number;
    likeItems: LikeItemDto[] | undefined;
    name: string | undefined;
    image: string | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfLikeInfoDto implements IPagedResultDtoOfLikeInfoDto {
    totalCount!: number;
    items!: LikeInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLikeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LikeInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLikeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLikeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLikeInfoDto {
    totalCount: number;
    items: LikeInfoDto[] | undefined;
}

export class CreateLikeInfoInput implements ICreateLikeInfoInput {
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: ICreateLikeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateLikeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLikeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateLikeInfoInput {
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class UpdateLikeInfoInput implements IUpdateLikeInfoInput {
    id!: number;
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateLikeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLikeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLikeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateLikeInfoInput {
    id: number;
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfLikeItemDto implements IPagedResultDtoOfLikeItemDto {
    totalCount!: number;
    items!: LikeItemDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLikeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LikeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLikeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLikeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLikeItemDto {
    totalCount: number;
    items: LikeItemDto[] | undefined;
}

export class CreateLikeItemInput implements ICreateLikeItemInput {
    skuId!: number;
    likeInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: ICreateLikeItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.likeInfoId = _data["likeInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): CreateLikeItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLikeItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["likeInfoId"] = this.likeInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface ICreateLikeItemInput {
    skuId: number;
    likeInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export class UpdateLikeItemInput implements IUpdateLikeItemInput {
    id!: number;
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateLikeItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLikeItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLikeItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateLikeItemInput {
    id: number;
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class BindingAccountDto implements IBindingAccountDto {
    userId!: number;
    userName!: string | undefined;
    tennatId!: number;
    tenancyName!: string | undefined;
    lastLoginTime!: DateTime | undefined;

    constructor(data?: IBindingAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.tennatId = _data["tennatId"];
            this.tenancyName = _data["tenancyName"];
            this.lastLoginTime = _data["lastLoginTime"] ? DateTime.fromISO(_data["lastLoginTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BindingAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new BindingAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["tennatId"] = this.tennatId;
        data["tenancyName"] = this.tenancyName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IBindingAccountDto {
    userId: number;
    userName: string | undefined;
    tennatId: number;
    tenancyName: string | undefined;
    lastLoginTime: DateTime | undefined;
}

export class TokenModel implements ITokenModel {
    impersonationToken!: string | undefined;
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ITokenModel {
    impersonationToken: string | undefined;
    userId: number;
    tenantId: number | undefined;
}

export class BindPlatformUserInput implements IBindPlatformUserInput {
    unionId!: string | undefined;

    constructor(data?: IBindPlatformUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unionId = _data["unionId"];
        }
    }

    static fromJS(data: any): BindPlatformUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindPlatformUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unionId"] = this.unionId;
        return data; 
    }
}

export interface IBindPlatformUserInput {
    unionId: string | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class SimpleUserDto implements ISimpleUserDto {
    tenantId!: number | undefined;
    userId!: number;
    userName!: string | undefined;
    unionId!: string | undefined;

    constructor(data?: ISimpleUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.unionId = _data["unionId"];
        }
    }

    static fromJS(data: any): SimpleUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["unionId"] = this.unionId;
        return data; 
    }
}

export interface ISimpleUserDto {
    tenantId: number | undefined;
    userId: number;
    userName: string | undefined;
    unionId: string | undefined;
}

export class MatchItemDto implements IMatchItemDto {
    id!: number;
    matchInfoId!: number;
    skuId!: number;
    skuPicUrl!: string | undefined;
    skuTitle!: string | undefined;
    salesVolume!: number;
    quantity!: number;
    price!: string | undefined;
    reason!: string | undefined;
    isMain!: boolean;
    auditStatus!: AuditStatus;
    creationTime!: DateTime;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: IMatchItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.matchInfoId = _data["matchInfoId"];
            this.skuId = _data["skuId"];
            this.skuPicUrl = _data["skuPicUrl"];
            this.skuTitle = _data["skuTitle"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
            this.auditStatus = _data["auditStatus"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): MatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["matchInfoId"] = this.matchInfoId;
        data["skuId"] = this.skuId;
        data["skuPicUrl"] = this.skuPicUrl;
        data["skuTitle"] = this.skuTitle;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        data["auditStatus"] = this.auditStatus;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IMatchItemDto {
    id: number;
    matchInfoId: number;
    skuId: number;
    skuPicUrl: string | undefined;
    skuTitle: string | undefined;
    salesVolume: number;
    quantity: number;
    price: string | undefined;
    reason: string | undefined;
    isMain: boolean;
    auditStatus: AuditStatus;
    creationTime: DateTime;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class MatchInfoDto implements IMatchInfoDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    code!: string;
    orderNumber!: number;
    showImage!: string | undefined;
    bImg!: string | undefined;
    mImg!: string | undefined;
    sImg!: string | undefined;
    name!: string | undefined;
    matchItems!: MatchItemDto[] | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IMatchInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            if (Array.isArray(_data["matchItems"])) {
                this.matchItems = [] as any;
                for (let item of _data["matchItems"])
                    this.matchItems!.push(MatchItemDto.fromJS(item));
            }
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MatchInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        if (Array.isArray(this.matchItems)) {
            data["matchItems"] = [];
            for (let item of this.matchItems)
                data["matchItems"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchInfoDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    code: string;
    orderNumber: number;
    showImage: string | undefined;
    bImg: string | undefined;
    mImg: string | undefined;
    sImg: string | undefined;
    name: string | undefined;
    matchItems: MatchItemDto[] | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfMatchInfoDto implements IPagedResultDtoOfMatchInfoDto {
    totalCount!: number;
    items!: MatchInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMatchInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MatchInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMatchInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMatchInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMatchInfoDto {
    totalCount: number;
    items: MatchInfoDto[] | undefined;
}

export class MainSku implements IMainSku {
    skuId!: number;
    isMain!: boolean;

    constructor(data?: IMainSku) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): MainSku {
        data = typeof data === 'object' ? data : {};
        let result = new MainSku();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface IMainSku {
    skuId: number;
    isMain: boolean;
}

export class CreateMatchInfoInput implements ICreateMatchInfoInput {
    orderNumber!: number;
    showImage!: string | undefined;
    bImg!: string | undefined;
    mImg!: string | undefined;
    sImg!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    skus!: MainSku[] | undefined;
    description!: string | undefined;

    constructor(data?: ICreateMatchInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(MainSku.fromJS(item));
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateMatchInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateMatchInfoInput {
    orderNumber: number;
    showImage: string | undefined;
    bImg: string | undefined;
    mImg: string | undefined;
    sImg: string | undefined;
    name: string | undefined;
    code: string | undefined;
    skus: MainSku[] | undefined;
    description: string | undefined;
}

export class UpdateMatchInfoInput implements IUpdateMatchInfoInput {
    id!: number;
    orderNumber!: number;
    showImage!: string | undefined;
    bImg!: string | undefined;
    mImg!: string | undefined;
    sImg!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    skus!: MainSku[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateMatchInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(MainSku.fromJS(item));
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateMatchInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMatchInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateMatchInfoInput {
    id: number;
    orderNumber: number;
    showImage: string | undefined;
    bImg: string | undefined;
    mImg: string | undefined;
    sImg: string | undefined;
    name: string | undefined;
    code: string | undefined;
    skus: MainSku[] | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfMatchItemDto implements IPagedResultDtoOfMatchItemDto {
    totalCount!: number;
    items!: MatchItemDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMatchItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMatchItemDto {
    totalCount: number;
    items: MatchItemDto[] | undefined;
}

export class CreateMatchItemInput implements ICreateMatchItemInput {
    skuId!: number;
    matchInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: ICreateMatchItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.matchInfoId = _data["matchInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): CreateMatchItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["matchInfoId"] = this.matchInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface ICreateMatchItemInput {
    skuId: number;
    matchInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export class UpdateMatchItemInput implements IUpdateMatchItemInput {
    id!: number;
    skuId!: number;
    matchInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: IUpdateMatchItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.matchInfoId = _data["matchInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): UpdateMatchItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMatchItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["matchInfoId"] = this.matchInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface IUpdateMatchItemInput {
    id: number;
    skuId: number;
    matchInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        this.properties![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: DateTime;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: DateTime;
    id: string;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class OnlineStoreProfileDto implements IOnlineStoreProfileDto {
    onlineStoreName!: string | undefined;
    code!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOnlineStoreProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlineStoreName = _data["onlineStoreName"];
            this.code = _data["code"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OnlineStoreProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new OnlineStoreProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlineStoreName"] = this.onlineStoreName;
        data["code"] = this.code;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOnlineStoreProfileDto {
    onlineStoreName: string | undefined;
    code: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfOnlineStoreProfileDto implements IPagedResultDtoOfOnlineStoreProfileDto {
    totalCount!: number;
    items!: OnlineStoreProfileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOnlineStoreProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OnlineStoreProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOnlineStoreProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOnlineStoreProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOnlineStoreProfileDto {
    totalCount: number;
    items: OnlineStoreProfileDto[] | undefined;
}

export class CreateOnlineStoreProfileInput implements ICreateOnlineStoreProfileInput {
    userId!: number;
    onlineStoreName!: string | undefined;
    code!: string | undefined;

    constructor(data?: ICreateOnlineStoreProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateOnlineStoreProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOnlineStoreProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICreateOnlineStoreProfileInput {
    userId: number;
    onlineStoreName: string | undefined;
    code: string | undefined;
}

export class UpdateOnlineStoreProfileInput implements IUpdateOnlineStoreProfileInput {
    userId!: number;
    id!: number;
    onlineStoreName!: string | undefined;
    code!: string | undefined;

    constructor(data?: IUpdateOnlineStoreProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.id = _data["id"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UpdateOnlineStoreProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOnlineStoreProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["id"] = this.id;
        data["onlineStoreName"] = this.onlineStoreName;
        data["code"] = this.code;
        return data; 
    }
}

export interface IUpdateOnlineStoreProfileInput {
    userId: number;
    id: number;
    onlineStoreName: string | undefined;
    code: string | undefined;
}

export class PositionDto implements IPositionDto {
    id!: number | undefined;
    state!: string | undefined;
    area!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    county!: string | undefined;
    location!: string | undefined;
    longitude!: number | undefined;
    latitude!: number | undefined;
    code!: string | undefined;
    zipCode!: string | undefined;

    constructor(data?: IPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.area = _data["area"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.location = _data["location"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.code = _data["code"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): PositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["area"] = this.area;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["location"] = this.location;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["code"] = this.code;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IPositionDto {
    id: number | undefined;
    state: string | undefined;
    area: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    location: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    code: string | undefined;
    zipCode: string | undefined;
}

export class OrganizationUnitTypeDto implements IOrganizationUnitTypeDto {
    name!: string | undefined;
    orderNumber!: number;
    isDefault!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.isDefault = _data["isDefault"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitTypeDto {
    name: string | undefined;
    orderNumber: number;
    isDefault: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class GroupDto implements IGroupDto {
    organizationUnitTypeId!: number;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    taobaoStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isNeedActivityApprove!: boolean;
    isNeedTrainingApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    organizationUnitType!: OrganizationUnitTypeDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    defaultOnlineShopName!: string | undefined;
    qrcodeRules!: string | undefined;
    targetSalesOfMonth!: number | undefined;
    targetRegisterOfMonth!: number | undefined;
    storeDevicesInfo!: string | undefined;
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitTypeId = _data["organizationUnitTypeId"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isNeedActivityApprove = _data["isNeedActivityApprove"];
            this.isNeedTrainingApprove = _data["isNeedTrainingApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.organizationUnitType = _data["organizationUnitType"] ? OrganizationUnitTypeDto.fromJS(_data["organizationUnitType"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.qrcodeRules = _data["qrcodeRules"];
            this.targetSalesOfMonth = _data["targetSalesOfMonth"];
            this.targetRegisterOfMonth = _data["targetRegisterOfMonth"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitTypeId"] = this.organizationUnitTypeId;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isNeedActivityApprove"] = this.isNeedActivityApprove;
        data["isNeedTrainingApprove"] = this.isNeedTrainingApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["organizationUnitType"] = this.organizationUnitType ? this.organizationUnitType.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["qrcodeRules"] = this.qrcodeRules;
        data["targetSalesOfMonth"] = this.targetSalesOfMonth;
        data["targetRegisterOfMonth"] = this.targetRegisterOfMonth;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGroupDto {
    organizationUnitTypeId: number;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    taobaoStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isNeedActivityApprove: boolean;
    isNeedTrainingApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    organizationUnitType: OrganizationUnitTypeDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    defaultOnlineShopName: string | undefined;
    qrcodeRules: string | undefined;
    targetSalesOfMonth: number | undefined;
    targetRegisterOfMonth: number | undefined;
    storeDevicesInfo: string | undefined;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ListResultDtoOfGroupDto implements IListResultDtoOfGroupDto {
    items!: GroupDto[] | undefined;

    constructor(data?: IListResultDtoOfGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGroupDto {
    items: GroupDto[] | undefined;
}

export class OrganizationPositionDto implements IOrganizationPositionDto {
    id!: number;
    outerId!: string | undefined;
    displayName!: string | undefined;
    position!: PositionDto;

    constructor(data?: IOrganizationPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.displayName = _data["displayName"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["displayName"] = this.displayName;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IOrganizationPositionDto {
    id: number;
    outerId: string | undefined;
    displayName: string | undefined;
    position: PositionDto;
}

export class PagedResultDtoOfOrganizationPositionDto implements IPagedResultDtoOfOrganizationPositionDto {
    totalCount!: number;
    items!: OrganizationPositionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationPositionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationPositionDto {
    totalCount: number;
    items: OrganizationPositionDto[] | undefined;
}

export class StoreDto implements IStoreDto {
    outerId!: string | undefined;
    displayName!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    qrCodeExtraInfo!: string | undefined;
    taobaoStoreId!: string | undefined;
    bizType!: string | undefined;
    position!: PositionDto;

    constructor(data?: IStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.displayName = _data["displayName"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.bizType = _data["bizType"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["displayName"] = this.displayName;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["bizType"] = this.bizType;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStoreDto {
    outerId: string | undefined;
    displayName: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    qrCodeExtraInfo: string | undefined;
    taobaoStoreId: string | undefined;
    bizType: string | undefined;
    position: PositionDto;
}

export class PagedResultDtoOfStoreDto implements IPagedResultDtoOfStoreDto {
    totalCount!: number;
    items!: StoreDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStoreDto {
    totalCount: number;
    items: StoreDto[] | undefined;
}

export class TreeDtoOfInt64 implements ITreeDtoOfInt64 {
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    children!: TreeDtoOfInt64[] | undefined;
    outerId!: string | undefined;

    constructor(data?: ITreeDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeDtoOfInt64.fromJS(item));
            }
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): TreeDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new TreeDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface ITreeDtoOfInt64 {
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    children: TreeDtoOfInt64[] | undefined;
    outerId: string | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class UserTenantOUDto implements IUserTenantOUDto {
    tenantId!: number;
    organizationUnitId!: number;
    userId!: number;

    constructor(data?: IUserTenantOUDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserTenantOUDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserTenantOUDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUserTenantOUDto {
    tenantId: number;
    organizationUnitId: number;
    userId: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;
    organizationUnitTypeId!: number | undefined;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    taobaoStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    isNeedActivityApprove!: boolean;
    isNeedTrainingApprove!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    defaultOnlineShopName!: string | undefined;
    qrcodeRules!: string | undefined;
    targetSalesOfMonth!: number | undefined;
    targetRegisterOfMonth!: number | undefined;
    storeDevicesInfo!: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
            this.organizationUnitTypeId = _data["organizationUnitTypeId"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.isNeedActivityApprove = _data["isNeedActivityApprove"];
            this.isNeedTrainingApprove = _data["isNeedTrainingApprove"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.qrcodeRules = _data["qrcodeRules"];
            this.targetSalesOfMonth = _data["targetSalesOfMonth"];
            this.targetRegisterOfMonth = _data["targetRegisterOfMonth"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["organizationUnitTypeId"] = this.organizationUnitTypeId;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["isNeedActivityApprove"] = this.isNeedActivityApprove;
        data["isNeedTrainingApprove"] = this.isNeedTrainingApprove;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["qrcodeRules"] = this.qrcodeRules;
        data["targetSalesOfMonth"] = this.targetSalesOfMonth;
        data["targetRegisterOfMonth"] = this.targetRegisterOfMonth;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
    organizationUnitTypeId: number | undefined;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    taobaoStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    isNeedActivityApprove: boolean;
    isNeedTrainingApprove: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    defaultOnlineShopName: string | undefined;
    qrcodeRules: string | undefined;
    targetSalesOfMonth: number | undefined;
    targetRegisterOfMonth: number | undefined;
    storeDevicesInfo: string | undefined;
}

export class UpdateGroupInput implements IUpdateGroupInput {
    organizationUnitTypeId!: number | undefined;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    taobaoStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isNeedActivityApprove!: boolean;
    isNeedTrainingApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    defaultOnlineShopName!: string | undefined;
    qrcodeRules!: string | undefined;
    targetSalesOfMonth!: number | undefined;
    targetRegisterOfMonth!: number | undefined;
    storeDevicesInfo!: string | undefined;
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitTypeId = _data["organizationUnitTypeId"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isNeedActivityApprove = _data["isNeedActivityApprove"];
            this.isNeedTrainingApprove = _data["isNeedTrainingApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.qrcodeRules = _data["qrcodeRules"];
            this.targetSalesOfMonth = _data["targetSalesOfMonth"];
            this.targetRegisterOfMonth = _data["targetRegisterOfMonth"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitTypeId"] = this.organizationUnitTypeId;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isNeedActivityApprove"] = this.isNeedActivityApprove;
        data["isNeedTrainingApprove"] = this.isNeedTrainingApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["qrcodeRules"] = this.qrcodeRules;
        data["targetSalesOfMonth"] = this.targetSalesOfMonth;
        data["targetRegisterOfMonth"] = this.targetRegisterOfMonth;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateGroupInput {
    organizationUnitTypeId: number | undefined;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    taobaoStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isNeedActivityApprove: boolean;
    isNeedTrainingApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    defaultOnlineShopName: string | undefined;
    qrcodeRules: string | undefined;
    targetSalesOfMonth: number | undefined;
    targetRegisterOfMonth: number | undefined;
    storeDevicesInfo: string | undefined;
    id: number;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class OrganizationUnitClaimsDto implements IOrganizationUnitClaimsDto {
    claims!: NameValue[] | undefined;
    features!: NameValue[] | undefined;

    constructor(data?: IOrganizationUnitClaimsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(NameValue.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitClaimsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitClaimsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitClaimsDto {
    claims: NameValue[] | undefined;
    features: NameValue[] | undefined;
}

export class OrganizationUnitClaimsInput implements IOrganizationUnitClaimsInput {
    organizationUnitId!: number;
    claims!: NameValue[] | undefined;

    constructor(data?: IOrganizationUnitClaimsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitClaimsInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitClaimsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitClaimsInput {
    organizationUnitId: number;
    claims: NameValue[] | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class PagedResultDtoOfIdNameDto implements IPagedResultDtoOfIdNameDto {
    totalCount!: number;
    items!: IdNameDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIdNameDto {
    totalCount: number;
    items: IdNameDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class PagedResultDtoOfOrganizationUnitTypeDto implements IPagedResultDtoOfOrganizationUnitTypeDto {
    totalCount!: number;
    items!: OrganizationUnitTypeDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitTypeDto {
    totalCount: number;
    items: OrganizationUnitTypeDto[] | undefined;
}

export class CreateOrganizationUnitTypeInput implements ICreateOrganizationUnitTypeInput {
    name!: string | undefined;
    orderNumber!: number;

    constructor(data?: ICreateOrganizationUnitTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface ICreateOrganizationUnitTypeInput {
    name: string | undefined;
    orderNumber: number;
}

export class CreateDefaultOUTypeInput implements ICreateDefaultOUTypeInput {
    name!: string | undefined;
    orderNumber!: number;
    tenantId!: number;
    isDefault!: boolean;

    constructor(data?: ICreateDefaultOUTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
            this.tenantId = _data["tenantId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateDefaultOUTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDefaultOUTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        data["tenantId"] = this.tenantId;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateDefaultOUTypeInput {
    name: string | undefined;
    orderNumber: number;
    tenantId: number;
    isDefault: boolean;
}

export class UpdateOrganizationUnitTypeInput implements IUpdateOrganizationUnitTypeInput {
    id!: number;
    name!: string | undefined;
    orderNumber!: number;

    constructor(data?: IUpdateOrganizationUnitTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateOrganizationUnitTypeInput {
    id: number;
    name: string | undefined;
    orderNumber: number;
}

export class StsTokenModel implements IStsTokenModel {
    bucketName!: string | undefined;
    endpoint!: string | undefined;
    status!: number;
    accessKeyId!: string | undefined;
    accessKeySecret!: string | undefined;
    security!: string | undefined;
    expiration!: string | undefined;
    useStsServer!: boolean;

    constructor(data?: IStsTokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bucketName = _data["bucketName"];
            this.endpoint = _data["endpoint"];
            this.status = _data["status"];
            this.accessKeyId = _data["accessKeyId"];
            this.accessKeySecret = _data["accessKeySecret"];
            this.security = _data["security"];
            this.expiration = _data["expiration"];
            this.useStsServer = _data["useStsServer"];
        }
    }

    static fromJS(data: any): StsTokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new StsTokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bucketName"] = this.bucketName;
        data["endpoint"] = this.endpoint;
        data["status"] = this.status;
        data["accessKeyId"] = this.accessKeyId;
        data["accessKeySecret"] = this.accessKeySecret;
        data["security"] = this.security;
        data["expiration"] = this.expiration;
        data["useStsServer"] = this.useStsServer;
        return data; 
    }
}

export interface IStsTokenModel {
    bucketName: string | undefined;
    endpoint: string | undefined;
    status: number;
    accessKeyId: string | undefined;
    accessKeySecret: string | undefined;
    security: string | undefined;
    expiration: string | undefined;
    useStsServer: boolean;
}

export enum OutPutInStorageType {
    Out = 0,
    Put = 1,
    Check = 2,
}

export class OutPutInStorageSku implements IOutPutInStorageSku {
    productId!: number;
    skuId!: number;
    number!: number;

    constructor(data?: IOutPutInStorageSku) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.skuId = _data["skuId"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): OutPutInStorageSku {
        data = typeof data === 'object' ? data : {};
        let result = new OutPutInStorageSku();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        return data; 
    }
}

export interface IOutPutInStorageSku {
    productId: number;
    skuId: number;
    number: number;
}

export class AddOrUpdateOutPutInStorageBillInput implements IAddOrUpdateOutPutInStorageBillInput {
    id!: number | undefined;
    outerId!: string | undefined;
    storeId!: number | undefined;
    from!: string | undefined;
    outPutInStorageType!: OutPutInStorageType;
    descrtption!: string | undefined;
    outPutInStorageSkus!: OutPutInStorageSku[] | undefined;

    constructor(data?: IAddOrUpdateOutPutInStorageBillInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.storeId = _data["storeId"];
            this.from = _data["from"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.descrtption = _data["descrtption"];
            if (Array.isArray(_data["outPutInStorageSkus"])) {
                this.outPutInStorageSkus = [] as any;
                for (let item of _data["outPutInStorageSkus"])
                    this.outPutInStorageSkus!.push(OutPutInStorageSku.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateOutPutInStorageBillInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOutPutInStorageBillInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["storeId"] = this.storeId;
        data["from"] = this.from;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["descrtption"] = this.descrtption;
        if (Array.isArray(this.outPutInStorageSkus)) {
            data["outPutInStorageSkus"] = [];
            for (let item of this.outPutInStorageSkus)
                data["outPutInStorageSkus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateOutPutInStorageBillInput {
    id: number | undefined;
    outerId: string | undefined;
    storeId: number | undefined;
    from: string | undefined;
    outPutInStorageType: OutPutInStorageType;
    descrtption: string | undefined;
    outPutInStorageSkus: OutPutInStorageSku[] | undefined;
}

export class GetOutPutInStorageBillInput implements IGetOutPutInStorageBillInput {
    storeId!: number[] | undefined;
    ignoreStore!: boolean;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    outPutInStorageType!: OutPutInStorageType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetOutPutInStorageBillInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeId"])) {
                this.storeId = [] as any;
                for (let item of _data["storeId"])
                    this.storeId!.push(item);
            }
            this.ignoreStore = _data["ignoreStore"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageBillInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageBillInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeId)) {
            data["storeId"] = [];
            for (let item of this.storeId)
                data["storeId"].push(item);
        }
        data["ignoreStore"] = this.ignoreStore;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetOutPutInStorageBillInput {
    storeId: number[] | undefined;
    ignoreStore: boolean;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    outPutInStorageType: OutPutInStorageType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetOutPutInStorageBillDto implements IGetOutPutInStorageBillDto {
    id!: number;
    creationTime!: DateTime;
    billNo!: string | undefined;
    outerId!: string | undefined;
    skuNumber!: number;
    skuCount!: number;
    description!: string | undefined;
    outPutInStorageType!: OutPutInStorageType;
    from!: string | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    storeId!: number | undefined;

    constructor(data?: IGetOutPutInStorageBillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.billNo = _data["billNo"];
            this.outerId = _data["outerId"];
            this.skuNumber = _data["skuNumber"];
            this.skuCount = _data["skuCount"];
            this.description = _data["description"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.from = _data["from"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageBillDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageBillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["billNo"] = this.billNo;
        data["outerId"] = this.outerId;
        data["skuNumber"] = this.skuNumber;
        data["skuCount"] = this.skuCount;
        data["description"] = this.description;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["from"] = this.from;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IGetOutPutInStorageBillDto {
    id: number;
    creationTime: DateTime;
    billNo: string | undefined;
    outerId: string | undefined;
    skuNumber: number;
    skuCount: number;
    description: string | undefined;
    outPutInStorageType: OutPutInStorageType;
    from: string | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    storeId: number | undefined;
}

export class PagedResultDtoOfGetOutPutInStorageBillDto implements IPagedResultDtoOfGetOutPutInStorageBillDto {
    totalCount!: number;
    items!: GetOutPutInStorageBillDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOutPutInStorageBillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOutPutInStorageBillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOutPutInStorageBillDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOutPutInStorageBillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOutPutInStorageBillDto {
    totalCount: number;
    items: GetOutPutInStorageBillDto[] | undefined;
}

export class GetOutPutInStorageRecordInput implements IGetOutPutInStorageRecordInput {
    outPutInStorageBillId!: number | undefined;
    skuId!: number | undefined;
    storeId!: number[] | undefined;
    startTime!: DateTime | undefined;
    endtTime!: DateTime | undefined;
    ignoreStore!: boolean;
    outPutInStorageType!: OutPutInStorageType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetOutPutInStorageRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outPutInStorageBillId = _data["outPutInStorageBillId"];
            this.skuId = _data["skuId"];
            if (Array.isArray(_data["storeId"])) {
                this.storeId = [] as any;
                for (let item of _data["storeId"])
                    this.storeId!.push(item);
            }
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endtTime = _data["endtTime"] ? DateTime.fromISO(_data["endtTime"].toString()) : <any>undefined;
            this.ignoreStore = _data["ignoreStore"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outPutInStorageBillId"] = this.outPutInStorageBillId;
        data["skuId"] = this.skuId;
        if (Array.isArray(this.storeId)) {
            data["storeId"] = [];
            for (let item of this.storeId)
                data["storeId"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endtTime"] = this.endtTime ? this.endtTime.toString() : <any>undefined;
        data["ignoreStore"] = this.ignoreStore;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetOutPutInStorageRecordInput {
    outPutInStorageBillId: number | undefined;
    skuId: number | undefined;
    storeId: number[] | undefined;
    startTime: DateTime | undefined;
    endtTime: DateTime | undefined;
    ignoreStore: boolean;
    outPutInStorageType: OutPutInStorageType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetOutPutInStorageRecordDto implements IGetOutPutInStorageRecordDto {
    id!: number;
    number!: number;
    quantityBefore!: number;
    quantityAfter!: number;
    sku!: SkuDto;
    bill!: GetOutPutInStorageBillDto;

    constructor(data?: IGetOutPutInStorageRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.quantityBefore = _data["quantityBefore"];
            this.quantityAfter = _data["quantityAfter"];
            this.sku = _data["sku"] ? SkuDto.fromJS(_data["sku"]) : <any>undefined;
            this.bill = _data["bill"] ? GetOutPutInStorageBillDto.fromJS(_data["bill"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOutPutInStorageRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["quantityBefore"] = this.quantityBefore;
        data["quantityAfter"] = this.quantityAfter;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["bill"] = this.bill ? this.bill.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetOutPutInStorageRecordDto {
    id: number;
    number: number;
    quantityBefore: number;
    quantityAfter: number;
    sku: SkuDto;
    bill: GetOutPutInStorageBillDto;
}

export class PagedResultDtoOfGetOutPutInStorageRecordDto implements IPagedResultDtoOfGetOutPutInStorageRecordDto {
    totalCount!: number;
    items!: GetOutPutInStorageRecordDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOutPutInStorageRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOutPutInStorageRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOutPutInStorageRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOutPutInStorageRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOutPutInStorageRecordDto {
    totalCount: number;
    items: GetOutPutInStorageRecordDto[] | undefined;
}

export class GetSkuRfidDto implements IGetSkuRfidDto {
    id!: number;
    rfidCode!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    sku!: SkuDto;
    isPurchased!: boolean;
    purchaseTime!: DateTime | undefined;

    constructor(data?: IGetSkuRfidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rfidCode = _data["rfidCode"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.sku = _data["sku"] ? SkuDto.fromJS(_data["sku"]) : <any>undefined;
            this.isPurchased = _data["isPurchased"];
            this.purchaseTime = _data["purchaseTime"] ? DateTime.fromISO(_data["purchaseTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSkuRfidDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSkuRfidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rfidCode"] = this.rfidCode;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["isPurchased"] = this.isPurchased;
        data["purchaseTime"] = this.purchaseTime ? this.purchaseTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetSkuRfidDto {
    id: number;
    rfidCode: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    sku: SkuDto;
    isPurchased: boolean;
    purchaseTime: DateTime | undefined;
}

export class PagedResultDtoOfGetSkuRfidDto implements IPagedResultDtoOfGetSkuRfidDto {
    totalCount!: number;
    items!: GetSkuRfidDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSkuRfidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSkuRfidDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSkuRfidDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSkuRfidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSkuRfidDto {
    totalCount: number;
    items: GetSkuRfidDto[] | undefined;
}

export class SkuQuantity implements ISkuQuantity {
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    quantity!: number;

    constructor(data?: ISkuQuantity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): SkuQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new SkuQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface ISkuQuantity {
    skuId: number | undefined;
    sku_Id: string | undefined;
    quantity: number;
}

export class AddStorageCheckInput implements IAddStorageCheckInput {
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    storageOuterId!: string | undefined;
    skuQuantity!: SkuQuantity[] | undefined;

    constructor(data?: IAddStorageCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storageOuterId = _data["storageOuterId"];
            if (Array.isArray(_data["skuQuantity"])) {
                this.skuQuantity = [] as any;
                for (let item of _data["skuQuantity"])
                    this.skuQuantity!.push(SkuQuantity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddStorageCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddStorageCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storageOuterId"] = this.storageOuterId;
        if (Array.isArray(this.skuQuantity)) {
            data["skuQuantity"] = [];
            for (let item of this.skuQuantity)
                data["skuQuantity"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddStorageCheckInput {
    storeId: number | undefined;
    storeOuterId: string | undefined;
    storageOuterId: string | undefined;
    skuQuantity: SkuQuantity[] | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
            this.additionalData = _data["additionalData"] ? AdditionalData.fromJS(_data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class PagedResultDtoOfPeripheralDto implements IPagedResultDtoOfPeripheralDto {
    totalCount!: number;
    items!: PeripheralDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPeripheralDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PeripheralDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPeripheralDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPeripheralDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPeripheralDto {
    totalCount: number;
    items: PeripheralDto[] | undefined;
}

export class CreatePeripheralInput implements ICreatePeripheralInput {
    name!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreatePeripheralInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreatePeripheralInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePeripheralInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreatePeripheralInput {
    name: string | undefined;
    iconUrl: string | undefined;
}

export class UpdatePeripheralInput implements IUpdatePeripheralInput {
    id!: number;
    name!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdatePeripheralInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdatePeripheralInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePeripheralInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdatePeripheralInput {
    id: number;
    name: string | undefined;
    iconUrl: string | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class UpdateDefaultPriceTagInput implements IUpdateDefaultPriceTagInput {
    deviceId!: number;
    targetSkuId!: number;

    constructor(data?: IUpdateDefaultPriceTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.targetSkuId = _data["targetSkuId"];
        }
    }

    static fromJS(data: any): UpdateDefaultPriceTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDefaultPriceTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["targetSkuId"] = this.targetSkuId;
        return data; 
    }
}

export interface IUpdateDefaultPriceTagInput {
    deviceId: number;
    targetSkuId: number;
}

export class PriceTagPriceTagIntegrationInput implements IPriceTagPriceTagIntegrationInput {
    deviceIds!: number[] | undefined;
    command!: string | undefined;

    constructor(data?: IPriceTagPriceTagIntegrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.command = _data["command"];
        }
    }

    static fromJS(data: any): PriceTagPriceTagIntegrationInput {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTagPriceTagIntegrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["command"] = this.command;
        return data; 
    }
}

export interface IPriceTagPriceTagIntegrationInput {
    deviceIds: number[] | undefined;
    command: string | undefined;
}

export class SyncItem implements ISyncItem {
    sku!: string | undefined;
    customerStoreCode!: string | undefined;
    itemName!: string | undefined;
    price1!: string | undefined;
    ean!: string | undefined;
    qrCode!: string | undefined;
    level1CategoryName!: string | undefined;
    rsrvTxt1!: string | undefined;
    rsrvTxt2!: string | undefined;
    rsrvBlob!: string | undefined;

    constructor(data?: ISyncItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.customerStoreCode = _data["customerStoreCode"];
            this.itemName = _data["itemName"];
            this.price1 = _data["price1"];
            this.ean = _data["ean"];
            this.qrCode = _data["qrCode"];
            this.level1CategoryName = _data["level1CategoryName"];
            this.rsrvTxt1 = _data["rsrvTxt1"];
            this.rsrvTxt2 = _data["rsrvTxt2"];
            this.rsrvBlob = _data["rsrvBlob"];
        }
    }

    static fromJS(data: any): SyncItem {
        data = typeof data === 'object' ? data : {};
        let result = new SyncItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["customerStoreCode"] = this.customerStoreCode;
        data["itemName"] = this.itemName;
        data["price1"] = this.price1;
        data["ean"] = this.ean;
        data["qrCode"] = this.qrCode;
        data["level1CategoryName"] = this.level1CategoryName;
        data["rsrvTxt1"] = this.rsrvTxt1;
        data["rsrvTxt2"] = this.rsrvTxt2;
        data["rsrvBlob"] = this.rsrvBlob;
        return data; 
    }
}

export interface ISyncItem {
    sku: string | undefined;
    customerStoreCode: string | undefined;
    itemName: string | undefined;
    price1: string | undefined;
    ean: string | undefined;
    qrCode: string | undefined;
    level1CategoryName: string | undefined;
    rsrvTxt1: string | undefined;
    rsrvTxt2: string | undefined;
    rsrvBlob: string | undefined;
}

export class PriceTagSyncProductInput implements IPriceTagSyncProductInput {
    customerStoreCode!: string | undefined;
    storeCode!: string | undefined;
    batchSize!: number;
    batchNo!: string | undefined;
    items!: SyncItem[] | undefined;

    constructor(data?: IPriceTagSyncProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerStoreCode = _data["customerStoreCode"];
            this.storeCode = _data["storeCode"];
            this.batchSize = _data["batchSize"];
            this.batchNo = _data["batchNo"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SyncItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceTagSyncProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTagSyncProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerStoreCode"] = this.customerStoreCode;
        data["storeCode"] = this.storeCode;
        data["batchSize"] = this.batchSize;
        data["batchNo"] = this.batchNo;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPriceTagSyncProductInput {
    customerStoreCode: string | undefined;
    storeCode: string | undefined;
    batchSize: number;
    batchNo: string | undefined;
    items: SyncItem[] | undefined;
}

export class PriceDefaultDto implements IPriceDefaultDto {
    defaultSku!: SkuDto;
    bindSku!: SkuDto;

    constructor(data?: IPriceDefaultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultSku = _data["defaultSku"] ? SkuDto.fromJS(_data["defaultSku"]) : <any>undefined;
            this.bindSku = _data["bindSku"] ? SkuDto.fromJS(_data["bindSku"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PriceDefaultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceDefaultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultSku"] = this.defaultSku ? this.defaultSku.toJSON() : <any>undefined;
        data["bindSku"] = this.bindSku ? this.bindSku.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPriceDefaultDto {
    defaultSku: SkuDto;
    bindSku: SkuDto;
}

export class UpdateProductInput implements IUpdateProductInput {
    id!: number;
    itemId!: string;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    categorys!: number[] | undefined;
    keywords!: string | undefined;
    tags!: number[] | undefined;
    quantity!: number;
    fromType!: string | undefined;
    price!: number;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number;
    orderNumber!: number;
    barcode!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    material3DUrl!: string | undefined;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    organizationUnitId!: number | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.material3DUrl = _data["material3DUrl"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["material3DUrl"] = this.material3DUrl;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateProductInput {
    id: number;
    itemId: string;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    subTitle: string | undefined;
    picUrl: string | undefined;
    categorys: number[] | undefined;
    keywords: string | undefined;
    tags: number[] | undefined;
    quantity: number;
    fromType: string | undefined;
    price: number;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number;
    orderNumber: number;
    barcode: string | undefined;
    auditStatus: number;
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    material3DUrl: string | undefined;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    organizationUnitId: number | undefined;
    pointRule: ProductPointRule;
}

export class CreateProductInput implements ICreateProductInput {
    itemId!: string;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    categorys!: number[] | undefined;
    keywords!: string | undefined;
    tags!: number[] | undefined;
    quantity!: number;
    fromType!: string | undefined;
    price!: number;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number;
    orderNumber!: number;
    barcode!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    material3DUrl!: string | undefined;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    organizationUnitId!: number | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: ICreateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.material3DUrl = _data["material3DUrl"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["material3DUrl"] = this.material3DUrl;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateProductInput {
    itemId: string;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    subTitle: string | undefined;
    picUrl: string | undefined;
    categorys: number[] | undefined;
    keywords: string | undefined;
    tags: number[] | undefined;
    quantity: number;
    fromType: string | undefined;
    price: number;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number;
    orderNumber: number;
    barcode: string | undefined;
    auditStatus: number;
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    material3DUrl: string | undefined;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    organizationUnitId: number | undefined;
    pointRule: ProductPointRule;
}

export class CreateSkuInput implements ICreateSkuInput {
    productId!: number;
    sku_id!: string | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    title!: string | undefined;
    price!: number;
    price2!: number | undefined;
    promPrice!: number | undefined;
    salesVolume!: number;
    quantity!: number;
    picUrl!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    tags!: number[] | undefined;
    propertyValueIds!: number[] | undefined;
    starLevel!: number | undefined;
    keywords!: string | undefined;
    pointRule!: ProductPointRule;
    weight!: number | undefined;

    constructor(data?: ICreateSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku_id = _data["sku_id"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["propertyValueIds"])) {
                this.propertyValueIds = [] as any;
                for (let item of _data["propertyValueIds"])
                    this.propertyValueIds!.push(item);
            }
            this.starLevel = _data["starLevel"];
            this.keywords = _data["keywords"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku_id"] = this.sku_id;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.propertyValueIds)) {
            data["propertyValueIds"] = [];
            for (let item of this.propertyValueIds)
                data["propertyValueIds"].push(item);
        }
        data["starLevel"] = this.starLevel;
        data["keywords"] = this.keywords;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface ICreateSkuInput {
    productId: number;
    sku_id: string | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    title: string | undefined;
    price: number;
    price2: number | undefined;
    promPrice: number | undefined;
    salesVolume: number;
    quantity: number;
    picUrl: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    tags: number[] | undefined;
    propertyValueIds: number[] | undefined;
    starLevel: number | undefined;
    keywords: string | undefined;
    pointRule: ProductPointRule;
    weight: number | undefined;
}

export class GetProductsInput implements IGetProductsInput {
    currentProductId!: number;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    auditStatus!: AuditStatus;
    tagIds!: number[] | undefined;
    catetoryIds!: number[] | undefined;
    price1!: number | undefined;
    price2!: number | undefined;
    stock!: string | undefined;
    salesVolume!: string | undefined;
    sortStatus!: string | undefined;
    isSearchSku!: boolean | undefined;
    organizationId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    brandIds!: number[] | undefined;
    pointRedeemType!: RedeemType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetProductsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentProductId = _data["currentProductId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["catetoryIds"])) {
                this.catetoryIds = [] as any;
                for (let item of _data["catetoryIds"])
                    this.catetoryIds!.push(item);
            }
            this.price1 = _data["price1"];
            this.price2 = _data["price2"];
            this.stock = _data["stock"];
            this.salesVolume = _data["salesVolume"];
            this.sortStatus = _data["sortStatus"];
            this.isSearchSku = _data["isSearchSku"];
            this.organizationId = _data["organizationId"];
            this.language = _data["language"];
            this.region = _data["region"];
            if (Array.isArray(_data["brandIds"])) {
                this.brandIds = [] as any;
                for (let item of _data["brandIds"])
                    this.brandIds!.push(item);
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetProductsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentProductId"] = this.currentProductId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.catetoryIds)) {
            data["catetoryIds"] = [];
            for (let item of this.catetoryIds)
                data["catetoryIds"].push(item);
        }
        data["price1"] = this.price1;
        data["price2"] = this.price2;
        data["stock"] = this.stock;
        data["salesVolume"] = this.salesVolume;
        data["sortStatus"] = this.sortStatus;
        data["isSearchSku"] = this.isSearchSku;
        data["organizationId"] = this.organizationId;
        data["language"] = this.language;
        data["region"] = this.region;
        if (Array.isArray(this.brandIds)) {
            data["brandIds"] = [];
            for (let item of this.brandIds)
                data["brandIds"].push(item);
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetProductsInput {
    currentProductId: number;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    auditStatus: AuditStatus;
    tagIds: number[] | undefined;
    catetoryIds: number[] | undefined;
    price1: number | undefined;
    price2: number | undefined;
    stock: string | undefined;
    salesVolume: string | undefined;
    sortStatus: string | undefined;
    isSearchSku: boolean | undefined;
    organizationId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    brandIds: number[] | undefined;
    pointRedeemType: RedeemType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PublishSearchedProductInput implements IPublishSearchedProductInput {
    searchCondition!: GetProductsInput;
    ouOrDeviceOrStoreList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IPublishSearchedProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCondition = _data["searchCondition"] ? GetProductsInput.fromJS(_data["searchCondition"]) : <any>undefined;
            if (Array.isArray(_data["ouOrDeviceOrStoreList"])) {
                this.ouOrDeviceOrStoreList = [] as any;
                for (let item of _data["ouOrDeviceOrStoreList"])
                    this.ouOrDeviceOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): PublishSearchedProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishSearchedProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCondition"] = this.searchCondition ? this.searchCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.ouOrDeviceOrStoreList)) {
            data["ouOrDeviceOrStoreList"] = [];
            for (let item of this.ouOrDeviceOrStoreList)
                data["ouOrDeviceOrStoreList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IPublishSearchedProductInput {
    searchCondition: GetProductsInput;
    ouOrDeviceOrStoreList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
}

export class SetProductTagsDto implements ISetProductTagsDto {
    tagIds!: number[] | undefined;
    productIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetProductTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetProductTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetProductTagsDto {
    tagIds: number[] | undefined;
    productIds: number[] | undefined;
    action: string | undefined;
}

export class SetProductCategoryDto implements ISetProductCategoryDto {
    categoryIds!: number[] | undefined;
    productIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetProductCategoryDto {
    categoryIds: number[] | undefined;
    productIds: number[] | undefined;
    action: string | undefined;
}

export class SkuCodeDto implements ISkuCodeDto {
    id!: number;
    sku_id!: string | undefined;
    quantity!: number;
    propsName!: string | undefined;
    title!: string | undefined;
    price!: string | undefined;
    qrCodeUrl!: string | undefined;
    keywords!: string | undefined;
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    skuTags!: IdNameDto[] | undefined;
    skuCategories!: IdNameDto[] | undefined;
    isMine!: boolean;
    onlineStoreInfos!: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos!: SkuFileDto[] | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preSkuId!: number;
    nextSkuId!: number;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    productId!: number;

    constructor(data?: ISkuCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["skuCategories"])) {
                this.skuCategories = [] as any;
                for (let item of _data["skuCategories"])
                    this.skuCategories!.push(IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(SkuFileDto.fromJS(item));
            }
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preSkuId = _data["preSkuId"];
            this.nextSkuId = _data["nextSkuId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): SkuCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        if (Array.isArray(this.skuCategories)) {
            data["skuCategories"] = [];
            for (let item of this.skuCategories)
                data["skuCategories"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preSkuId"] = this.preSkuId;
        data["nextSkuId"] = this.nextSkuId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface ISkuCodeDto {
    id: number;
    sku_id: string | undefined;
    quantity: number;
    propsName: string | undefined;
    title: string | undefined;
    price: string | undefined;
    qrCodeUrl: string | undefined;
    keywords: string | undefined;
    auditStatus: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    orderNumber: number;
    skuTags: IdNameDto[] | undefined;
    skuCategories: IdNameDto[] | undefined;
    isMine: boolean;
    onlineStoreInfos: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos: SkuFileDto[] | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    barcode: string | undefined;
    starLevel: number | undefined;
    preSkuId: number;
    nextSkuId: number;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    productId: number;
}

export class GetSkuByCodeDto implements IGetSkuByCodeDto {
    id!: number;
    code!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    sku!: SkuCodeDto;
    isPurchased!: boolean;
    purchaseTime!: DateTime | undefined;

    constructor(data?: IGetSkuByCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.sku = _data["sku"] ? SkuCodeDto.fromJS(_data["sku"]) : <any>undefined;
            this.isPurchased = _data["isPurchased"];
            this.purchaseTime = _data["purchaseTime"] ? DateTime.fromISO(_data["purchaseTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSkuByCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSkuByCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["isPurchased"] = this.isPurchased;
        data["purchaseTime"] = this.purchaseTime ? this.purchaseTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetSkuByCodeDto {
    id: number;
    code: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    sku: SkuCodeDto;
    isPurchased: boolean;
    purchaseTime: DateTime | undefined;
}

export class GetProductPicturesInput implements IGetProductPicturesInput {
    idTypes!: IdTypeDto[] | undefined;

    constructor(data?: IGetProductPicturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["idTypes"])) {
                this.idTypes = [] as any;
                for (let item of _data["idTypes"])
                    this.idTypes!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductPicturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPicturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.idTypes)) {
            data["idTypes"] = [];
            for (let item of this.idTypes)
                data["idTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductPicturesInput {
    idTypes: IdTypeDto[] | undefined;
}

export class IdPicUrlDto implements IIdPicUrlDto {
    id!: number;
    picUrl!: string | undefined;
    category!: string | undefined;

    constructor(data?: IIdPicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.picUrl = _data["picUrl"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): IdPicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdPicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picUrl"] = this.picUrl;
        data["category"] = this.category;
        return data; 
    }
}

export interface IIdPicUrlDto {
    id: number;
    picUrl: string | undefined;
    category: string | undefined;
}

export class ItemIdTypeDto implements IItemIdTypeDto {
    itemId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IItemIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ItemIdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IItemIdTypeDto {
    itemId: string | undefined;
    type: string | undefined;
}

export class GetProductPicturesByItemIdInput implements IGetProductPicturesByItemIdInput {
    itemIdTypes!: ItemIdTypeDto[] | undefined;

    constructor(data?: IGetProductPicturesByItemIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIdTypes"])) {
                this.itemIdTypes = [] as any;
                for (let item of _data["itemIdTypes"])
                    this.itemIdTypes!.push(ItemIdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductPicturesByItemIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPicturesByItemIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIdTypes)) {
            data["itemIdTypes"] = [];
            for (let item of this.itemIdTypes)
                data["itemIdTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductPicturesByItemIdInput {
    itemIdTypes: ItemIdTypeDto[] | undefined;
}

export class ItemIdPicUrlDto implements IItemIdPicUrlDto {
    itemId!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IItemIdPicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): ItemIdPicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdPicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IItemIdPicUrlDto {
    itemId: string | undefined;
    picUrl: string | undefined;
}

export class OuterIdAndType implements IOuterIdAndType {
    outerId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IOuterIdAndType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OuterIdAndType {
        data = typeof data === 'object' ? data : {};
        let result = new OuterIdAndType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IOuterIdAndType {
    outerId: string | undefined;
    type: string | undefined;
}

export class GetProductIdAndName implements IGetProductIdAndName {
    outerIdAndTypes!: OuterIdAndType[] | undefined;

    constructor(data?: IGetProductIdAndName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["outerIdAndTypes"])) {
                this.outerIdAndTypes = [] as any;
                for (let item of _data["outerIdAndTypes"])
                    this.outerIdAndTypes!.push(OuterIdAndType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductIdAndName {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductIdAndName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.outerIdAndTypes)) {
            data["outerIdAndTypes"] = [];
            for (let item of this.outerIdAndTypes)
                data["outerIdAndTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductIdAndName {
    outerIdAndTypes: OuterIdAndType[] | undefined;
}

export class IdNameItemIdDto implements IIdNameItemIdDto {
    id!: number;
    name!: string | undefined;
    itemId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IIdNameItemIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.itemId = _data["itemId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdNameItemIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameItemIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["itemId"] = this.itemId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdNameItemIdDto {
    id: number;
    name: string | undefined;
    itemId: string | undefined;
    type: string | undefined;
}

export class ProductCommentDto implements IProductCommentDto {
    id!: number;
    userName!: string | undefined;
    starLevel!: number | undefined;
    avatorUrl!: string | undefined;
    content!: string | undefined;
    productId!: number;
    commentDateTime!: DateTime;
    orderNumber!: number;
    picUrl!: string | undefined;

    constructor(data?: IProductCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.starLevel = _data["starLevel"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.productId = _data["productId"];
            this.commentDateTime = _data["commentDateTime"] ? DateTime.fromISO(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): ProductCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["starLevel"] = this.starLevel;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["productId"] = this.productId;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IProductCommentDto {
    id: number;
    userName: string | undefined;
    starLevel: number | undefined;
    avatorUrl: string | undefined;
    content: string | undefined;
    productId: number;
    commentDateTime: DateTime;
    orderNumber: number;
    picUrl: string | undefined;
}

export class PagedResultDtoOfProductCommentDto implements IPagedResultDtoOfProductCommentDto {
    totalCount!: number;
    items!: ProductCommentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCommentDto {
    totalCount: number;
    items: ProductCommentDto[] | undefined;
}

export class UpdateProductCommentInput implements IUpdateProductCommentInput {
    id!: number;
    userName!: string | undefined;
    avatorUrl!: string | undefined;
    content!: string | undefined;
    commentDateTime!: DateTime | undefined;
    orderNumber!: number;

    constructor(data?: IUpdateProductCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.commentDateTime = _data["commentDateTime"] ? DateTime.fromISO(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateProductCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateProductCommentInput {
    id: number;
    userName: string | undefined;
    avatorUrl: string | undefined;
    content: string | undefined;
    commentDateTime: DateTime | undefined;
    orderNumber: number;
}

export class PagedResultDtoOfProductOnlineStoreInfoDto implements IPagedResultDtoOfProductOnlineStoreInfoDto {
    totalCount!: number;
    items!: ProductOnlineStoreInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductOnlineStoreInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductOnlineStoreInfoDto {
    totalCount: number;
    items: ProductOnlineStoreInfoDto[] | undefined;
}

export class CreateProductOnlineInfoInput implements ICreateProductOnlineInfoInput {
    productId!: number;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    pid!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: ICreateProductOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): CreateProductOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ICreateProductOnlineInfoInput {
    productId: number;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    pid: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class UpdateProductOnlineInfoInput implements IUpdateProductOnlineInfoInput {
    id!: number;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    pid!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: IUpdateProductOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): UpdateProductOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IUpdateProductOnlineInfoInput {
    id: number;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    pid: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class PagedResultDtoOfSkuFileDto implements IPagedResultDtoOfSkuFileDto {
    totalCount!: number;
    items!: SkuFileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSkuFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSkuFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSkuFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSkuFileDto {
    totalCount: number;
    items: SkuFileDto[] | undefined;
}

export class CreateSkuResourceInput implements ICreateSkuResourceInput {
    fileUrl!: string;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    skuId!: number;
    fromType!: string | undefined;

    constructor(data?: ICreateSkuResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.skuId = _data["skuId"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateSkuResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["skuId"] = this.skuId;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateSkuResourceInput {
    fileUrl: string;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    skuId: number;
    fromType: string | undefined;
}

export class PagedResultDtoOfSkuOnlineStoreInfoDto implements IPagedResultDtoOfSkuOnlineStoreInfoDto {
    totalCount!: number;
    items!: SkuOnlineStoreInfoDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSkuOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSkuOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSkuOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSkuOnlineStoreInfoDto {
    totalCount: number;
    items: SkuOnlineStoreInfoDto[] | undefined;
}

export class CreateSkuOnlineInfoInput implements ICreateSkuOnlineInfoInput {
    skuId!: number;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    sku_ID!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: ICreateSkuOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): CreateSkuOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ICreateSkuOnlineInfoInput {
    skuId: number;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    sku_ID: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class UpdateSkuOnlineInfoInput implements IUpdateSkuOnlineInfoInput {
    id!: number;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    sku_ID!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;

    constructor(data?: IUpdateSkuOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): UpdateSkuOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IUpdateSkuOnlineInfoInput {
    id: number;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    sku_ID: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
}

export class ProductPropertyDto implements IProductPropertyDto {
    propertyId!: number;
    propertyName!: string | undefined;
    isForSale!: boolean;
    isDefaultDecideImage!: boolean;
    propertyValues!: PropertyValueDto[] | undefined;

    constructor(data?: IProductPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.isForSale = _data["isForSale"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["isForSale"] = this.isForSale;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductPropertyDto {
    propertyId: number;
    propertyName: string | undefined;
    isForSale: boolean;
    isDefaultDecideImage: boolean;
    propertyValues: PropertyValueDto[] | undefined;
}

export class IdAndTotalCount implements IIdAndTotalCount {
    id!: number;
    totalCount!: number;

    constructor(data?: IIdAndTotalCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdAndTotalCount {
        data = typeof data === 'object' ? data : {};
        let result = new IdAndTotalCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IIdAndTotalCount {
    id: number;
    totalCount: number;
}

export class ProductCategoryDto implements IProductCategoryDto {
    organizationUnitId!: number | undefined;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number | undefined;
    parentCategoryName!: string | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductCategoryDto {
    organizationUnitId: number | undefined;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number | undefined;
    parentCategoryName: string | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfProductCategoryDto implements IPagedResultDtoOfProductCategoryDto {
    totalCount!: number;
    items!: ProductCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategoryDto {
    totalCount: number;
    items: ProductCategoryDto[] | undefined;
}

export class CreateProductCategoryInput implements ICreateProductCategoryInput {
    categoryCode!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: ICreateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateProductCategoryInput {
    categoryCode: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class UpdateProductCategoryInput implements IUpdateProductCategoryInput {
    id!: number;
    categoryCode!: string | undefined;
    name!: string;
    parentCategoryId!: number | undefined;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IUpdateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): UpdateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IUpdateProductCategoryInput {
    id: number;
    categoryCode: string | undefined;
    name: string;
    parentCategoryId: number | undefined;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class ProductCategoryTreeItemDto implements IProductCategoryTreeItemDto {
    iconUrl!: string | undefined;
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    imageUrl!: string | undefined;
    productCount!: number;
    children!: ProductCategoryTreeItemDto[] | undefined;

    constructor(data?: IProductCategoryTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconUrl = _data["iconUrl"];
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            this.imageUrl = _data["imageUrl"];
            this.productCount = _data["productCount"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ProductCategoryTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconUrl"] = this.iconUrl;
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        data["imageUrl"] = this.imageUrl;
        data["productCount"] = this.productCount;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCategoryTreeItemDto {
    iconUrl: string | undefined;
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    imageUrl: string | undefined;
    productCount: number;
    children: ProductCategoryTreeItemDto[] | undefined;
}

export class AddOrUpdateProductCategoryInput implements IAddOrUpdateProductCategoryInput {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    parentCode!: string | undefined;
    code!: string | undefined;
    name!: string;
    picUrl!: string | undefined;
    sortOrder!: number;
    fromType!: string | undefined;

    constructor(data?: IAddOrUpdateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
            this.sortOrder = _data["sortOrder"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): AddOrUpdateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["sortOrder"] = this.sortOrder;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IAddOrUpdateProductCategoryInput {
    tenantId: number;
    organizationUnitId: number | undefined;
    parentCode: string | undefined;
    code: string | undefined;
    name: string;
    picUrl: string | undefined;
    sortOrder: number;
    fromType: string | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string | undefined;
    x!: number;
    y!: number;
    width!: number;
    height!: number;
    useGravatarProfilePicture!: boolean;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileToken = _data["fileToken"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
    useGravatarProfilePicture: boolean;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum PromotionTypeEnum {
    InShop = 0,
    InGroup = 1,
    InProduct = 2,
}

export enum DiscountType {
    Voucher = 0,
    Discount = 1,
}

export class AddOrUpdatePromotionInput implements IAddOrUpdatePromotionInput {
    id!: number | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    attribute!: any | undefined;
    otherNeed!: string | undefined;
    otherSend!: string | undefined;
    fromType!: string | undefined;
    promotionType!: PromotionTypeEnum;
    discountType!: DiscountType;
    discountAmount!: number | undefined;

    constructor(data?: IAddOrUpdatePromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.attribute = _data["attribute"];
            this.otherNeed = _data["otherNeed"];
            this.otherSend = _data["otherSend"];
            this.fromType = _data["fromType"];
            this.promotionType = _data["promotionType"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): AddOrUpdatePromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdatePromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["attribute"] = this.attribute;
        data["otherNeed"] = this.otherNeed;
        data["otherSend"] = this.otherSend;
        data["fromType"] = this.fromType;
        data["promotionType"] = this.promotionType;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        return data; 
    }
}

export interface IAddOrUpdatePromotionInput {
    id: number | undefined;
    outerId: string | undefined;
    name: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    attribute: any | undefined;
    otherNeed: string | undefined;
    otherSend: string | undefined;
    fromType: string | undefined;
    promotionType: PromotionTypeEnum;
    discountType: DiscountType;
    discountAmount: number | undefined;
}

export class GetPromotioDto implements IGetPromotioDto {
    id!: number;
    outerId!: string | undefined;
    name!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    attribute!: any | undefined;
    otherNeed!: string | undefined;
    otherSend!: string | undefined;
    fromType!: string | undefined;
    promotionType!: PromotionTypeEnum;
    discountType!: DiscountType;
    discountAmount!: number | undefined;

    constructor(data?: IGetPromotioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.attribute = _data["attribute"];
            this.otherNeed = _data["otherNeed"];
            this.otherSend = _data["otherSend"];
            this.fromType = _data["fromType"];
            this.promotionType = _data["promotionType"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): GetPromotioDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPromotioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["attribute"] = this.attribute;
        data["otherNeed"] = this.otherNeed;
        data["otherSend"] = this.otherSend;
        data["fromType"] = this.fromType;
        data["promotionType"] = this.promotionType;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        return data; 
    }
}

export interface IGetPromotioDto {
    id: number;
    outerId: string | undefined;
    name: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    attribute: any | undefined;
    otherNeed: string | undefined;
    otherSend: string | undefined;
    fromType: string | undefined;
    promotionType: PromotionTypeEnum;
    discountType: DiscountType;
    discountAmount: number | undefined;
}

export class PagedResultDtoOfGetPromotioDto implements IPagedResultDtoOfGetPromotioDto {
    totalCount!: number;
    items!: GetPromotioDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPromotioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPromotioDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPromotioDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPromotioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetPromotioDto {
    totalCount: number;
    items: GetPromotioDto[] | undefined;
}

export class ProductPromotionInput implements IProductPromotionInput {
    productId!: number;
    discountType!: DiscountType;
    discountValue!: number | undefined;

    constructor(data?: IProductPromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
        }
    }

    static fromJS(data: any): ProductPromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        return data; 
    }
}

export interface IProductPromotionInput {
    productId: number;
    discountType: DiscountType;
    discountValue: number | undefined;
}

export class AddOrUpdateProductsToPromotionInput implements IAddOrUpdateProductsToPromotionInput {
    promotionId!: number;
    productPromotionInputs!: ProductPromotionInput[] | undefined;

    constructor(data?: IAddOrUpdateProductsToPromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            if (Array.isArray(_data["productPromotionInputs"])) {
                this.productPromotionInputs = [] as any;
                for (let item of _data["productPromotionInputs"])
                    this.productPromotionInputs!.push(ProductPromotionInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateProductsToPromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductsToPromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        if (Array.isArray(this.productPromotionInputs)) {
            data["productPromotionInputs"] = [];
            for (let item of this.productPromotionInputs)
                data["productPromotionInputs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateProductsToPromotionInput {
    promotionId: number;
    productPromotionInputs: ProductPromotionInput[] | undefined;
}

export class GetProductPromotionDto implements IGetProductPromotionDto {
    id!: number;
    product!: ProductDto;
    discountType!: DiscountType;
    discountValue!: number;
    price!: number;

    constructor(data?: IGetProductPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): GetProductPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["price"] = this.price;
        return data; 
    }
}

export interface IGetProductPromotionDto {
    id: number;
    product: ProductDto;
    discountType: DiscountType;
    discountValue: number;
    price: number;
}

export class PagedResultDtoOfGetProductPromotionDto implements IPagedResultDtoOfGetProductPromotionDto {
    totalCount!: number;
    items!: GetProductPromotionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetProductPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProductPromotionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetProductPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetProductPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetProductPromotionDto {
    totalCount: number;
    items: GetProductPromotionDto[] | undefined;
}

export class PagedResultDtoOfPropertyDto implements IPagedResultDtoOfPropertyDto {
    totalCount!: number;
    items!: PropertyDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPropertyDto {
    totalCount: number;
    items: PropertyDto[] | undefined;
}

export class CreatePropertyInput implements ICreatePropertyInput {
    orderNumber!: number;
    name!: string;
    isDefaultDecideImage!: boolean;
    isForSale!: boolean;
    fromType!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreatePropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreatePropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreatePropertyInput {
    orderNumber: number;
    name: string;
    isDefaultDecideImage: boolean;
    isForSale: boolean;
    fromType: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class UpdatePropertyInput implements IUpdatePropertyInput {
    id!: number;
    orderNumber!: number;
    name!: string;
    isDefaultDecideImage!: boolean;
    isForSale!: boolean;
    fromType!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdatePropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdatePropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdatePropertyInput {
    id: number;
    orderNumber: number;
    name: string;
    isDefaultDecideImage: boolean;
    isForSale: boolean;
    fromType: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class PagedResultDtoOfPropertyValueDto implements IPagedResultDtoOfPropertyValueDto {
    totalCount!: number;
    items!: PropertyValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPropertyValueDto {
    totalCount: number;
    items: PropertyValueDto[] | undefined;
}

export class CreatePropertyValueInput implements ICreatePropertyValueInput {
    orderNumber!: number;
    propertyId!: number;
    value!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreatePropertyValueInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreatePropertyValueInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyValueInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreatePropertyValueInput {
    orderNumber: number;
    propertyId: number;
    value: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class UpdatePropertyValueInput implements IUpdatePropertyValueInput {
    id!: number;
    orderNumber!: number;
    propertyId!: number;
    value!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdatePropertyValueInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdatePropertyValueInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePropertyValueInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdatePropertyValueInput {
    id: number;
    orderNumber: number;
    propertyId: number;
    value: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class NameValueTimeDto implements INameValueTimeDto {
    seconds!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seconds = _data["seconds"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seconds"] = this.seconds;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueTimeDto {
    seconds: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class GetCountReportInput implements IGetCountReportInput {
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    storeOrOuList!: IdTypeDto[] | undefined;

    constructor(data?: IGetCountReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["storeOrOuList"])) {
                this.storeOrOuList = [] as any;
                for (let item of _data["storeOrOuList"])
                    this.storeOrOuList!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCountReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        if (Array.isArray(this.storeOrOuList)) {
            data["storeOrOuList"] = [];
            for (let item of this.storeOrOuList)
                data["storeOrOuList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetCountReportInput {
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    storeOrOuList: IdTypeDto[] | undefined;
}

export class ResourceFileDto implements IResourceFileDto {
    name!: string;
    fileUrl!: string;
    content!: string | undefined;
    type!: FileType;
    typeString!: string | undefined;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    size!: number;
    orderNumber!: number;
    width!: number | undefined;
    height!: number | undefined;
    thumbnailUrl!: string | undefined;
    category!: string | undefined;
    resourceTags!: IdNameDto[] | undefined;
    md5!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IResourceFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.typeString = _data["typeString"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.size = _data["size"];
            this.orderNumber = _data["orderNumber"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.category = _data["category"];
            if (Array.isArray(_data["resourceTags"])) {
                this.resourceTags = [] as any;
                for (let item of _data["resourceTags"])
                    this.resourceTags!.push(IdNameDto.fromJS(item));
            }
            this.md5 = _data["md5"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ResourceFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["content"] = this.content;
        data["type"] = this.type;
        data["typeString"] = this.typeString;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["size"] = this.size;
        data["orderNumber"] = this.orderNumber;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["category"] = this.category;
        if (Array.isArray(this.resourceTags)) {
            data["resourceTags"] = [];
            for (let item of this.resourceTags)
                data["resourceTags"].push(item.toJSON());
        }
        data["md5"] = this.md5;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IResourceFileDto {
    name: string;
    fileUrl: string;
    content: string | undefined;
    type: FileType;
    typeString: string | undefined;
    tenantId: number;
    organizationUnitId: number | undefined;
    size: number;
    orderNumber: number;
    width: number | undefined;
    height: number | undefined;
    thumbnailUrl: string | undefined;
    category: string | undefined;
    resourceTags: IdNameDto[] | undefined;
    md5: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfResourceFileDto implements IPagedResultDtoOfResourceFileDto {
    totalCount!: number;
    items!: ResourceFileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfResourceFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResourceFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfResourceFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfResourceFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfResourceFileDto {
    totalCount: number;
    items: ResourceFileDto[] | undefined;
}

export class CreateResourceFileInput implements ICreateResourceFileInput {
    name!: string;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    fileUrl!: string;
    content!: string | undefined;
    type!: FileType;
    size!: number;
    orderNumber!: number;
    width!: number | undefined;
    height!: number | undefined;
    thumbnailUrl!: string | undefined;
    category!: string | undefined;
    tags!: number[] | undefined;
    md5!: string | undefined;

    constructor(data?: ICreateResourceFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.fileUrl = _data["fileUrl"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.size = _data["size"];
            this.orderNumber = _data["orderNumber"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.category = _data["category"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.md5 = _data["md5"];
        }
    }

    static fromJS(data: any): CreateResourceFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResourceFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["fileUrl"] = this.fileUrl;
        data["content"] = this.content;
        data["type"] = this.type;
        data["size"] = this.size;
        data["orderNumber"] = this.orderNumber;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["category"] = this.category;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["md5"] = this.md5;
        return data; 
    }
}

export interface ICreateResourceFileInput {
    name: string;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    fileUrl: string;
    content: string | undefined;
    type: FileType;
    size: number;
    orderNumber: number;
    width: number | undefined;
    height: number | undefined;
    thumbnailUrl: string | undefined;
    category: string | undefined;
    tags: number[] | undefined;
    md5: string | undefined;
}

export class UpdateResourceFileInput implements IUpdateResourceFileInput {
    id!: number;
    name!: string;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    fileUrl!: string;
    content!: string | undefined;
    type!: FileType;
    size!: number;
    orderNumber!: number;
    width!: number | undefined;
    height!: number | undefined;
    thumbnailUrl!: string | undefined;
    category!: string | undefined;
    tags!: number[] | undefined;
    md5!: string | undefined;

    constructor(data?: IUpdateResourceFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.fileUrl = _data["fileUrl"];
            this.content = _data["content"];
            this.type = _data["type"];
            this.size = _data["size"];
            this.orderNumber = _data["orderNumber"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.category = _data["category"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.md5 = _data["md5"];
        }
    }

    static fromJS(data: any): UpdateResourceFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResourceFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["fileUrl"] = this.fileUrl;
        data["content"] = this.content;
        data["type"] = this.type;
        data["size"] = this.size;
        data["orderNumber"] = this.orderNumber;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["category"] = this.category;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["md5"] = this.md5;
        return data; 
    }
}

export interface IUpdateResourceFileInput {
    id: number;
    name: string;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    fileUrl: string;
    content: string | undefined;
    type: FileType;
    size: number;
    orderNumber: number;
    width: number | undefined;
    height: number | undefined;
    thumbnailUrl: string | undefined;
    category: string | undefined;
    tags: number[] | undefined;
    md5: string | undefined;
}

export class SetResourceTagsDto implements ISetResourceTagsDto {
    tagIds!: number[] | undefined;
    resourceIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetResourceTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["resourceIds"])) {
                this.resourceIds = [] as any;
                for (let item of _data["resourceIds"])
                    this.resourceIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetResourceTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetResourceTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.resourceIds)) {
            data["resourceIds"] = [];
            for (let item of this.resourceIds)
                data["resourceIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetResourceTagsDto {
    tagIds: number[] | undefined;
    resourceIds: number[] | undefined;
    action: string | undefined;
}

export class GetRolesInput implements IGetRolesInput {
    permissions!: string[] | undefined;

    constructor(data?: IGetRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface IGetRolesInput {
    permissions: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: DateTime;
    id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class RegisterDeviceInput implements IRegisterDeviceInput {
    name!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    mac!: string | undefined;
    address!: string | undefined;
    deviceTypeId!: number;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    resolution_Width!: number;
    resolution_Height!: number;
    os!: string | undefined;

    constructor(data?: IRegisterDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.mac = _data["mac"];
            this.address = _data["address"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.os = _data["os"];
        }
    }

    static fromJS(data: any): RegisterDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["mac"] = this.mac;
        data["address"] = this.address;
        data["deviceTypeId"] = this.deviceTypeId;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["os"] = this.os;
        return data; 
    }
}

export interface IRegisterDeviceInput {
    name: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    mac: string | undefined;
    address: string | undefined;
    deviceTypeId: number;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    resolution_Width: number;
    resolution_Height: number;
    os: string | undefined;
}

export class DeviceExtraOutput implements IDeviceExtraOutput {
    platformType!: ExternalEnum;
    extraDeviceId!: string | undefined;

    constructor(data?: IDeviceExtraOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformType = _data["platformType"];
            this.extraDeviceId = _data["extraDeviceId"];
        }
    }

    static fromJS(data: any): DeviceExtraOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceExtraOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformType"] = this.platformType;
        data["extraDeviceId"] = this.extraDeviceId;
        return data; 
    }
}

export interface IDeviceExtraOutput {
    platformType: ExternalEnum;
    extraDeviceId: string | undefined;
}

export class DeviceOutput implements IDeviceOutput {
    id!: number;
    name!: string | undefined;
    mac!: string | undefined;
    operatingType!: OperatingType;
    isLocked!: boolean;
    deviceTypeName!: string | undefined;
    address!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    isRegistered!: boolean;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    shutdownTime!: DateTime | undefined;
    resolution_Width!: number;
    resolution_Height!: number;
    subKey!: string | undefined;
    os!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    tenantName!: string | undefined;
    tenantId!: number;
    organizationUnitName!: string | undefined;
    organizationUnitId!: number;
    storeId!: number;
    storeOuterId!: string | undefined;
    storeName!: string | undefined;
    outType!: string | undefined;
    taobaoDeviceId!: string | undefined;
    deviceOuterId!: string | undefined;
    osType!: OsTypeEnum;
    extras!: DeviceExtraOutput[] | undefined;
    shopUrl!: string | undefined;

    constructor(data?: IDeviceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.operatingType = _data["operatingType"];
            this.isLocked = _data["isLocked"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.isRegistered = _data["isRegistered"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.shutdownTime = _data["shutdownTime"] ? DateTime.fromISO(_data["shutdownTime"].toString()) : <any>undefined;
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.subKey = _data["subKey"];
            this.os = _data["os"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeName = _data["storeName"];
            this.outType = _data["outType"];
            this.taobaoDeviceId = _data["taobaoDeviceId"];
            this.deviceOuterId = _data["deviceOuterId"];
            this.osType = _data["osType"];
            if (Array.isArray(_data["extras"])) {
                this.extras = [] as any;
                for (let item of _data["extras"])
                    this.extras!.push(DeviceExtraOutput.fromJS(item));
            }
            this.shopUrl = _data["shopUrl"];
        }
    }

    static fromJS(data: any): DeviceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["operatingType"] = this.operatingType;
        data["isLocked"] = this.isLocked;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["isRegistered"] = this.isRegistered;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toString() : <any>undefined;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["subKey"] = this.subKey;
        data["os"] = this.os;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storeName"] = this.storeName;
        data["outType"] = this.outType;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["deviceOuterId"] = this.deviceOuterId;
        data["osType"] = this.osType;
        if (Array.isArray(this.extras)) {
            data["extras"] = [];
            for (let item of this.extras)
                data["extras"].push(item.toJSON());
        }
        data["shopUrl"] = this.shopUrl;
        return data; 
    }
}

export interface IDeviceOutput {
    id: number;
    name: string | undefined;
    mac: string | undefined;
    operatingType: OperatingType;
    isLocked: boolean;
    deviceTypeName: string | undefined;
    address: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    isRegistered: boolean;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    shutdownTime: DateTime | undefined;
    resolution_Width: number;
    resolution_Height: number;
    subKey: string | undefined;
    os: string | undefined;
    onlineTrafficTarget: string | undefined;
    tenantName: string | undefined;
    tenantId: number;
    organizationUnitName: string | undefined;
    organizationUnitId: number;
    storeId: number;
    storeOuterId: string | undefined;
    storeName: string | undefined;
    outType: string | undefined;
    taobaoDeviceId: string | undefined;
    deviceOuterId: string | undefined;
    osType: OsTypeEnum;
    extras: DeviceExtraOutput[] | undefined;
    shopUrl: string | undefined;
}

export class PriceTagIntegrationWithSubkeyInput implements IPriceTagIntegrationWithSubkeyInput {
    subkey!: string | undefined;
    skuIds!: number[] | undefined;
    command!: string | undefined;

    constructor(data?: IPriceTagIntegrationWithSubkeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.command = _data["command"];
        }
    }

    static fromJS(data: any): PriceTagIntegrationWithSubkeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTagIntegrationWithSubkeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["command"] = this.command;
        return data; 
    }
}

export interface IPriceTagIntegrationWithSubkeyInput {
    subkey: string | undefined;
    skuIds: number[] | undefined;
    command: string | undefined;
}

export class UpdateDeviceStatusInput implements IUpdateDeviceStatusInput {
    deviceTypes!: number[] | undefined;
    timeSpan!: number;
    sign!: string | undefined;
    status!: DeviceStatus;

    constructor(data?: IUpdateDeviceStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceTypes"])) {
                this.deviceTypes = [] as any;
                for (let item of _data["deviceTypes"])
                    this.deviceTypes!.push(item);
            }
            this.timeSpan = _data["timeSpan"];
            this.sign = _data["sign"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateDeviceStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceTypes)) {
            data["deviceTypes"] = [];
            for (let item of this.deviceTypes)
                data["deviceTypes"].push(item);
        }
        data["timeSpan"] = this.timeSpan;
        data["sign"] = this.sign;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateDeviceStatusInput {
    deviceTypes: number[] | undefined;
    timeSpan: number;
    sign: string | undefined;
    status: DeviceStatus;
}

export class DeviceHeartBeatInput implements IDeviceHeartBeatInput {
    cpuUsaged!: number | undefined;
    memoryUsaged!: number | undefined;

    constructor(data?: IDeviceHeartBeatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cpuUsaged = _data["cpuUsaged"];
            this.memoryUsaged = _data["memoryUsaged"];
        }
    }

    static fromJS(data: any): DeviceHeartBeatInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceHeartBeatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpuUsaged"] = this.cpuUsaged;
        data["memoryUsaged"] = this.memoryUsaged;
        return data; 
    }
}

export interface IDeviceHeartBeatInput {
    cpuUsaged: number | undefined;
    memoryUsaged: number | undefined;
}

export class TenantAndOrganizationUnitAndStoreOutput implements ITenantAndOrganizationUnitAndStoreOutput {
    tenantId!: number;
    tenantName!: string | undefined;
    organizationUnitId!: number | undefined;
    organizationUnitName!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;

    constructor(data?: ITenantAndOrganizationUnitAndStoreOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
        }
    }

    static fromJS(data: any): TenantAndOrganizationUnitAndStoreOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAndOrganizationUnitAndStoreOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        return data; 
    }
}

export interface ITenantAndOrganizationUnitAndStoreOutput {
    tenantId: number;
    tenantName: string | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
}

export class TenantAppSdkSetting implements ITenantAppSdkSetting {
    alias!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    extensionData!: string | undefined;
    materialPacketUrl!: string | undefined;
    isDefault!: boolean;

    constructor(data?: ITenantAppSdkSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): TenantAppSdkSetting {
        data = typeof data === 'object' ? data : {};
        let result = new TenantAppSdkSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ITenantAppSdkSetting {
    alias: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    extensionData: string | undefined;
    materialPacketUrl: string | undefined;
    isDefault: boolean;
}

export class SoftwareSdkModel implements ISoftwareSdkModel {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    owner!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    versionNumber!: string | undefined;
    packageUrl!: string | undefined;
    type!: string | undefined;
    envType!: string | undefined;
    description!: string | undefined;
    language!: string | undefined;
    exePath!: string | undefined;
    extensionData!: string | undefined;
    gameType!: string | undefined;
    setting!: string | undefined;
    url!: string | undefined;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;

    constructor(data?: ISoftwareSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.owner = _data["owner"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.type = _data["type"];
            this.envType = _data["envType"];
            this.description = _data["description"];
            this.language = _data["language"];
            this.exePath = _data["exePath"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.setting = _data["setting"];
            this.url = _data["url"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
        }
    }

    static fromJS(data: any): SoftwareSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["owner"] = this.owner;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["type"] = this.type;
        data["envType"] = this.envType;
        data["description"] = this.description;
        data["language"] = this.language;
        data["exePath"] = this.exePath;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["setting"] = this.setting;
        data["url"] = this.url;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        return data; 
    }
}

export interface ISoftwareSdkModel {
    id: number;
    name: string | undefined;
    code: string | undefined;
    owner: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    versionNumber: string | undefined;
    packageUrl: string | undefined;
    type: string | undefined;
    envType: string | undefined;
    description: string | undefined;
    language: string | undefined;
    exePath: string | undefined;
    extensionData: string | undefined;
    gameType: string | undefined;
    setting: string | undefined;
    url: string | undefined;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
}

export class DeviceSoftwareSdkModel implements IDeviceSoftwareSdkModel {
    id!: number;
    deviceId!: number;
    tenantAppSetting!: TenantAppSdkSetting;
    software!: SoftwareSdkModel;
    isDefault!: boolean;
    materialPacketUrl!: string | undefined;
    alias!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IDeviceSoftwareSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.tenantAppSetting = _data["tenantAppSetting"] ? TenantAppSdkSetting.fromJS(_data["tenantAppSetting"]) : <any>undefined;
            this.software = _data["software"] ? SoftwareSdkModel.fromJS(_data["software"]) : <any>undefined;
            this.isDefault = _data["isDefault"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.alias = _data["alias"];
            this.extensionData = _data["extensionData"];
        }
    }

    static fromJS(data: any): DeviceSoftwareSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSoftwareSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["tenantAppSetting"] = this.tenantAppSetting ? this.tenantAppSetting.toJSON() : <any>undefined;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["alias"] = this.alias;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IDeviceSoftwareSdkModel {
    id: number;
    deviceId: number;
    tenantAppSetting: TenantAppSdkSetting;
    software: SoftwareSdkModel;
    isDefault: boolean;
    materialPacketUrl: string | undefined;
    alias: string | undefined;
    extensionData: string | undefined;
}

export class PagedResultDtoOfDeviceSoftwareSdkModel implements IPagedResultDtoOfDeviceSoftwareSdkModel {
    totalCount!: number;
    items!: DeviceSoftwareSdkModel[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceSoftwareSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSoftwareSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceSoftwareSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceSoftwareSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceSoftwareSdkModel {
    totalCount: number;
    items: DeviceSoftwareSdkModel[] | undefined;
}

export class ProductDecideImageViewModel implements IProductDecideImageViewModel {
    propertyName!: string | undefined;
    imageUrl!: string | undefined;

    constructor(data?: IProductDecideImageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): ProductDecideImageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDecideImageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IProductDecideImageViewModel {
    propertyName: string | undefined;
    imageUrl: string | undefined;
}

export class OnlineStoreInfoViewModel implements IOnlineStoreInfoViewModel {
    onlineStoreName!: string | undefined;
    qrcode!: string | undefined;
    skuId!: number;
    sku_Id!: string | undefined;

    constructor(data?: IOnlineStoreInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlineStoreName = _data["onlineStoreName"];
            this.qrcode = _data["qrcode"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
        }
    }

    static fromJS(data: any): OnlineStoreInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OnlineStoreInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlineStoreName"] = this.onlineStoreName;
        data["qrcode"] = this.qrcode;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        return data; 
    }
}

export interface IOnlineStoreInfoViewModel {
    onlineStoreName: string | undefined;
    qrcode: string | undefined;
    skuId: number;
    sku_Id: string | undefined;
}

export class EntityFileSdkModel implements IEntityFileSdkModel {
    id!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    fromType!: string | undefined;
    type!: string | undefined;
    content!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    md5!: string | undefined;

    constructor(data?: IEntityFileSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.content = _data["content"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.md5 = _data["md5"];
        }
    }

    static fromJS(data: any): EntityFileSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFileSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["content"] = this.content;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["md5"] = this.md5;
        return data; 
    }
}

export interface IEntityFileSdkModel {
    id: number;
    name: string | undefined;
    fileUrl: string | undefined;
    fromType: string | undefined;
    type: string | undefined;
    content: string | undefined;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    md5: string | undefined;
}

export class SkuSdkModel implements ISkuSdkModel {
    id!: number;
    skuId!: string | undefined;
    quantity!: number;
    barcode!: string | undefined;
    propsName!: string | undefined;
    propValueIds!: number[] | undefined;
    title!: string | undefined;
    price!: number;
    promPrice!: number;
    salesVolume!: number;
    likeCount!: number;
    keywords!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    outerId!: string | undefined;
    orderNumber!: number;
    tagIds!: number[] | undefined;
    fromType!: string | undefined;
    colorName!: string | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    weight!: number | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: ISkuSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.quantity = _data["quantity"];
            this.barcode = _data["barcode"];
            this.propsName = _data["propsName"];
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.likeCount = _data["likeCount"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.outerId = _data["outerId"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.fromType = _data["fromType"];
            this.colorName = _data["colorName"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["quantity"] = this.quantity;
        data["barcode"] = this.barcode;
        data["propsName"] = this.propsName;
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["likeCount"] = this.likeCount;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["outerId"] = this.outerId;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["fromType"] = this.fromType;
        data["colorName"] = this.colorName;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["weight"] = this.weight;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISkuSdkModel {
    id: number;
    skuId: string | undefined;
    quantity: number;
    barcode: string | undefined;
    propsName: string | undefined;
    propValueIds: number[] | undefined;
    title: string | undefined;
    price: number;
    promPrice: number;
    salesVolume: number;
    likeCount: number;
    keywords: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    outerId: string | undefined;
    orderNumber: number;
    tagIds: number[] | undefined;
    fromType: string | undefined;
    colorName: string | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    weight: number | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class ProductSdkModel implements IProductSdkModel {
    id!: number;
    itemId!: string | undefined;
    quantity!: number;
    title!: string | undefined;
    organizationUnitId!: number | undefined;
    subTitle!: string | undefined;
    price!: number;
    promPrice!: number;
    barcode!: string | undefined;
    salesVolume!: number;
    keywords!: string | undefined;
    picUrl!: string | undefined;
    likeCount!: number;
    description!: string | undefined;
    isFromBrand!: boolean;
    sellerId!: string | undefined;
    outerId!: string | undefined;
    fromType!: string | undefined;
    hasRealSkus!: boolean;
    propImgs!: ProductDecideImageViewModel[] | undefined;
    categoryIds!: number[] | undefined;
    propValueIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    skus!: SkuSdkModel[] | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    groupQrCodeInfo!: string | undefined;
    orderNumber!: number;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProductSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isFromBrand = _data["isFromBrand"];
            this.sellerId = _data["sellerId"];
            this.outerId = _data["outerId"];
            this.fromType = _data["fromType"];
            this.hasRealSkus = _data["hasRealSkus"];
            if (Array.isArray(_data["propImgs"])) {
                this.propImgs = [] as any;
                for (let item of _data["propImgs"])
                    this.propImgs!.push(ProductDecideImageViewModel.fromJS(item));
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.groupQrCodeInfo = _data["groupQrCodeInfo"];
            this.orderNumber = _data["orderNumber"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["organizationUnitId"] = this.organizationUnitId;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isFromBrand"] = this.isFromBrand;
        data["sellerId"] = this.sellerId;
        data["outerId"] = this.outerId;
        data["fromType"] = this.fromType;
        data["hasRealSkus"] = this.hasRealSkus;
        if (Array.isArray(this.propImgs)) {
            data["propImgs"] = [];
            for (let item of this.propImgs)
                data["propImgs"].push(item.toJSON());
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["groupQrCodeInfo"] = this.groupQrCodeInfo;
        data["orderNumber"] = this.orderNumber;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductSdkModel {
    id: number;
    itemId: string | undefined;
    quantity: number;
    title: string | undefined;
    organizationUnitId: number | undefined;
    subTitle: string | undefined;
    price: number;
    promPrice: number;
    barcode: string | undefined;
    salesVolume: number;
    keywords: string | undefined;
    picUrl: string | undefined;
    likeCount: number;
    description: string | undefined;
    isFromBrand: boolean;
    sellerId: string | undefined;
    outerId: string | undefined;
    fromType: string | undefined;
    hasRealSkus: boolean;
    propImgs: ProductDecideImageViewModel[] | undefined;
    categoryIds: number[] | undefined;
    propValueIds: number[] | undefined;
    tagIds: number[] | undefined;
    skus: SkuSdkModel[] | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    groupQrCodeInfo: string | undefined;
    orderNumber: number;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class PagedResultDtoOfProductSdkModel implements IPagedResultDtoOfProductSdkModel {
    totalCount!: number;
    items!: ProductSdkModel[] | undefined;

    constructor(data?: IPagedResultDtoOfProductSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductSdkModel {
    totalCount: number;
    items: ProductSdkModel[] | undefined;
}

export class GetProductBySubKeyAndOuterIdOutput implements IGetProductBySubKeyAndOuterIdOutput {
    id!: number;
    itemId!: string | undefined;
    quantity!: number;
    title!: string | undefined;
    organizationUnitId!: number | undefined;
    subTitle!: string | undefined;
    price!: number;
    promPrice!: number;
    barcode!: string | undefined;
    salesVolume!: number;
    keywords!: string | undefined;
    picUrl!: string | undefined;
    likeCount!: number;
    description!: string | undefined;
    isFromBrand!: boolean;
    sellerId!: string | undefined;
    outerId!: string | undefined;
    fromType!: string | undefined;
    hasRealSkus!: boolean;
    propImgs!: ProductDecideImageViewModel[] | undefined;
    categoryIds!: number[] | undefined;
    propValueIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    skus!: SkuSdkModel[] | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    groupQrCodeInfo!: string | undefined;
    orderNumber!: number;
    brandId!: number | undefined;
    brandName!: string | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IGetProductBySubKeyAndOuterIdOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isFromBrand = _data["isFromBrand"];
            this.sellerId = _data["sellerId"];
            this.outerId = _data["outerId"];
            this.fromType = _data["fromType"];
            this.hasRealSkus = _data["hasRealSkus"];
            if (Array.isArray(_data["propImgs"])) {
                this.propImgs = [] as any;
                for (let item of _data["propImgs"])
                    this.propImgs!.push(ProductDecideImageViewModel.fromJS(item));
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.groupQrCodeInfo = _data["groupQrCodeInfo"];
            this.orderNumber = _data["orderNumber"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProductBySubKeyAndOuterIdOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductBySubKeyAndOuterIdOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["organizationUnitId"] = this.organizationUnitId;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isFromBrand"] = this.isFromBrand;
        data["sellerId"] = this.sellerId;
        data["outerId"] = this.outerId;
        data["fromType"] = this.fromType;
        data["hasRealSkus"] = this.hasRealSkus;
        if (Array.isArray(this.propImgs)) {
            data["propImgs"] = [];
            for (let item of this.propImgs)
                data["propImgs"].push(item.toJSON());
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["groupQrCodeInfo"] = this.groupQrCodeInfo;
        data["orderNumber"] = this.orderNumber;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProductBySubKeyAndOuterIdOutput {
    id: number;
    itemId: string | undefined;
    quantity: number;
    title: string | undefined;
    organizationUnitId: number | undefined;
    subTitle: string | undefined;
    price: number;
    promPrice: number;
    barcode: string | undefined;
    salesVolume: number;
    keywords: string | undefined;
    picUrl: string | undefined;
    likeCount: number;
    description: string | undefined;
    isFromBrand: boolean;
    sellerId: string | undefined;
    outerId: string | undefined;
    fromType: string | undefined;
    hasRealSkus: boolean;
    propImgs: ProductDecideImageViewModel[] | undefined;
    categoryIds: number[] | undefined;
    propValueIds: number[] | undefined;
    tagIds: number[] | undefined;
    skus: SkuSdkModel[] | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    groupQrCodeInfo: string | undefined;
    orderNumber: number;
    brandId: number | undefined;
    brandName: string | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class ProductCategorySDKModel implements IProductCategorySDKModel {
    id!: number;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IProductCategorySDKModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): ProductCategorySDKModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategorySDKModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IProductCategorySDKModel {
    id: number;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class PagedResultDtoOfProductCategorySDKModel implements IPagedResultDtoOfProductCategorySDKModel {
    totalCount!: number;
    items!: ProductCategorySDKModel[] | undefined;

    constructor(data?: IPagedResultDtoOfProductCategorySDKModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategorySDKModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProductCategorySDKModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProductCategorySDKModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfProductCategorySDKModel {
    totalCount: number;
    items: ProductCategorySDKModel[] | undefined;
}

export class AdAndAppTimelineScheduleDto implements IAdAndAppTimelineScheduleDto {
    date!: DateTime;
    startTime!: string | undefined;
    endTime!: string | undefined;
    scheduleModel!: ScheduleModel;
    adAndApps!: ProgramItem[] | undefined;

    constructor(data?: IAdAndAppTimelineScheduleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.scheduleModel = _data["scheduleModel"] ? ScheduleModel.fromJS(_data["scheduleModel"]) : <any>undefined;
            if (Array.isArray(_data["adAndApps"])) {
                this.adAndApps = [] as any;
                for (let item of _data["adAndApps"])
                    this.adAndApps!.push(ProgramItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AdAndAppTimelineScheduleDto {
        data = typeof data === 'object' ? data : {};
        let result = new AdAndAppTimelineScheduleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["scheduleModel"] = this.scheduleModel ? this.scheduleModel.toJSON() : <any>undefined;
        if (Array.isArray(this.adAndApps)) {
            data["adAndApps"] = [];
            for (let item of this.adAndApps)
                data["adAndApps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAdAndAppTimelineScheduleDto {
    date: DateTime;
    startTime: string | undefined;
    endTime: string | undefined;
    scheduleModel: ScheduleModel;
    adAndApps: ProgramItem[] | undefined;
}

export class TagSdkModel implements ITagSdkModel {
    id!: number;
    value!: string | undefined;
    type!: string | undefined;
    isSpecial!: boolean;
    iconUrl!: string | undefined;

    constructor(data?: ITagSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.isSpecial = _data["isSpecial"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): TagSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new TagSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["isSpecial"] = this.isSpecial;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ITagSdkModel {
    id: number;
    value: string | undefined;
    type: string | undefined;
    isSpecial: boolean;
    iconUrl: string | undefined;
}

export class PagedResultDtoOfTagSdkModel implements IPagedResultDtoOfTagSdkModel {
    totalCount!: number;
    items!: TagSdkModel[] | undefined;

    constructor(data?: IPagedResultDtoOfTagSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTagSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTagSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTagSdkModel {
    totalCount: number;
    items: TagSdkModel[] | undefined;
}

export class BrandIdAndProductIdsDto implements IBrandIdAndProductIdsDto {
    brandId!: number;
    brandName!: string | undefined;
    productIds!: number[] | undefined;

    constructor(data?: IBrandIdAndProductIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BrandIdAndProductIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandIdAndProductIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data; 
    }
}

export interface IBrandIdAndProductIdsDto {
    brandId: number;
    brandName: string | undefined;
    productIds: number[] | undefined;
}

export class BrandProductDto implements IBrandProductDto {
    items!: BrandIdAndProductIdsDto[] | undefined;

    constructor(data?: IBrandProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandIdAndProductIdsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrandProductDto {
    items: BrandIdAndProductIdsDto[] | undefined;
}

export class BrandIdAndSkuIdsDto implements IBrandIdAndSkuIdsDto {
    brandId!: number;
    brandName!: string | undefined;
    skuIds!: number[] | undefined;
    sku_Ids!: string[] | undefined;

    constructor(data?: IBrandIdAndSkuIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            if (Array.isArray(_data["sku_Ids"])) {
                this.sku_Ids = [] as any;
                for (let item of _data["sku_Ids"])
                    this.sku_Ids!.push(item);
            }
        }
    }

    static fromJS(data: any): BrandIdAndSkuIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandIdAndSkuIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        if (Array.isArray(this.sku_Ids)) {
            data["sku_Ids"] = [];
            for (let item of this.sku_Ids)
                data["sku_Ids"].push(item);
        }
        return data; 
    }
}

export interface IBrandIdAndSkuIdsDto {
    brandId: number;
    brandName: string | undefined;
    skuIds: number[] | undefined;
    sku_Ids: string[] | undefined;
}

export class BrandSkuDto implements IBrandSkuDto {
    items!: BrandIdAndSkuIdsDto[] | undefined;

    constructor(data?: IBrandSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandIdAndSkuIdsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrandSkuDto {
    items: BrandIdAndSkuIdsDto[] | undefined;
}

export class SkuIdAndOuterIdDto implements ISkuIdAndOuterIdDto {
    skuId!: number;
    title!: string | undefined;
    outerId!: string | undefined;

    constructor(data?: ISkuIdAndOuterIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): SkuIdAndOuterIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuIdAndOuterIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface ISkuIdAndOuterIdDto {
    skuId: number;
    title: string | undefined;
    outerId: string | undefined;
}

export class StaffSdkModel implements IStaffSdkModel {
    phoneNumber!: string | undefined;
    emailAddress!: string | undefined;
    userName!: string | undefined;
    fullName!: string | undefined;
    lastLoginTime!: DateTime | undefined;
    outerId!: string | undefined;
    canApiAccess!: boolean;
    isStaff!: boolean;
    profilePictureId!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    onlineStoreInfos!: OnlineStoreProfileDto[] | undefined;

    constructor(data?: IStaffSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? DateTime.fromISO(_data["lastLoginTime"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            this.canApiAccess = _data["canApiAccess"];
            this.isStaff = _data["isStaff"];
            this.profilePictureId = _data["profilePictureId"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StaffSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new StaffSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toString() : <any>undefined;
        data["outerId"] = this.outerId;
        data["canApiAccess"] = this.canApiAccess;
        data["isStaff"] = this.isStaff;
        data["profilePictureId"] = this.profilePictureId;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStaffSdkModel {
    phoneNumber: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    fullName: string | undefined;
    lastLoginTime: DateTime | undefined;
    outerId: string | undefined;
    canApiAccess: boolean;
    isStaff: boolean;
    profilePictureId: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    onlineStoreInfos: OnlineStoreProfileDto[] | undefined;
}

export class PagedResultDtoOfStaffSdkModel implements IPagedResultDtoOfStaffSdkModel {
    totalCount!: number;
    items!: StaffSdkModel[] | undefined;

    constructor(data?: IPagedResultDtoOfStaffSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StaffSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStaffSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStaffSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStaffSdkModel {
    totalCount: number;
    items: StaffSdkModel[] | undefined;
}

export class PagedResultDtoOfCouponDto implements IPagedResultDtoOfCouponDto {
    totalCount!: number;
    items!: CouponDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CouponDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCouponDto {
    totalCount: number;
    items: CouponDto[] | undefined;
}

export class SensingDevicePropertyValueDto implements ISensingDevicePropertyValueDto {
    id!: number;
    value!: string | undefined;
    description!: string | undefined;
    defaultImage!: string | undefined;

    constructor(data?: ISensingDevicePropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.defaultImage = _data["defaultImage"];
        }
    }

    static fromJS(data: any): SensingDevicePropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDevicePropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["description"] = this.description;
        data["defaultImage"] = this.defaultImage;
        return data; 
    }
}

export interface ISensingDevicePropertyValueDto {
    id: number;
    value: string | undefined;
    description: string | undefined;
    defaultImage: string | undefined;
}

export class SensingDevicePropertyDto implements ISensingDevicePropertyDto {
    propertyValues!: SensingDevicePropertyValueDto[] | undefined;
    id!: number;
    name!: string | undefined;
    isForSale!: boolean;
    isDefaultDecideImage!: boolean;
    description!: string | undefined;

    constructor(data?: ISensingDevicePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(SensingDevicePropertyValueDto.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isForSale = _data["isForSale"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SensingDevicePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDevicePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isForSale"] = this.isForSale;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISensingDevicePropertyDto {
    propertyValues: SensingDevicePropertyValueDto[] | undefined;
    id: number;
    name: string | undefined;
    isForSale: boolean;
    isDefaultDecideImage: boolean;
    description: string | undefined;
}

export class PagedResultDtoOfSensingDevicePropertyDto implements IPagedResultDtoOfSensingDevicePropertyDto {
    totalCount!: number;
    items!: SensingDevicePropertyDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDevicePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDevicePropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDevicePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDevicePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDevicePropertyDto {
    totalCount: number;
    items: SensingDevicePropertyDto[] | undefined;
}

export class SensingDeviceProductCommentModel implements ISensingDeviceProductCommentModel {
    id!: number;
    userName!: string | undefined;
    commentDateTime!: DateTime;
    content!: string | undefined;
    orderNumber!: number;
    avatorUrl!: string | undefined;
    productId!: number;

    constructor(data?: ISensingDeviceProductCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.commentDateTime = _data["commentDateTime"] ? DateTime.fromISO(_data["commentDateTime"].toString()) : <any>undefined;
            this.content = _data["content"];
            this.orderNumber = _data["orderNumber"];
            this.avatorUrl = _data["avatorUrl"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): SensingDeviceProductCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceProductCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toString() : <any>undefined;
        data["content"] = this.content;
        data["orderNumber"] = this.orderNumber;
        data["avatorUrl"] = this.avatorUrl;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface ISensingDeviceProductCommentModel {
    id: number;
    userName: string | undefined;
    commentDateTime: DateTime;
    content: string | undefined;
    orderNumber: number;
    avatorUrl: string | undefined;
    productId: number;
}

export class PagedResultDtoOfSensingDeviceProductCommentModel implements IPagedResultDtoOfSensingDeviceProductCommentModel {
    totalCount!: number;
    items!: SensingDeviceProductCommentModel[] | undefined;

    constructor(data?: IPagedResultDtoOfSensingDeviceProductCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDeviceProductCommentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSensingDeviceProductCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSensingDeviceProductCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSensingDeviceProductCommentModel {
    totalCount: number;
    items: SensingDeviceProductCommentModel[] | undefined;
}

export class FaceImage implements IFaceImage {
    image!: string | undefined;
    imageUrl!: string | undefined;
    type!: string | undefined;

    constructor(data?: IFaceImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.imageUrl = _data["imageUrl"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): FaceImage {
        data = typeof data === 'object' ? data : {};
        let result = new FaceImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["imageUrl"] = this.imageUrl;
        data["type"] = this.type;
        return data; 
    }
}

export interface IFaceImage {
    image: string | undefined;
    imageUrl: string | undefined;
    type: string | undefined;
}

export class FacesRecommendsInput implements IFacesRecommendsInput {
    faces!: FaceImage[] | undefined;
    subkey!: string | undefined;

    constructor(data?: IFacesRecommendsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["faces"])) {
                this.faces = [] as any;
                for (let item of _data["faces"])
                    this.faces!.push(FaceImage.fromJS(item));
            }
            this.subkey = _data["subkey"];
        }
    }

    static fromJS(data: any): FacesRecommendsInput {
        data = typeof data === 'object' ? data : {};
        let result = new FacesRecommendsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.faces)) {
            data["faces"] = [];
            for (let item of this.faces)
                data["faces"].push(item.toJSON());
        }
        data["subkey"] = this.subkey;
        return data; 
    }
}

export interface IFacesRecommendsInput {
    faces: FaceImage[] | undefined;
    subkey: string | undefined;
}

export class Recommneds implements IRecommneds {
    id!: string | undefined;
    type!: string | undefined;
    reason!: string | undefined;

    constructor(data?: IRecommneds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): Recommneds {
        data = typeof data === 'object' ? data : {};
        let result = new Recommneds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IRecommneds {
    id: string | undefined;
    type: string | undefined;
    reason: string | undefined;
}

export class FaceRecommnedsOutput implements IFaceRecommnedsOutput {
    recognized!: boolean;
    age!: number;
    gender!: string | undefined;
    isMember!: boolean;
    memberId!: string | undefined;
    memberName!: string | undefined;
    mobile!: string | undefined;
    openId!: string | undefined;
    avatarUrl!: string | undefined;
    from!: string | undefined;
    recommends!: Recommneds[] | undefined;
    reason!: string | undefined;
    faceId!: string | undefined;

    constructor(data?: IFaceRecommnedsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recognized = _data["recognized"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.isMember = _data["isMember"];
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.mobile = _data["mobile"];
            this.openId = _data["openId"];
            this.avatarUrl = _data["avatarUrl"];
            this.from = _data["from"];
            if (Array.isArray(_data["recommends"])) {
                this.recommends = [] as any;
                for (let item of _data["recommends"])
                    this.recommends!.push(Recommneds.fromJS(item));
            }
            this.reason = _data["reason"];
            this.faceId = _data["faceId"];
        }
    }

    static fromJS(data: any): FaceRecommnedsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FaceRecommnedsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recognized"] = this.recognized;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["isMember"] = this.isMember;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["mobile"] = this.mobile;
        data["openId"] = this.openId;
        data["avatarUrl"] = this.avatarUrl;
        data["from"] = this.from;
        if (Array.isArray(this.recommends)) {
            data["recommends"] = [];
            for (let item of this.recommends)
                data["recommends"].push(item.toJSON());
        }
        data["reason"] = this.reason;
        data["faceId"] = this.faceId;
        return data; 
    }
}

export interface IFaceRecommnedsOutput {
    recognized: boolean;
    age: number;
    gender: string | undefined;
    isMember: boolean;
    memberId: string | undefined;
    memberName: string | undefined;
    mobile: string | undefined;
    openId: string | undefined;
    avatarUrl: string | undefined;
    from: string | undefined;
    recommends: Recommneds[] | undefined;
    reason: string | undefined;
    faceId: string | undefined;
}

export class SimpleFaceOutput implements ISimpleFaceOutput {
    gender!: string | undefined;
    age!: number;
    keywords!: string | undefined;
    recognized!: boolean;
    from!: string | undefined;

    constructor(data?: ISimpleFaceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.age = _data["age"];
            this.keywords = _data["keywords"];
            this.recognized = _data["recognized"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): SimpleFaceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleFaceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["age"] = this.age;
        data["keywords"] = this.keywords;
        data["recognized"] = this.recognized;
        data["from"] = this.from;
        return data; 
    }
}

export interface ISimpleFaceOutput {
    gender: string | undefined;
    age: number;
    keywords: string | undefined;
    recognized: boolean;
    from: string | undefined;
}

export class FaceInput implements IFaceInput {
    face!: string | undefined;
    subkey!: string;

    constructor(data?: IFaceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.face = _data["face"];
            this.subkey = _data["subkey"];
        }
    }

    static fromJS(data: any): FaceInput {
        data = typeof data === 'object' ? data : {};
        let result = new FaceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["face"] = this.face;
        data["subkey"] = this.subkey;
        return data; 
    }
}

export interface IFaceInput {
    face: string | undefined;
    subkey: string;
}

export class FaceMemberOutput implements IFaceMemberOutput {
    recognized!: boolean;
    faceGroupName!: string | undefined;
    age!: number;
    gender!: string | undefined;
    isMember!: boolean;
    memberId!: string | undefined;
    memberName!: string | undefined;
    mobile!: string | undefined;
    openId!: string | undefined;
    avatarUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IFaceMemberOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recognized = _data["recognized"];
            this.faceGroupName = _data["faceGroupName"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.isMember = _data["isMember"];
            this.memberId = _data["memberId"];
            this.memberName = _data["memberName"];
            this.mobile = _data["mobile"];
            this.openId = _data["openId"];
            this.avatarUrl = _data["avatarUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): FaceMemberOutput {
        data = typeof data === 'object' ? data : {};
        let result = new FaceMemberOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recognized"] = this.recognized;
        data["faceGroupName"] = this.faceGroupName;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["isMember"] = this.isMember;
        data["memberId"] = this.memberId;
        data["memberName"] = this.memberName;
        data["mobile"] = this.mobile;
        data["openId"] = this.openId;
        data["avatarUrl"] = this.avatarUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IFaceMemberOutput {
    recognized: boolean;
    faceGroupName: string | undefined;
    age: number;
    gender: string | undefined;
    isMember: boolean;
    memberId: string | undefined;
    memberName: string | undefined;
    mobile: string | undefined;
    openId: string | undefined;
    avatarUrl: string | undefined;
    from: string | undefined;
}

export class RecommendOutput implements IRecommendOutput {
    id!: number;
    type!: string | undefined;
    title!: string | undefined;
    price!: number;
    picUrl!: string | undefined;
    detailUrl!: string | undefined;
    reason!: string | undefined;

    constructor(data?: IRecommendOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.picUrl = _data["picUrl"];
            this.detailUrl = _data["detailUrl"];
            this.reason = _data["reason"];
        }
    }

    static fromJS(data: any): RecommendOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["price"] = this.price;
        data["picUrl"] = this.picUrl;
        data["detailUrl"] = this.detailUrl;
        data["reason"] = this.reason;
        return data; 
    }
}

export interface IRecommendOutput {
    id: number;
    type: string | undefined;
    title: string | undefined;
    price: number;
    picUrl: string | undefined;
    detailUrl: string | undefined;
    reason: string | undefined;
}

export class RecommendsOutput implements IRecommendsOutput {
    type!: string | undefined;
    recommends!: RecommendOutput[] | undefined;

    constructor(data?: IRecommendsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["recommends"])) {
                this.recommends = [] as any;
                for (let item of _data["recommends"])
                    this.recommends!.push(RecommendOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecommendsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.recommends)) {
            data["recommends"] = [];
            for (let item of this.recommends)
                data["recommends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecommendsOutput {
    type: string | undefined;
    recommends: RecommendOutput[] | undefined;
}

export class BrandSdkDto implements IBrandSdkDto {
    id!: number;
    code!: string | undefined;
    orderNumber!: number;
    name!: string | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    b_BrandCategories!: IdNameDto[] | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    slogan!: string | undefined;
    theme!: string | undefined;
    extensionData!: string | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IBrandSdkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            if (Array.isArray(_data["b_BrandCategories"])) {
                this.b_BrandCategories = [] as any;
                for (let item of _data["b_BrandCategories"])
                    this.b_BrandCategories!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            this.slogan = _data["slogan"];
            this.theme = _data["theme"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BrandSdkDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandSdkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        if (Array.isArray(this.b_BrandCategories)) {
            data["b_BrandCategories"] = [];
            for (let item of this.b_BrandCategories)
                data["b_BrandCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["slogan"] = this.slogan;
        data["theme"] = this.theme;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IBrandSdkDto {
    id: number;
    code: string | undefined;
    orderNumber: number;
    name: string | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    b_BrandCategories: IdNameDto[] | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    slogan: string | undefined;
    theme: string | undefined;
    extensionData: string | undefined;
    tagIds: number[] | undefined;
}

export class PagedResultDtoOfBrandSdkDto implements IPagedResultDtoOfBrandSdkDto {
    totalCount!: number;
    items!: BrandSdkDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBrandSdkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandSdkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBrandSdkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBrandSdkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBrandSdkDto {
    totalCount: number;
    items: BrandSdkDto[] | undefined;
}

export class StoreBrandBindingDto implements IStoreBrandBindingDto {
    storeId!: number;
    brandId!: number | undefined;
    roomIds!: string | undefined;

    constructor(data?: IStoreBrandBindingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.brandId = _data["brandId"];
            this.roomIds = _data["roomIds"];
        }
    }

    static fromJS(data: any): StoreBrandBindingDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreBrandBindingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["brandId"] = this.brandId;
        data["roomIds"] = this.roomIds;
        return data; 
    }
}

export interface IStoreBrandBindingDto {
    storeId: number;
    brandId: number | undefined;
    roomIds: string | undefined;
}

export class PagedResultDtoOfStoreBrandBindingDto implements IPagedResultDtoOfStoreBrandBindingDto {
    totalCount!: number;
    items!: StoreBrandBindingDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreBrandBindingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreBrandBindingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreBrandBindingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreBrandBindingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStoreBrandBindingDto {
    totalCount: number;
    items: StoreBrandBindingDto[] | undefined;
}

export class TableLastTimeDto implements ITableLastTimeDto {
    ads!: DateTime | undefined;
    apps!: DateTime | undefined;
    productCategories!: DateTime | undefined;
    products!: DateTime | undefined;
    skus!: DateTime | undefined;
    tags!: DateTime | undefined;
    productComments!: DateTime | undefined;
    properties!: DateTime | undefined;
    propertyValues!: DateTime | undefined;
    coupons!: DateTime | undefined;
    staffs!: DateTime | undefined;
    matchInfos!: DateTime | undefined;
    likeInfos!: DateTime | undefined;
    brands!: DateTime | undefined;

    constructor(data?: ITableLastTimeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ads = _data["ads"] ? DateTime.fromISO(_data["ads"].toString()) : <any>undefined;
            this.apps = _data["apps"] ? DateTime.fromISO(_data["apps"].toString()) : <any>undefined;
            this.productCategories = _data["productCategories"] ? DateTime.fromISO(_data["productCategories"].toString()) : <any>undefined;
            this.products = _data["products"] ? DateTime.fromISO(_data["products"].toString()) : <any>undefined;
            this.skus = _data["skus"] ? DateTime.fromISO(_data["skus"].toString()) : <any>undefined;
            this.tags = _data["tags"] ? DateTime.fromISO(_data["tags"].toString()) : <any>undefined;
            this.productComments = _data["productComments"] ? DateTime.fromISO(_data["productComments"].toString()) : <any>undefined;
            this.properties = _data["properties"] ? DateTime.fromISO(_data["properties"].toString()) : <any>undefined;
            this.propertyValues = _data["propertyValues"] ? DateTime.fromISO(_data["propertyValues"].toString()) : <any>undefined;
            this.coupons = _data["coupons"] ? DateTime.fromISO(_data["coupons"].toString()) : <any>undefined;
            this.staffs = _data["staffs"] ? DateTime.fromISO(_data["staffs"].toString()) : <any>undefined;
            this.matchInfos = _data["matchInfos"] ? DateTime.fromISO(_data["matchInfos"].toString()) : <any>undefined;
            this.likeInfos = _data["likeInfos"] ? DateTime.fromISO(_data["likeInfos"].toString()) : <any>undefined;
            this.brands = _data["brands"] ? DateTime.fromISO(_data["brands"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TableLastTimeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TableLastTimeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ads"] = this.ads ? this.ads.toString() : <any>undefined;
        data["apps"] = this.apps ? this.apps.toString() : <any>undefined;
        data["productCategories"] = this.productCategories ? this.productCategories.toString() : <any>undefined;
        data["products"] = this.products ? this.products.toString() : <any>undefined;
        data["skus"] = this.skus ? this.skus.toString() : <any>undefined;
        data["tags"] = this.tags ? this.tags.toString() : <any>undefined;
        data["productComments"] = this.productComments ? this.productComments.toString() : <any>undefined;
        data["properties"] = this.properties ? this.properties.toString() : <any>undefined;
        data["propertyValues"] = this.propertyValues ? this.propertyValues.toString() : <any>undefined;
        data["coupons"] = this.coupons ? this.coupons.toString() : <any>undefined;
        data["staffs"] = this.staffs ? this.staffs.toString() : <any>undefined;
        data["matchInfos"] = this.matchInfos ? this.matchInfos.toString() : <any>undefined;
        data["likeInfos"] = this.likeInfos ? this.likeInfos.toString() : <any>undefined;
        data["brands"] = this.brands ? this.brands.toString() : <any>undefined;
        return data; 
    }
}

export interface ITableLastTimeDto {
    ads: DateTime | undefined;
    apps: DateTime | undefined;
    productCategories: DateTime | undefined;
    products: DateTime | undefined;
    skus: DateTime | undefined;
    tags: DateTime | undefined;
    productComments: DateTime | undefined;
    properties: DateTime | undefined;
    propertyValues: DateTime | undefined;
    coupons: DateTime | undefined;
    staffs: DateTime | undefined;
    matchInfos: DateTime | undefined;
    likeInfos: DateTime | undefined;
    brands: DateTime | undefined;
}

export class TableNeedUpdateDto implements ITableNeedUpdateDto {
    ads!: boolean;
    apps!: boolean;
    productCategories!: boolean;
    products!: boolean;
    skus!: boolean;
    tags!: boolean;
    productComments!: boolean;
    properties!: boolean;
    propertyValues!: boolean;
    coupons!: boolean;
    staffs!: boolean;
    matchInfos!: boolean;
    likeInfos!: boolean;
    brands!: boolean;

    constructor(data?: ITableNeedUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ads = _data["ads"];
            this.apps = _data["apps"];
            this.productCategories = _data["productCategories"];
            this.products = _data["products"];
            this.skus = _data["skus"];
            this.tags = _data["tags"];
            this.productComments = _data["productComments"];
            this.properties = _data["properties"];
            this.propertyValues = _data["propertyValues"];
            this.coupons = _data["coupons"];
            this.staffs = _data["staffs"];
            this.matchInfos = _data["matchInfos"];
            this.likeInfos = _data["likeInfos"];
            this.brands = _data["brands"];
        }
    }

    static fromJS(data: any): TableNeedUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TableNeedUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ads"] = this.ads;
        data["apps"] = this.apps;
        data["productCategories"] = this.productCategories;
        data["products"] = this.products;
        data["skus"] = this.skus;
        data["tags"] = this.tags;
        data["productComments"] = this.productComments;
        data["properties"] = this.properties;
        data["propertyValues"] = this.propertyValues;
        data["coupons"] = this.coupons;
        data["staffs"] = this.staffs;
        data["matchInfos"] = this.matchInfos;
        data["likeInfos"] = this.likeInfos;
        data["brands"] = this.brands;
        return data; 
    }
}

export interface ITableNeedUpdateDto {
    ads: boolean;
    apps: boolean;
    productCategories: boolean;
    products: boolean;
    skus: boolean;
    tags: boolean;
    productComments: boolean;
    properties: boolean;
    propertyValues: boolean;
    coupons: boolean;
    staffs: boolean;
    matchInfos: boolean;
    likeInfos: boolean;
    brands: boolean;
}

export class AppPodSettings implements IAppPodSettings {
    isLocalOnly!: boolean;
    backgroundUrl!: string | undefined;
    sensingStoreLogoUrl!: string | undefined;
    isAutoStartApp!: boolean;
    updateResourceMinutesTickTime!: number;
    heartBreakSecondTickTime!: number;
    isCacheApps!: boolean;

    constructor(data?: IAppPodSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLocalOnly = _data["isLocalOnly"];
            this.backgroundUrl = _data["backgroundUrl"];
            this.sensingStoreLogoUrl = _data["sensingStoreLogoUrl"];
            this.isAutoStartApp = _data["isAutoStartApp"];
            this.updateResourceMinutesTickTime = _data["updateResourceMinutesTickTime"];
            this.heartBreakSecondTickTime = _data["heartBreakSecondTickTime"];
            this.isCacheApps = _data["isCacheApps"];
        }
    }

    static fromJS(data: any): AppPodSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLocalOnly"] = this.isLocalOnly;
        data["backgroundUrl"] = this.backgroundUrl;
        data["sensingStoreLogoUrl"] = this.sensingStoreLogoUrl;
        data["isAutoStartApp"] = this.isAutoStartApp;
        data["updateResourceMinutesTickTime"] = this.updateResourceMinutesTickTime;
        data["heartBreakSecondTickTime"] = this.heartBreakSecondTickTime;
        data["isCacheApps"] = this.isCacheApps;
        return data; 
    }
}

export interface IAppPodSettings {
    isLocalOnly: boolean;
    backgroundUrl: string | undefined;
    sensingStoreLogoUrl: string | undefined;
    isAutoStartApp: boolean;
    updateResourceMinutesTickTime: number;
    heartBreakSecondTickTime: number;
    isCacheApps: boolean;
}

export class AppPodUpdateStatusDto implements IAppPodUpdateStatusDto {
    needUpdate!: boolean;
    updateUrl!: string | undefined;
    versions!: string | undefined;
    releaseTime!: DateTime;
    updateCount!: number;
    updateInfo!: string | undefined;
    appPodSettings!: AppPodSettings;

    constructor(data?: IAppPodUpdateStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.needUpdate = _data["needUpdate"];
            this.updateUrl = _data["updateUrl"];
            this.versions = _data["versions"];
            this.releaseTime = _data["releaseTime"] ? DateTime.fromISO(_data["releaseTime"].toString()) : <any>undefined;
            this.updateCount = _data["updateCount"];
            this.updateInfo = _data["updateInfo"];
            this.appPodSettings = _data["appPodSettings"] ? AppPodSettings.fromJS(_data["appPodSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppPodUpdateStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodUpdateStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["needUpdate"] = this.needUpdate;
        data["updateUrl"] = this.updateUrl;
        data["versions"] = this.versions;
        data["releaseTime"] = this.releaseTime ? this.releaseTime.toString() : <any>undefined;
        data["updateCount"] = this.updateCount;
        data["updateInfo"] = this.updateInfo;
        data["appPodSettings"] = this.appPodSettings ? this.appPodSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAppPodUpdateStatusDto {
    needUpdate: boolean;
    updateUrl: string | undefined;
    versions: string | undefined;
    releaseTime: DateTime;
    updateCount: number;
    updateInfo: string | undefined;
    appPodSettings: AppPodSettings;
}

export class AndroidPadResDto implements IAndroidPadResDto {
    bgImage!: string | undefined;
    logo!: string | undefined;
    noImage!: string | undefined;
    loadingImage!: string | undefined;
    mainColor!: string | undefined;
    topbarBg_H!: string | undefined;
    topbarBg_V!: string | undefined;
    backButton!: string | undefined;
    defaultAppIcon!: string | undefined;
    qrcodeImage!: string | undefined;
    profileImage!: string | undefined;
    backBtnBackground!: string | undefined;

    constructor(data?: IAndroidPadResDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bgImage = _data["bgImage"];
            this.logo = _data["logo"];
            this.noImage = _data["noImage"];
            this.loadingImage = _data["loadingImage"];
            this.mainColor = _data["mainColor"];
            this.topbarBg_H = _data["topbarBg_H"];
            this.topbarBg_V = _data["topbarBg_V"];
            this.backButton = _data["backButton"];
            this.defaultAppIcon = _data["defaultAppIcon"];
            this.qrcodeImage = _data["qrcodeImage"];
            this.profileImage = _data["profileImage"];
            this.backBtnBackground = _data["backBtnBackground"];
        }
    }

    static fromJS(data: any): AndroidPadResDto {
        data = typeof data === 'object' ? data : {};
        let result = new AndroidPadResDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bgImage"] = this.bgImage;
        data["logo"] = this.logo;
        data["noImage"] = this.noImage;
        data["loadingImage"] = this.loadingImage;
        data["mainColor"] = this.mainColor;
        data["topbarBg_H"] = this.topbarBg_H;
        data["topbarBg_V"] = this.topbarBg_V;
        data["backButton"] = this.backButton;
        data["defaultAppIcon"] = this.defaultAppIcon;
        data["qrcodeImage"] = this.qrcodeImage;
        data["profileImage"] = this.profileImage;
        data["backBtnBackground"] = this.backBtnBackground;
        return data; 
    }
}

export interface IAndroidPadResDto {
    bgImage: string | undefined;
    logo: string | undefined;
    noImage: string | undefined;
    loadingImage: string | undefined;
    mainColor: string | undefined;
    topbarBg_H: string | undefined;
    topbarBg_V: string | undefined;
    backButton: string | undefined;
    defaultAppIcon: string | undefined;
    qrcodeImage: string | undefined;
    profileImage: string | undefined;
    backBtnBackground: string | undefined;
}

export class GetProductsCountAndInventoryDto implements IGetProductsCountAndInventoryDto {
    productCount!: number;
    sku!: number;
    skuCount!: number;
    storage!: IdNameDto[] | undefined;

    constructor(data?: IGetProductsCountAndInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCount = _data["productCount"];
            this.sku = _data["sku"];
            this.skuCount = _data["skuCount"];
            if (Array.isArray(_data["storage"])) {
                this.storage = [] as any;
                for (let item of _data["storage"])
                    this.storage!.push(IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductsCountAndInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsCountAndInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCount"] = this.productCount;
        data["sku"] = this.sku;
        data["skuCount"] = this.skuCount;
        if (Array.isArray(this.storage)) {
            data["storage"] = [];
            for (let item of this.storage)
                data["storage"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductsCountAndInventoryDto {
    productCount: number;
    sku: number;
    skuCount: number;
    storage: IdNameDto[] | undefined;
}

export class RfidQrcodeDto implements IRfidQrcodeDto {
    qrcodeUrl!: string | undefined;
    qrcodeImageUrl!: string | undefined;

    constructor(data?: IRfidQrcodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrcodeUrl = _data["qrcodeUrl"];
            this.qrcodeImageUrl = _data["qrcodeImageUrl"];
        }
    }

    static fromJS(data: any): RfidQrcodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidQrcodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrcodeUrl"] = this.qrcodeUrl;
        data["qrcodeImageUrl"] = this.qrcodeImageUrl;
        return data; 
    }
}

export interface IRfidQrcodeDto {
    qrcodeUrl: string | undefined;
    qrcodeImageUrl: string | undefined;
}

export enum CargoType {
    Product = 0,
    Sku = 1,
    Award = 2,
}

export class ThingDto implements IThingDto {
    thingId!: number;
    type!: CargoType;

    constructor(data?: IThingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ThingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IThingDto {
    thingId: number;
    type: CargoType;
}

export class QueryProductsOrSkusInput implements IQueryProductsOrSkusInput {
    subKey!: string | undefined;
    usage!: string | undefined;
    things!: ThingDto[] | undefined;

    constructor(data?: IQueryProductsOrSkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.usage = _data["usage"];
            if (Array.isArray(_data["things"])) {
                this.things = [] as any;
                for (let item of _data["things"])
                    this.things!.push(ThingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueryProductsOrSkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryProductsOrSkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["usage"] = this.usage;
        if (Array.isArray(this.things)) {
            data["things"] = [];
            for (let item of this.things)
                data["things"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IQueryProductsOrSkusInput {
    subKey: string | undefined;
    usage: string | undefined;
    things: ThingDto[] | undefined;
}

export class SimpleFileDto implements ISimpleFileDto {
    fileUrl!: string | undefined;
    type!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;

    constructor(data?: ISimpleFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.type = _data["type"];
            this.usage = _data["usage"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SimpleFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["type"] = this.type;
        data["usage"] = this.usage;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISimpleFileDto {
    fileUrl: string | undefined;
    type: string | undefined;
    usage: string | undefined;
    description: string | undefined;
}

export class SimpleProductOrSkuDto implements ISimpleProductOrSkuDto {
    thingId!: number;
    title!: string | undefined;
    type!: CargoType;
    price!: number;
    promPrice!: number | undefined;
    picUrl!: string | undefined;
    quantity!: number;
    description!: string | undefined;
    imagesOrVideos!: SimpleFileDto[] | undefined;

    constructor(data?: ISimpleProductOrSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.picUrl = _data["picUrl"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            if (Array.isArray(_data["imagesOrVideos"])) {
                this.imagesOrVideos = [] as any;
                for (let item of _data["imagesOrVideos"])
                    this.imagesOrVideos!.push(SimpleFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleProductOrSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProductOrSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["title"] = this.title;
        data["type"] = this.type;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["picUrl"] = this.picUrl;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        if (Array.isArray(this.imagesOrVideos)) {
            data["imagesOrVideos"] = [];
            for (let item of this.imagesOrVideos)
                data["imagesOrVideos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISimpleProductOrSkuDto {
    thingId: number;
    title: string | undefined;
    type: CargoType;
    price: number;
    promPrice: number | undefined;
    picUrl: string | undefined;
    quantity: number;
    description: string | undefined;
    imagesOrVideos: SimpleFileDto[] | undefined;
}

export class DeviceCount implements IDeviceCount {
    totalNumber!: number;
    onlineNumber!: number;

    constructor(data?: IDeviceCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNumber = _data["totalNumber"];
            this.onlineNumber = _data["onlineNumber"];
        }
    }

    static fromJS(data: any): DeviceCount {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNumber"] = this.totalNumber;
        data["onlineNumber"] = this.onlineNumber;
        return data; 
    }
}

export interface IDeviceCount {
    totalNumber: number;
    onlineNumber: number;
}

export class DeviceLocation implements IDeviceLocation {
    longitude!: string | undefined;
    latitude!: string | undefined;
    prictureUrl!: string | undefined;
    deviceId!: number;
    deviceName!: string | undefined;
    sn!: string | undefined;
    address!: string | undefined;

    constructor(data?: IDeviceLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.prictureUrl = _data["prictureUrl"];
            this.deviceId = _data["deviceId"];
            this.deviceName = _data["deviceName"];
            this.sn = _data["sn"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): DeviceLocation {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["prictureUrl"] = this.prictureUrl;
        data["deviceId"] = this.deviceId;
        data["deviceName"] = this.deviceName;
        data["sn"] = this.sn;
        data["address"] = this.address;
        return data; 
    }
}

export interface IDeviceLocation {
    longitude: string | undefined;
    latitude: string | undefined;
    prictureUrl: string | undefined;
    deviceId: number;
    deviceName: string | undefined;
    sn: string | undefined;
    address: string | undefined;
}

export class IndustryDeviceReportDto implements IIndustryDeviceReportDto {
    gatewayCount!: DeviceCount;
    sensorCount!: DeviceCount;
    actDeviceCount!: DeviceCount;
    deviceLocations!: DeviceLocation[] | undefined;

    constructor(data?: IIndustryDeviceReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayCount = _data["gatewayCount"] ? DeviceCount.fromJS(_data["gatewayCount"]) : <any>undefined;
            this.sensorCount = _data["sensorCount"] ? DeviceCount.fromJS(_data["sensorCount"]) : <any>undefined;
            this.actDeviceCount = _data["actDeviceCount"] ? DeviceCount.fromJS(_data["actDeviceCount"]) : <any>undefined;
            if (Array.isArray(_data["deviceLocations"])) {
                this.deviceLocations = [] as any;
                for (let item of _data["deviceLocations"])
                    this.deviceLocations!.push(DeviceLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IndustryDeviceReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryDeviceReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayCount"] = this.gatewayCount ? this.gatewayCount.toJSON() : <any>undefined;
        data["sensorCount"] = this.sensorCount ? this.sensorCount.toJSON() : <any>undefined;
        data["actDeviceCount"] = this.actDeviceCount ? this.actDeviceCount.toJSON() : <any>undefined;
        if (Array.isArray(this.deviceLocations)) {
            data["deviceLocations"] = [];
            for (let item of this.deviceLocations)
                data["deviceLocations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIndustryDeviceReportDto {
    gatewayCount: DeviceCount;
    sensorCount: DeviceCount;
    actDeviceCount: DeviceCount;
    deviceLocations: DeviceLocation[] | undefined;
}

export class CargoInfoForWeimobActivityDto implements ICargoInfoForWeimobActivityDto {
    orderNo!: number | undefined;
    siteId!: number | undefined;
    selfPickupcode!: string | undefined;
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    errorMessage!: string | undefined;

    constructor(data?: ICargoInfoForWeimobActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNo = _data["orderNo"];
            this.siteId = _data["siteId"];
            this.selfPickupcode = _data["selfPickupcode"];
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CargoInfoForWeimobActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoInfoForWeimobActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNo"] = this.orderNo;
        data["siteId"] = this.siteId;
        data["selfPickupcode"] = this.selfPickupcode;
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface ICargoInfoForWeimobActivityDto {
    orderNo: number | undefined;
    siteId: number | undefined;
    selfPickupcode: string | undefined;
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    errorMessage: string | undefined;
}

export class BaseInfo implements IBaseInfo {
    storeName!: string | undefined;
    storeCode!: string | undefined;
    kindName!: string | undefined;
    kindCode!: string | undefined;
    priceBase!: string | undefined;
    updateDataTime!: DateTime;

    constructor(data?: IBaseInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"];
            this.storeCode = _data["storeCode"];
            this.kindName = _data["kindName"];
            this.kindCode = _data["kindCode"];
            this.priceBase = _data["priceBase"];
            this.updateDataTime = _data["updateDataTime"] ? DateTime.fromISO(_data["updateDataTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BaseInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["storeCode"] = this.storeCode;
        data["kindName"] = this.kindName;
        data["kindCode"] = this.kindCode;
        data["priceBase"] = this.priceBase;
        data["updateDataTime"] = this.updateDataTime ? this.updateDataTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IBaseInfo {
    storeName: string | undefined;
    storeCode: string | undefined;
    kindName: string | undefined;
    kindCode: string | undefined;
    priceBase: string | undefined;
    updateDataTime: DateTime;
}

export class UploadDailyInfosInput implements IUploadDailyInfosInput {
    subKey!: string | undefined;
    dailyInfos!: BaseInfo[] | undefined;

    constructor(data?: IUploadDailyInfosInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            if (Array.isArray(_data["dailyInfos"])) {
                this.dailyInfos = [] as any;
                for (let item of _data["dailyInfos"])
                    this.dailyInfos!.push(BaseInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadDailyInfosInput {
        data = typeof data === 'object' ? data : {};
        let result = new UploadDailyInfosInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        if (Array.isArray(this.dailyInfos)) {
            data["dailyInfos"] = [];
            for (let item of this.dailyInfos)
                data["dailyInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUploadDailyInfosInput {
    subKey: string | undefined;
    dailyInfos: BaseInfo[] | undefined;
}

export class AddOrUpdateSnsUserInfoInput implements IAddOrUpdateSnsUserInfoInput {
    subKey!: string | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: DateTime | undefined;
    unSubScribeTime!: DateTime | undefined;
    unionid!: string | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    gameName!: string | undefined;
    score!: string | undefined;

    constructor(data?: IAddOrUpdateSnsUserInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.snsAppID = _data["snsAppID"];
            this.subscribe = _data["subscribe"];
            this.openid = _data["openid"];
            this.nickname = _data["nickname"];
            this.sex = _data["sex"];
            this.language = _data["language"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.country = _data["country"];
            this.headimgurl = _data["headimgurl"];
            this.subscribeTime = _data["subscribeTime"] ? DateTime.fromISO(_data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = _data["unSubScribeTime"] ? DateTime.fromISO(_data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = _data["unionid"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.identityID = _data["identityID"];
            this.gameName = _data["gameName"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): AddOrUpdateSnsUserInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSnsUserInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["gameName"] = this.gameName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IAddOrUpdateSnsUserInfoInput {
    subKey: string | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: DateTime | undefined;
    unSubScribeTime: DateTime | undefined;
    unionid: string | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    gameName: string | undefined;
    score: string | undefined;
}

export class PostPlayerDataInfoInput implements IPostPlayerDataInfoInput {
    snsUserInfo!: AddOrUpdateSnsUserInfoInput;
    message!: string | undefined;

    constructor(data?: IPostPlayerDataInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.snsUserInfo = _data["snsUserInfo"] ? AddOrUpdateSnsUserInfoInput.fromJS(_data["snsUserInfo"]) : <any>undefined;
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): PostPlayerDataInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostPlayerDataInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["message"] = this.message;
        return data; 
    }
}

export interface IPostPlayerDataInfoInput {
    snsUserInfo: AddOrUpdateSnsUserInfoInput;
    message: string | undefined;
}

export class IntfaDeviceDescriptionWithId implements IIntfaDeviceDescriptionWithId {
    id!: number;
    name!: string | undefined;
    outerId!: string | undefined;
    subKey!: string | undefined;
    isStatic!: boolean;
    description!: string | undefined;

    constructor(data?: IIntfaDeviceDescriptionWithId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.subKey = _data["subKey"];
            this.isStatic = _data["isStatic"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IntfaDeviceDescriptionWithId {
        data = typeof data === 'object' ? data : {};
        let result = new IntfaDeviceDescriptionWithId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["subKey"] = this.subKey;
        data["isStatic"] = this.isStatic;
        data["description"] = this.description;
        return data; 
    }
}

export interface IIntfaDeviceDescriptionWithId {
    id: number;
    name: string | undefined;
    outerId: string | undefined;
    subKey: string | undefined;
    isStatic: boolean;
    description: string | undefined;
}

export class UpdateIntfaDeviceDescription implements IUpdateIntfaDeviceDescription {
    subKey!: string | undefined;
    isStatic!: boolean;
    description!: string | undefined;

    constructor(data?: IUpdateIntfaDeviceDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.isStatic = _data["isStatic"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateIntfaDeviceDescription {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIntfaDeviceDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["isStatic"] = this.isStatic;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateIntfaDeviceDescription {
    subKey: string | undefined;
    isStatic: boolean;
    description: string | undefined;
}

export class UpdateIntfaDeviceDescriptionsInput implements IUpdateIntfaDeviceDescriptionsInput {
    devices!: UpdateIntfaDeviceDescription[] | undefined;

    constructor(data?: IUpdateIntfaDeviceDescriptionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["devices"])) {
                this.devices = [] as any;
                for (let item of _data["devices"])
                    this.devices!.push(UpdateIntfaDeviceDescription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateIntfaDeviceDescriptionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIntfaDeviceDescriptionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devices)) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateIntfaDeviceDescriptionsInput {
    devices: UpdateIntfaDeviceDescription[] | undefined;
}

export class EcovacsQrcodeExtend implements IEcovacsQrcodeExtend {
    game_name!: string | undefined;
    game_score!: string | undefined;

    constructor(data?: IEcovacsQrcodeExtend) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.game_name = _data["game_name"];
            this.game_score = _data["game_score"];
        }
    }

    static fromJS(data: any): EcovacsQrcodeExtend {
        data = typeof data === 'object' ? data : {};
        let result = new EcovacsQrcodeExtend();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["game_name"] = this.game_name;
        data["game_score"] = this.game_score;
        return data; 
    }
}

export interface IEcovacsQrcodeExtend {
    game_name: string | undefined;
    game_score: string | undefined;
}

export class CreateEcovacsQrcodeInput implements ICreateEcovacsQrcodeInput {
    qrcode_type!: string | undefined;
    robot_id!: string | undefined;
    extend!: EcovacsQrcodeExtend;

    constructor(data?: ICreateEcovacsQrcodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrcode_type = _data["qrcode_type"];
            this.robot_id = _data["robot_id"];
            this.extend = _data["extend"] ? EcovacsQrcodeExtend.fromJS(_data["extend"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateEcovacsQrcodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEcovacsQrcodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrcode_type"] = this.qrcode_type;
        data["robot_id"] = this.robot_id;
        data["extend"] = this.extend ? this.extend.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateEcovacsQrcodeInput {
    qrcode_type: string | undefined;
    robot_id: string | undefined;
    extend: EcovacsQrcodeExtend;
}

export class TextForPDF implements ITextForPDF {
    content!: string | undefined;
    bold!: boolean;
    fontSize!: number;

    constructor(data?: ITextForPDF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.bold = _data["bold"];
            this.fontSize = _data["fontSize"];
        }
    }

    static fromJS(data: any): TextForPDF {
        data = typeof data === 'object' ? data : {};
        let result = new TextForPDF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["bold"] = this.bold;
        data["fontSize"] = this.fontSize;
        return data; 
    }
}

export interface ITextForPDF {
    content: string | undefined;
    bold: boolean;
    fontSize: number;
}

export class PDFDto implements IPDFDto {
    tenantId!: number;
    skuId!: number;
    isTop!: number;
    textForPDF!: TextForPDF[] | undefined;
    column!: number;

    constructor(data?: IPDFDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.skuId = _data["skuId"];
            this.isTop = _data["isTop"];
            if (Array.isArray(_data["textForPDF"])) {
                this.textForPDF = [] as any;
                for (let item of _data["textForPDF"])
                    this.textForPDF!.push(TextForPDF.fromJS(item));
            }
            this.column = _data["column"];
        }
    }

    static fromJS(data: any): PDFDto {
        data = typeof data === 'object' ? data : {};
        let result = new PDFDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["skuId"] = this.skuId;
        data["isTop"] = this.isTop;
        if (Array.isArray(this.textForPDF)) {
            data["textForPDF"] = [];
            for (let item of this.textForPDF)
                data["textForPDF"].push(item.toJSON());
        }
        data["column"] = this.column;
        return data; 
    }
}

export interface IPDFDto {
    tenantId: number;
    skuId: number;
    isTop: number;
    textForPDF: TextForPDF[] | undefined;
    column: number;
}

export enum StoreType {
    Self_Supporting = 0,
    Join = 1,
}

export enum StoreStatus {
    Stopped = 0,
    Running = 1,
}

export class StoresDto implements IStoresDto {
    storeId!: number;
    displayName!: string | undefined;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    contact!: string | undefined;
    categoryId!: string | undefined;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    qrcodeRules!: string | undefined;
    defaultOnlineShopName!: string | undefined;
    type!: StoreType;
    memberCount!: number;
    organziationUnitName!: string | undefined;
    storeType!: string | undefined;
    storeStatus!: StoreStatus;
    storeDevicesInfo!: string | undefined;
    roomIds!: string | undefined;
    brandId!: number | undefined;

    constructor(data?: IStoresDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.displayName = _data["displayName"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.contact = _data["contact"];
            this.categoryId = _data["categoryId"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrcodeRules = _data["qrcodeRules"];
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.type = _data["type"];
            this.memberCount = _data["memberCount"];
            this.organziationUnitName = _data["organziationUnitName"];
            this.storeType = _data["storeType"];
            this.storeStatus = _data["storeStatus"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.roomIds = _data["roomIds"];
            this.brandId = _data["brandId"];
        }
    }

    static fromJS(data: any): StoresDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoresDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["displayName"] = this.displayName;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["contact"] = this.contact;
        data["categoryId"] = this.categoryId;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrcodeRules"] = this.qrcodeRules;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["type"] = this.type;
        data["memberCount"] = this.memberCount;
        data["organziationUnitName"] = this.organziationUnitName;
        data["storeType"] = this.storeType;
        data["storeStatus"] = this.storeStatus;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["roomIds"] = this.roomIds;
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface IStoresDto {
    storeId: number;
    displayName: string | undefined;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    contact: string | undefined;
    categoryId: string | undefined;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    qrcodeRules: string | undefined;
    defaultOnlineShopName: string | undefined;
    type: StoreType;
    memberCount: number;
    organziationUnitName: string | undefined;
    storeType: string | undefined;
    storeStatus: StoreStatus;
    storeDevicesInfo: string | undefined;
    roomIds: string | undefined;
    brandId: number | undefined;
}

export class PagedResultDtoOfStoresDto implements IPagedResultDtoOfStoresDto {
    totalCount!: number;
    items!: StoresDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoresDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoresDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoresDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoresDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStoresDto {
    totalCount: number;
    items: StoresDto[] | undefined;
}

export class GetSensingSdkShopInput implements IGetSensingSdkShopInput {
    currentProductId!: number;
    auditStatus!: AuditStatus;
    pointRedeemType!: RedeemType;
    tagId!: number | undefined;
    categoryId!: number | undefined;
    sortStatus!: string | undefined;
    isSearchSku!: boolean | undefined;
    ticketId!: number | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetSensingSdkShopInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentProductId = _data["currentProductId"];
            this.auditStatus = _data["auditStatus"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.tagId = _data["tagId"];
            this.categoryId = _data["categoryId"];
            this.sortStatus = _data["sortStatus"];
            this.isSearchSku = _data["isSearchSku"];
            this.ticketId = _data["ticketId"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetSensingSdkShopInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSensingSdkShopInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentProductId"] = this.currentProductId;
        data["auditStatus"] = this.auditStatus;
        data["pointRedeemType"] = this.pointRedeemType;
        data["tagId"] = this.tagId;
        data["categoryId"] = this.categoryId;
        data["sortStatus"] = this.sortStatus;
        data["isSearchSku"] = this.isSearchSku;
        data["ticketId"] = this.ticketId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetSensingSdkShopInput {
    currentProductId: number;
    auditStatus: AuditStatus;
    pointRedeemType: RedeemType;
    tagId: number | undefined;
    categoryId: number | undefined;
    sortStatus: string | undefined;
    isSearchSku: boolean | undefined;
    ticketId: number | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class ShopPagedResultDtoOfProuctListOutPut implements IShopPagedResultDtoOfProuctListOutPut {
    categories!: IdNameDto[] | undefined;
    tags!: IdNameDto[] | undefined;
    totalCount!: number;
    items!: ProuctListOutPut[] | undefined;

    constructor(data?: IShopPagedResultDtoOfProuctListOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(IdNameDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProuctListOutPut.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShopPagedResultDtoOfProuctListOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new ShopPagedResultDtoOfProuctListOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShopPagedResultDtoOfProuctListOutPut {
    categories: IdNameDto[] | undefined;
    tags: IdNameDto[] | undefined;
    totalCount: number;
    items: ProuctListOutPut[] | undefined;
}

export class GetSingleShopProductInput implements IGetSingleShopProductInput {
    currentProductId!: number;

    constructor(data?: IGetSingleShopProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentProductId = _data["currentProductId"];
        }
    }

    static fromJS(data: any): GetSingleShopProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSingleShopProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentProductId"] = this.currentProductId;
        return data; 
    }
}

export interface IGetSingleShopProductInput {
    currentProductId: number;
}

export class GetTicketDto implements IGetTicketDto {
    id!: number;
    creationTime!: DateTime;
    displayName!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    avaliableDays!: number | undefined;
    expireTime!: DateTime | undefined;
    isTaked!: boolean;
    description!: string | undefined;
    value!: number;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;

    constructor(data?: IGetTicketDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.expireTime = _data["expireTime"] ? DateTime.fromISO(_data["expireTime"].toString()) : <any>undefined;
            this.isTaked = _data["isTaked"];
            this.description = _data["description"];
            this.value = _data["value"];
            if (Array.isArray(_data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of _data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
        }
    }

    static fromJS(data: any): GetTicketDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["expireTime"] = this.expireTime ? this.expireTime.toString() : <any>undefined;
        data["isTaked"] = this.isTaked;
        data["description"] = this.description;
        data["value"] = this.value;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        return data; 
    }
}

export interface IGetTicketDto {
    id: number;
    creationTime: DateTime;
    displayName: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    avaliableDays: number | undefined;
    expireTime: DateTime | undefined;
    isTaked: boolean;
    description: string | undefined;
    value: number;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
}

export class SingleShopProductDto implements ISingleShopProductDto {
    id!: number;
    itemId!: string | undefined;
    quantity!: number;
    title!: string | undefined;
    price!: number;
    picUrl!: string | undefined;
    description!: string | undefined;
    skus!: SkuDto[] | undefined;
    itemImagesOrVideos!: EntityFileDto[] | undefined;
    skuProperties!: PropertyDto[] | undefined;
    descriptionItemImagesOrVideos!: EntityFileDto[] | undefined;
    productCommentDto!: ProductCommentDto[] | undefined;
    tickets!: GetTicketDto[] | undefined;
    visualImagePropertyId!: number | undefined;
    promPrice!: string | undefined;
    price2!: number | undefined;
    salesVolume!: number;
    isCollection!: boolean;
    status!: string | undefined;
    haveOtherTickets!: boolean;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: ISingleShopProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileDto.fromJS(item));
            }
            if (Array.isArray(_data["skuProperties"])) {
                this.skuProperties = [] as any;
                for (let item of _data["skuProperties"])
                    this.skuProperties!.push(PropertyDto.fromJS(item));
            }
            if (Array.isArray(_data["descriptionItemImagesOrVideos"])) {
                this.descriptionItemImagesOrVideos = [] as any;
                for (let item of _data["descriptionItemImagesOrVideos"])
                    this.descriptionItemImagesOrVideos!.push(EntityFileDto.fromJS(item));
            }
            if (Array.isArray(_data["productCommentDto"])) {
                this.productCommentDto = [] as any;
                for (let item of _data["productCommentDto"])
                    this.productCommentDto!.push(ProductCommentDto.fromJS(item));
            }
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(GetTicketDto.fromJS(item));
            }
            this.visualImagePropertyId = _data["visualImagePropertyId"];
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            this.isCollection = _data["isCollection"];
            this.status = _data["status"];
            this.haveOtherTickets = _data["haveOtherTickets"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SingleShopProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SingleShopProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["price"] = this.price;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.skuProperties)) {
            data["skuProperties"] = [];
            for (let item of this.skuProperties)
                data["skuProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.descriptionItemImagesOrVideos)) {
            data["descriptionItemImagesOrVideos"] = [];
            for (let item of this.descriptionItemImagesOrVideos)
                data["descriptionItemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.productCommentDto)) {
            data["productCommentDto"] = [];
            for (let item of this.productCommentDto)
                data["productCommentDto"].push(item.toJSON());
        }
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        data["visualImagePropertyId"] = this.visualImagePropertyId;
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        data["isCollection"] = this.isCollection;
        data["status"] = this.status;
        data["haveOtherTickets"] = this.haveOtherTickets;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISingleShopProductDto {
    id: number;
    itemId: string | undefined;
    quantity: number;
    title: string | undefined;
    price: number;
    picUrl: string | undefined;
    description: string | undefined;
    skus: SkuDto[] | undefined;
    itemImagesOrVideos: EntityFileDto[] | undefined;
    skuProperties: PropertyDto[] | undefined;
    descriptionItemImagesOrVideos: EntityFileDto[] | undefined;
    productCommentDto: ProductCommentDto[] | undefined;
    tickets: GetTicketDto[] | undefined;
    visualImagePropertyId: number | undefined;
    promPrice: string | undefined;
    price2: number | undefined;
    salesVolume: number;
    isCollection: boolean;
    status: string | undefined;
    haveOtherTickets: boolean;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class GetShopProductCategoriesInput implements IGetShopProductCategoriesInput {
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetShopProductCategoriesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetShopProductCategoriesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetShopProductCategoriesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetShopProductCategoriesInput {
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class ShopProductSkuDto implements IShopProductSkuDto {
    id!: number;
    sku_id!: string | undefined;
    productId!: number;
    productName!: string | undefined;
    productPointRedeemType!: RedeemType;
    productPointRule!: ProductPointRule;
    quantity!: number;
    auditStatus!: AuditStatus;
    propsName!: string | undefined;
    title!: string | undefined;
    price!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    price2!: number | undefined;
    salesVolume!: number;
    tagIds!: number[] | undefined;
    tagNames!: string[] | undefined;
    categoryIds!: number[] | undefined;
    categoryNames!: string[] | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;
    storeId!: number | undefined;
    storeOuterId!: string | undefined;

    constructor(data?: IShopProductSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productPointRedeemType = _data["productPointRedeemType"];
            this.productPointRule = _data["productPointRule"] ? ProductPointRule.fromJS(_data["productPointRule"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.auditStatus = _data["auditStatus"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["tagNames"])) {
                this.tagNames = [] as any;
                for (let item of _data["tagNames"])
                    this.tagNames!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["categoryNames"])) {
                this.categoryNames = [] as any;
                for (let item of _data["categoryNames"])
                    this.categoryNames!.push(item);
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
        }
    }

    static fromJS(data: any): ShopProductSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopProductSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productPointRedeemType"] = this.productPointRedeemType;
        data["productPointRule"] = this.productPointRule ? this.productPointRule.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["auditStatus"] = this.auditStatus;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.tagNames)) {
            data["tagNames"] = [];
            for (let item of this.tagNames)
                data["tagNames"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.categoryNames)) {
            data["categoryNames"] = [];
            for (let item of this.categoryNames)
                data["categoryNames"].push(item);
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        return data; 
    }
}

export interface IShopProductSkuDto {
    id: number;
    sku_id: string | undefined;
    productId: number;
    productName: string | undefined;
    productPointRedeemType: RedeemType;
    productPointRule: ProductPointRule;
    quantity: number;
    auditStatus: AuditStatus;
    propsName: string | undefined;
    title: string | undefined;
    price: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    price2: number | undefined;
    salesVolume: number;
    tagIds: number[] | undefined;
    tagNames: string[] | undefined;
    categoryIds: number[] | undefined;
    categoryNames: string[] | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
    storeId: number | undefined;
    storeOuterId: string | undefined;
}

export class ProductTagAndCategoryDto implements IProductTagAndCategoryDto {
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: IProductTagAndCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductTagAndCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagAndCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface IProductTagAndCategoryDto {
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export enum ShopStatus {
    Stopped = 0,
    Running = 1,
}

export class PayCashPointRule implements IPayCashPointRule {
    payCashAmount!: number;
    awardPointAmount!: number;

    constructor(data?: IPayCashPointRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payCashAmount = _data["payCashAmount"];
            this.awardPointAmount = _data["awardPointAmount"];
        }
    }

    static fromJS(data: any): PayCashPointRule {
        data = typeof data === 'object' ? data : {};
        let result = new PayCashPointRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payCashAmount"] = this.payCashAmount;
        data["awardPointAmount"] = this.awardPointAmount;
        return data; 
    }
}

export interface IPayCashPointRule {
    payCashAmount: number;
    awardPointAmount: number;
}

export class PayPointRule implements IPayPointRule {
    shopPointRule!: PayCashPointRule;
    devicePointRule!: PayCashPointRule;

    constructor(data?: IPayPointRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shopPointRule = _data["shopPointRule"] ? PayCashPointRule.fromJS(_data["shopPointRule"]) : <any>undefined;
            this.devicePointRule = _data["devicePointRule"] ? PayCashPointRule.fromJS(_data["devicePointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PayPointRule {
        data = typeof data === 'object' ? data : {};
        let result = new PayPointRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shopPointRule"] = this.shopPointRule ? this.shopPointRule.toJSON() : <any>undefined;
        data["devicePointRule"] = this.devicePointRule ? this.devicePointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPayPointRule {
    shopPointRule: PayCashPointRule;
    devicePointRule: PayCashPointRule;
}

export class DeductionRule implements IDeductionRule {
    deductionPointAmount!: number;
    payCashAmount!: number;

    constructor(data?: IDeductionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deductionPointAmount = _data["deductionPointAmount"];
            this.payCashAmount = _data["payCashAmount"];
        }
    }

    static fromJS(data: any): DeductionRule {
        data = typeof data === 'object' ? data : {};
        let result = new DeductionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deductionPointAmount"] = this.deductionPointAmount;
        data["payCashAmount"] = this.payCashAmount;
        return data; 
    }
}

export interface IDeductionRule {
    deductionPointAmount: number;
    payCashAmount: number;
}

export class PointDeductionRule implements IPointDeductionRule {
    shopDeductionRule!: DeductionRule;
    deviceDeductionRule!: DeductionRule;

    constructor(data?: IPointDeductionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shopDeductionRule = _data["shopDeductionRule"] ? DeductionRule.fromJS(_data["shopDeductionRule"]) : <any>undefined;
            this.deviceDeductionRule = _data["deviceDeductionRule"] ? DeductionRule.fromJS(_data["deviceDeductionRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PointDeductionRule {
        data = typeof data === 'object' ? data : {};
        let result = new PointDeductionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shopDeductionRule"] = this.shopDeductionRule ? this.shopDeductionRule.toJSON() : <any>undefined;
        data["deviceDeductionRule"] = this.deviceDeductionRule ? this.deviceDeductionRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPointDeductionRule {
    shopDeductionRule: DeductionRule;
    deviceDeductionRule: DeductionRule;
}

export class ShopSettingDto implements IShopSettingDto {
    id!: number;
    tenantId!: number;
    outerId!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    refundAddress!: string | undefined;
    description!: string | undefined;
    status!: ShopStatus;
    orderAutoCloseDays!: number;
    orderAutoSignDays!: number;
    orderAllowRefundDays!: number;
    shopUrl!: string | undefined;
    publicAccountId!: number | undefined;
    isEnablePointRule!: boolean;
    needCertification!: boolean | undefined;
    certificationUrl!: string | undefined;
    payPointRule!: PayPointRule;
    pointDeductionRule!: PointDeductionRule;

    constructor(data?: IShopSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.outerId = _data["outerId"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.refundAddress = _data["refundAddress"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.orderAutoCloseDays = _data["orderAutoCloseDays"];
            this.orderAutoSignDays = _data["orderAutoSignDays"];
            this.orderAllowRefundDays = _data["orderAllowRefundDays"];
            this.shopUrl = _data["shopUrl"];
            this.publicAccountId = _data["publicAccountId"];
            this.isEnablePointRule = _data["isEnablePointRule"];
            this.needCertification = _data["needCertification"];
            this.certificationUrl = _data["certificationUrl"];
            this.payPointRule = _data["payPointRule"] ? PayPointRule.fromJS(_data["payPointRule"]) : <any>undefined;
            this.pointDeductionRule = _data["pointDeductionRule"] ? PointDeductionRule.fromJS(_data["pointDeductionRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShopSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["outerId"] = this.outerId;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["refundAddress"] = this.refundAddress;
        data["description"] = this.description;
        data["status"] = this.status;
        data["orderAutoCloseDays"] = this.orderAutoCloseDays;
        data["orderAutoSignDays"] = this.orderAutoSignDays;
        data["orderAllowRefundDays"] = this.orderAllowRefundDays;
        data["shopUrl"] = this.shopUrl;
        data["publicAccountId"] = this.publicAccountId;
        data["isEnablePointRule"] = this.isEnablePointRule;
        data["needCertification"] = this.needCertification;
        data["certificationUrl"] = this.certificationUrl;
        data["payPointRule"] = this.payPointRule ? this.payPointRule.toJSON() : <any>undefined;
        data["pointDeductionRule"] = this.pointDeductionRule ? this.pointDeductionRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShopSettingDto {
    id: number;
    tenantId: number;
    outerId: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    refundAddress: string | undefined;
    description: string | undefined;
    status: ShopStatus;
    orderAutoCloseDays: number;
    orderAutoSignDays: number;
    orderAllowRefundDays: number;
    shopUrl: string | undefined;
    publicAccountId: number | undefined;
    isEnablePointRule: boolean;
    needCertification: boolean | undefined;
    certificationUrl: string | undefined;
    payPointRule: PayPointRule;
    pointDeductionRule: PointDeductionRule;
}

export class ShopSliderDto implements IShopSliderDto {
    id!: number;
    tenantId!: number;
    displayName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: IShopSliderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.displayName = _data["displayName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): ShopSliderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopSliderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["displayName"] = this.displayName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IShopSliderDto {
    id: number;
    tenantId: number;
    displayName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export class ShopCategoryDto implements IShopCategoryDto {
    id!: number;
    tenantId!: number;
    categoryId!: number;
    categoryName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: IShopCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): ShopCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IShopCategoryDto {
    id: number;
    tenantId: number;
    categoryId: number;
    categoryName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export enum ShopTag {
    Left = 0,
    Top = 1,
    Bottom = 2,
}

export class ShopTagDto implements IShopTagDto {
    id!: number;
    tenantId!: number;
    tagId!: number;
    tagName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    shopTag!: ShopTag;

    constructor(data?: IShopTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.tagId = _data["tagId"];
            this.tagName = _data["tagName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.shopTag = _data["shopTag"];
        }
    }

    static fromJS(data: any): ShopTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["tagId"] = this.tagId;
        data["tagName"] = this.tagName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["shopTag"] = this.shopTag;
        return data; 
    }
}

export interface IShopTagDto {
    id: number;
    tenantId: number;
    tagId: number;
    tagName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    shopTag: ShopTag;
}

export class BasicShopDto implements IBasicShopDto {
    shopSettingDto!: ShopSettingDto;
    shopSliderDtos!: ShopSliderDto[] | undefined;
    shopCategoryDtos!: ShopCategoryDto[] | undefined;
    shopTagDtos!: ShopTagDto[] | undefined;
    shopCarThings!: number | undefined;
    position!: PositionDto;

    constructor(data?: IBasicShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shopSettingDto = _data["shopSettingDto"] ? ShopSettingDto.fromJS(_data["shopSettingDto"]) : <any>undefined;
            if (Array.isArray(_data["shopSliderDtos"])) {
                this.shopSliderDtos = [] as any;
                for (let item of _data["shopSliderDtos"])
                    this.shopSliderDtos!.push(ShopSliderDto.fromJS(item));
            }
            if (Array.isArray(_data["shopCategoryDtos"])) {
                this.shopCategoryDtos = [] as any;
                for (let item of _data["shopCategoryDtos"])
                    this.shopCategoryDtos!.push(ShopCategoryDto.fromJS(item));
            }
            if (Array.isArray(_data["shopTagDtos"])) {
                this.shopTagDtos = [] as any;
                for (let item of _data["shopTagDtos"])
                    this.shopTagDtos!.push(ShopTagDto.fromJS(item));
            }
            this.shopCarThings = _data["shopCarThings"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BasicShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new BasicShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shopSettingDto"] = this.shopSettingDto ? this.shopSettingDto.toJSON() : <any>undefined;
        if (Array.isArray(this.shopSliderDtos)) {
            data["shopSliderDtos"] = [];
            for (let item of this.shopSliderDtos)
                data["shopSliderDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.shopCategoryDtos)) {
            data["shopCategoryDtos"] = [];
            for (let item of this.shopCategoryDtos)
                data["shopCategoryDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.shopTagDtos)) {
            data["shopTagDtos"] = [];
            for (let item of this.shopTagDtos)
                data["shopTagDtos"].push(item.toJSON());
        }
        data["shopCarThings"] = this.shopCarThings;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBasicShopDto {
    shopSettingDto: ShopSettingDto;
    shopSliderDtos: ShopSliderDto[] | undefined;
    shopCategoryDtos: ShopCategoryDto[] | undefined;
    shopTagDtos: ShopTagDto[] | undefined;
    shopCarThings: number | undefined;
    position: PositionDto;
}

export class GetShopLikeInfosInput implements IGetShopLikeInfosInput {
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetShopLikeInfosInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetShopLikeInfosInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetShopLikeInfosInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetShopLikeInfosInput {
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class ShopLikeInfosDto implements IShopLikeInfosDto {
    tenantId!: number;
    memberId!: number;
    productId!: number;
    viewTimes!: number;
    displayName!: string | undefined;
    image!: string | undefined;
    price!: number;
    description!: string | undefined;

    constructor(data?: IShopLikeInfosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.memberId = _data["memberId"];
            this.productId = _data["productId"];
            this.viewTimes = _data["viewTimes"];
            this.displayName = _data["displayName"];
            this.image = _data["image"];
            this.price = _data["price"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ShopLikeInfosDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopLikeInfosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["memberId"] = this.memberId;
        data["productId"] = this.productId;
        data["viewTimes"] = this.viewTimes;
        data["displayName"] = this.displayName;
        data["image"] = this.image;
        data["price"] = this.price;
        data["description"] = this.description;
        return data; 
    }
}

export interface IShopLikeInfosDto {
    tenantId: number;
    memberId: number;
    productId: number;
    viewTimes: number;
    displayName: string | undefined;
    image: string | undefined;
    price: number;
    description: string | undefined;
}

export class ShopSkuDto implements IShopSkuDto {
    id!: number;
    sku_id!: string | undefined;
    productId!: number;
    quantity!: number;
    auditStatus!: AuditStatus;
    propsName!: string | undefined;
    title!: string | undefined;
    price!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    price2!: number | undefined;
    salesVolume!: number;
    status!: string | undefined;

    constructor(data?: IShopSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.auditStatus = _data["auditStatus"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ShopSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["auditStatus"] = this.auditStatus;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        data["status"] = this.status;
        return data; 
    }
}

export interface IShopSkuDto {
    id: number;
    sku_id: string | undefined;
    productId: number;
    quantity: number;
    auditStatus: AuditStatus;
    propsName: string | undefined;
    title: string | undefined;
    price: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    price2: number | undefined;
    salesVolume: number;
    status: string | undefined;
}

export class ShopCarDto implements IShopCarDto {
    skuDto!: ShopSkuDto;
    number!: number;

    constructor(data?: IShopCarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuDto = _data["skuDto"] ? ShopSkuDto.fromJS(_data["skuDto"]) : <any>undefined;
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): ShopCarDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopCarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuDto"] = this.skuDto ? this.skuDto.toJSON() : <any>undefined;
        data["number"] = this.number;
        return data; 
    }
}

export interface IShopCarDto {
    skuDto: ShopSkuDto;
    number: number;
}

export class AddOrUpdateShopCarsInput implements IAddOrUpdateShopCarsInput {
    skuId!: number;
    action!: string | undefined;
    number!: number;

    constructor(data?: IAddOrUpdateShopCarsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.action = _data["action"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): AddOrUpdateShopCarsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateShopCarsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["action"] = this.action;
        data["number"] = this.number;
        return data; 
    }
}

export interface IAddOrUpdateShopCarsInput {
    skuId: number;
    action: string | undefined;
    number: number;
}

export class DeleteShopCarsInput implements IDeleteShopCarsInput {
    skuIds!: number[] | undefined;

    constructor(data?: IDeleteShopCarsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteShopCarsInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteShopCarsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        return data; 
    }
}

export interface IDeleteShopCarsInput {
    skuIds: number[] | undefined;
}

export class ShopCollectionDto implements IShopCollectionDto {
    id!: number;
    price!: number | undefined;
    title!: string | undefined;
    picUrl!: string | undefined;
    promPrice!: number;
    price2!: number | undefined;
    salesVolume!: number;
    isCollection!: boolean;

    constructor(data?: IShopCollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.title = _data["title"];
            this.picUrl = _data["picUrl"];
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            this.isCollection = _data["isCollection"];
        }
    }

    static fromJS(data: any): ShopCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["title"] = this.title;
        data["picUrl"] = this.picUrl;
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        data["isCollection"] = this.isCollection;
        return data; 
    }
}

export interface IShopCollectionDto {
    id: number;
    price: number | undefined;
    title: string | undefined;
    picUrl: string | undefined;
    promPrice: number;
    price2: number | undefined;
    salesVolume: number;
    isCollection: boolean;
}

export class PagedResultDtoOfShopCollectionDto implements IPagedResultDtoOfShopCollectionDto {
    totalCount!: number;
    items!: ShopCollectionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopCollectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopCollectionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopCollectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopCollectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopCollectionDto {
    totalCount: number;
    items: ShopCollectionDto[] | undefined;
}

export class AddOrDeleteCollectionsInput implements IAddOrDeleteCollectionsInput {
    thingId!: number;
    type!: string | undefined;
    action!: string | undefined;

    constructor(data?: IAddOrDeleteCollectionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): AddOrDeleteCollectionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrDeleteCollectionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["action"] = this.action;
        return data; 
    }
}

export interface IAddOrDeleteCollectionsInput {
    thingId: number;
    type: string | undefined;
    action: string | undefined;
}

export class GetShopRecommendProductsInput implements IGetShopRecommendProductsInput {
    tagName!: string | undefined;
    needFill!: boolean;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetShopRecommendProductsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagName = _data["tagName"];
            this.needFill = _data["needFill"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetShopRecommendProductsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetShopRecommendProductsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagName"] = this.tagName;
        data["needFill"] = this.needFill;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetShopRecommendProductsInput {
    tagName: string | undefined;
    needFill: boolean;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfSingleShopProductDto implements IPagedResultDtoOfSingleShopProductDto {
    totalCount!: number;
    items!: SingleShopProductDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSingleShopProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SingleShopProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSingleShopProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSingleShopProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSingleShopProductDto {
    totalCount: number;
    items: SingleShopProductDto[] | undefined;
}

export class IdAndNumberDto implements IIdAndNumberDto {
    skuId!: number;
    number!: number;

    constructor(data?: IIdAndNumberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): IdAndNumberDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdAndNumberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        return data; 
    }
}

export interface IIdAndNumberDto {
    skuId: number;
    number: number;
}

export class GetShopFreightInput implements IGetShopFreightInput {
    items!: IdAndNumberDto[] | undefined;
    city!: string | undefined;

    constructor(data?: IGetShopFreightInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdAndNumberDto.fromJS(item));
            }
            this.city = _data["city"];
        }
    }

    static fromJS(data: any): GetShopFreightInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetShopFreightInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["city"] = this.city;
        return data; 
    }
}

export interface IGetShopFreightInput {
    items: IdAndNumberDto[] | undefined;
    city: string | undefined;
}

export class CreateShopCommentInput implements ICreateShopCommentInput {
    mediaIds!: string[] | undefined;
    userName!: string | undefined;
    avatorUrl!: string | undefined;
    content!: string | undefined;
    orderId!: number | undefined;
    starLevel!: number | undefined;
    from!: string | undefined;

    constructor(data?: ICreateShopCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mediaIds"])) {
                this.mediaIds = [] as any;
                for (let item of _data["mediaIds"])
                    this.mediaIds!.push(item);
            }
            this.userName = _data["userName"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.orderId = _data["orderId"];
            this.starLevel = _data["starLevel"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): CreateShopCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mediaIds)) {
            data["mediaIds"] = [];
            for (let item of this.mediaIds)
                data["mediaIds"].push(item);
        }
        data["userName"] = this.userName;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["orderId"] = this.orderId;
        data["starLevel"] = this.starLevel;
        data["from"] = this.from;
        return data; 
    }
}

export interface ICreateShopCommentInput {
    mediaIds: string[] | undefined;
    userName: string | undefined;
    avatorUrl: string | undefined;
    content: string | undefined;
    orderId: number | undefined;
    starLevel: number | undefined;
    from: string | undefined;
}

export class NameBoolDto implements INameBoolDto {
    name!: string | undefined;
    isPurchased!: boolean;

    constructor(data?: INameBoolDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isPurchased = _data["isPurchased"];
        }
    }

    static fromJS(data: any): NameBoolDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameBoolDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isPurchased"] = this.isPurchased;
        return data; 
    }
}

export interface INameBoolDto {
    name: string | undefined;
    isPurchased: boolean;
}

export class RfidCodeStateDto implements IRfidCodeStateDto {
    rfidStates!: NameBoolDto[] | undefined;
    allPurchased!: boolean;

    constructor(data?: IRfidCodeStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["rfidStates"])) {
                this.rfidStates = [] as any;
                for (let item of _data["rfidStates"])
                    this.rfidStates!.push(NameBoolDto.fromJS(item));
            }
            this.allPurchased = _data["allPurchased"];
        }
    }

    static fromJS(data: any): RfidCodeStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidCodeStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.rfidStates)) {
            data["rfidStates"] = [];
            for (let item of this.rfidStates)
                data["rfidStates"].push(item.toJSON());
        }
        data["allPurchased"] = this.allPurchased;
        return data; 
    }
}

export interface IRfidCodeStateDto {
    rfidStates: NameBoolDto[] | undefined;
    allPurchased: boolean;
}

export class ActivePromotionInput implements IActivePromotionInput {
    promotionId!: string | undefined;
    activeTime!: DateTime;
    md5!: string | undefined;
    deletePromotion!: boolean | undefined;

    constructor(data?: IActivePromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            this.activeTime = _data["activeTime"] ? DateTime.fromISO(_data["activeTime"].toString()) : <any>undefined;
            this.md5 = _data["md5"];
            this.deletePromotion = _data["deletePromotion"];
        }
    }

    static fromJS(data: any): ActivePromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivePromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        data["activeTime"] = this.activeTime ? this.activeTime.toString() : <any>undefined;
        data["md5"] = this.md5;
        data["deletePromotion"] = this.deletePromotion;
        return data; 
    }
}

export interface IActivePromotionInput {
    promotionId: string | undefined;
    activeTime: DateTime;
    md5: string | undefined;
    deletePromotion: boolean | undefined;
}

export class BrandsCategory implements IBrandsCategory {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number | undefined;
    parentCategory!: BrandsCategory;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrandsCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategory = _data["parentCategory"] ? BrandsCategory.fromJS(_data["parentCategory"]) : <any>undefined;
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandsCategory {
        data = typeof data === 'object' ? data : {};
        let result = new BrandsCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrandsCategory {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number | undefined;
    parentCategory: BrandsCategory;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Brand_BrandCategory implements IBrand_BrandCategory {
    brandId!: number;
    brand!: Brand;
    brandCategoryId!: number;
    brandCategory!: BrandsCategory;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrand_BrandCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.brandCategoryId = _data["brandCategoryId"];
            this.brandCategory = _data["brandCategory"] ? BrandsCategory.fromJS(_data["brandCategory"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Brand_BrandCategory {
        data = typeof data === 'object' ? data : {};
        let result = new Brand_BrandCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["brandCategoryId"] = this.brandCategoryId;
        data["brandCategory"] = this.brandCategory ? this.brandCategory.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrand_BrandCategory {
    brandId: number;
    brand: Brand;
    brandCategoryId: number;
    brandCategory: BrandsCategory;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BrandResourceFile implements IBrandResourceFile {
    brandId!: number;
    brand!: Brand;
    resourceItemId!: number;
    resourceItem!: ResourceFile;
    usage!: string | undefined;
    description!: string | undefined;
    fromType!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrandResourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.resourceItemId = _data["resourceItemId"];
            this.resourceItem = _data["resourceItem"] ? ResourceFile.fromJS(_data["resourceItem"]) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.fromType = _data["fromType"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandResourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new BrandResourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["resourceItemId"] = this.resourceItemId;
        data["resourceItem"] = this.resourceItem ? this.resourceItem.toJSON() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["fromType"] = this.fromType;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrandResourceFile {
    brandId: number;
    brand: Brand;
    resourceItemId: number;
    resourceItem: ResourceFile;
    usage: string | undefined;
    description: string | undefined;
    fromType: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class BrandTag implements IBrandTag {
    brandId!: number;
    brand!: Brand;
    tagId!: number;
    tag!: Tag;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrandTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandTag {
        data = typeof data === 'object' ? data : {};
        let result = new BrandTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrandTag {
    brandId: number;
    brand: Brand;
    tagId: number;
    tag: Tag;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Brand implements IBrand {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    code!: string | undefined;
    name!: string | undefined;
    b_BrandCategories!: Brand_BrandCategory[] | undefined;
    logoUrl!: string | undefined;
    imageUrl!: string | undefined;
    state!: string | undefined;
    mainColor!: string | undefined;
    description!: string | undefined;
    itemImagesOrVideos!: BrandResourceFile[] | undefined;
    brandTags!: BrandTag[] | undefined;
    slogan!: string | undefined;
    auditStatus!: AuditStatus;
    theme!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["b_BrandCategories"])) {
                this.b_BrandCategories = [] as any;
                for (let item of _data["b_BrandCategories"])
                    this.b_BrandCategories!.push(Brand_BrandCategory.fromJS(item));
            }
            this.logoUrl = _data["logoUrl"];
            this.imageUrl = _data["imageUrl"];
            this.state = _data["state"];
            this.mainColor = _data["mainColor"];
            this.description = _data["description"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(BrandResourceFile.fromJS(item));
            }
            if (Array.isArray(_data["brandTags"])) {
                this.brandTags = [] as any;
                for (let item of _data["brandTags"])
                    this.brandTags!.push(BrandTag.fromJS(item));
            }
            this.slogan = _data["slogan"];
            this.auditStatus = _data["auditStatus"];
            this.theme = _data["theme"];
            this.extensionData = _data["extensionData"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.b_BrandCategories)) {
            data["b_BrandCategories"] = [];
            for (let item of this.b_BrandCategories)
                data["b_BrandCategories"].push(item.toJSON());
        }
        data["logoUrl"] = this.logoUrl;
        data["imageUrl"] = this.imageUrl;
        data["state"] = this.state;
        data["mainColor"] = this.mainColor;
        data["description"] = this.description;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.brandTags)) {
            data["brandTags"] = [];
            for (let item of this.brandTags)
                data["brandTags"].push(item.toJSON());
        }
        data["slogan"] = this.slogan;
        data["auditStatus"] = this.auditStatus;
        data["theme"] = this.theme;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBrand {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    code: string | undefined;
    name: string | undefined;
    b_BrandCategories: Brand_BrandCategory[] | undefined;
    logoUrl: string | undefined;
    imageUrl: string | undefined;
    state: string | undefined;
    mainColor: string | undefined;
    description: string | undefined;
    itemImagesOrVideos: BrandResourceFile[] | undefined;
    brandTags: BrandTag[] | undefined;
    slogan: string | undefined;
    auditStatus: AuditStatus;
    theme: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductResourceFile implements IProductResourceFile {
    productId!: number;
    product!: Product;
    resourceItemId!: number;
    resourceItem!: ResourceFile;
    usage!: string | undefined;
    description!: string | undefined;
    fromType!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductResourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.resourceItemId = _data["resourceItemId"];
            this.resourceItem = _data["resourceItem"] ? ResourceFile.fromJS(_data["resourceItem"]) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.fromType = _data["fromType"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductResourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new ProductResourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["resourceItemId"] = this.resourceItemId;
        data["resourceItem"] = this.resourceItem ? this.resourceItem.toJSON() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["fromType"] = this.fromType;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductResourceFile {
    productId: number;
    product: Product;
    resourceItemId: number;
    resourceItem: ResourceFile;
    usage: string | undefined;
    description: string | undefined;
    fromType: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class SkuTag implements ISkuTag {
    skuId!: number;
    sku!: Sku;
    tagId!: number;
    tag!: Tag;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISkuTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.sku = _data["sku"] ? Sku.fromJS(_data["sku"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkuTag {
        data = typeof data === 'object' ? data : {};
        let result = new SkuTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISkuTag {
    skuId: number;
    sku: Sku;
    tagId: number;
    tag: Tag;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class SkuResourceFile implements ISkuResourceFile {
    skuId!: number;
    sku!: Sku;
    resourceItemId!: number;
    resourceItem!: ResourceFile;
    usage!: string | undefined;
    description!: string | undefined;
    fromType!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISkuResourceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.sku = _data["sku"] ? Sku.fromJS(_data["sku"]) : <any>undefined;
            this.resourceItemId = _data["resourceItemId"];
            this.resourceItem = _data["resourceItem"] ? ResourceFile.fromJS(_data["resourceItem"]) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.fromType = _data["fromType"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkuResourceFile {
        data = typeof data === 'object' ? data : {};
        let result = new SkuResourceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["resourceItemId"] = this.resourceItemId;
        data["resourceItem"] = this.resourceItem ? this.resourceItem.toJSON() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["fromType"] = this.fromType;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISkuResourceFile {
    skuId: number;
    sku: Sku;
    resourceItemId: number;
    resourceItem: ResourceFile;
    usage: string | undefined;
    description: string | undefined;
    fromType: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Sku implements ISku {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    sku_id!: string | undefined;
    productId!: number;
    product!: Product;
    barcode!: string | undefined;
    properties!: string | undefined;
    propertiesName!: string | undefined;
    price!: number;
    quantity!: number;
    picUrl!: string | undefined;
    keywords!: string | undefined;
    is3D!: boolean;
    material3DUrl!: string | undefined;
    description!: string | undefined;
    colorId!: string | undefined;
    colorName!: string | undefined;
    outerId!: string | undefined;
    platformPicUrl!: string | undefined;
    title!: string | undefined;
    fromType!: string | undefined;
    skuTags!: SkuTag[] | undefined;
    auditStatus!: AuditStatus;
    itemImagesOrVideos!: SkuResourceFile[] | undefined;
    promPrice!: number;
    suitablePeople!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    salesVolume!: number;
    starLevel!: number | undefined;
    brandId!: number | undefined;
    brand!: Brand;
    pointRedeemType!: RedeemType;
    pointRule!: string | undefined;
    weight!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISku) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.sku_id = _data["sku_id"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.barcode = _data["barcode"];
            this.properties = _data["properties"];
            this.propertiesName = _data["propertiesName"];
            this.price = _data["price"];
            this.quantity = _data["quantity"];
            this.picUrl = _data["picUrl"];
            this.keywords = _data["keywords"];
            this.is3D = _data["is3D"];
            this.material3DUrl = _data["material3DUrl"];
            this.description = _data["description"];
            this.colorId = _data["colorId"];
            this.colorName = _data["colorName"];
            this.outerId = _data["outerId"];
            this.platformPicUrl = _data["platformPicUrl"];
            this.title = _data["title"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(SkuTag.fromJS(item));
            }
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(SkuResourceFile.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.suitablePeople = _data["suitablePeople"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            this.starLevel = _data["starLevel"];
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"];
            this.weight = _data["weight"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Sku {
        data = typeof data === 'object' ? data : {};
        let result = new Sku();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["sku_id"] = this.sku_id;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["barcode"] = this.barcode;
        data["properties"] = this.properties;
        data["propertiesName"] = this.propertiesName;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["picUrl"] = this.picUrl;
        data["keywords"] = this.keywords;
        data["is3D"] = this.is3D;
        data["material3DUrl"] = this.material3DUrl;
        data["description"] = this.description;
        data["colorId"] = this.colorId;
        data["colorName"] = this.colorName;
        data["outerId"] = this.outerId;
        data["platformPicUrl"] = this.platformPicUrl;
        data["title"] = this.title;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["suitablePeople"] = this.suitablePeople;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        data["starLevel"] = this.starLevel;
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule;
        data["weight"] = this.weight;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISku {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    sku_id: string | undefined;
    productId: number;
    product: Product;
    barcode: string | undefined;
    properties: string | undefined;
    propertiesName: string | undefined;
    price: number;
    quantity: number;
    picUrl: string | undefined;
    keywords: string | undefined;
    is3D: boolean;
    material3DUrl: string | undefined;
    description: string | undefined;
    colorId: string | undefined;
    colorName: string | undefined;
    outerId: string | undefined;
    platformPicUrl: string | undefined;
    title: string | undefined;
    fromType: string | undefined;
    skuTags: SkuTag[] | undefined;
    auditStatus: AuditStatus;
    itemImagesOrVideos: SkuResourceFile[] | undefined;
    promPrice: number;
    suitablePeople: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    salesVolume: number;
    starLevel: number | undefined;
    brandId: number | undefined;
    brand: Brand;
    pointRedeemType: RedeemType;
    pointRule: string | undefined;
    weight: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductCategory implements IProductCategory {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    categoryCode!: string | undefined;
    name!: string | undefined;
    parentCategoryId!: number | undefined;
    parentCategory!: ProductCategory;
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategory = _data["parentCategory"] ? ProductCategory.fromJS(_data["parentCategory"]) : <any>undefined;
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductCategory {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    categoryCode: string | undefined;
    name: string | undefined;
    parentCategoryId: number | undefined;
    parentCategory: ProductCategory;
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Product_ProductCategory implements IProduct_ProductCategory {
    productId!: number;
    product!: Product;
    productCategoryId!: number;
    productCategory!: ProductCategory;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProduct_ProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.productCategoryId = _data["productCategoryId"];
            this.productCategory = _data["productCategory"] ? ProductCategory.fromJS(_data["productCategory"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Product_ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new Product_ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["productCategoryId"] = this.productCategoryId;
        data["productCategory"] = this.productCategory ? this.productCategory.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProduct_ProductCategory {
    productId: number;
    product: Product;
    productCategoryId: number;
    productCategory: ProductCategory;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductTag implements IProductTag {
    productId!: number;
    product!: Product;
    tagId!: number;
    tag!: Tag;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductTag {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductTag {
    productId: number;
    product: Product;
    tagId: number;
    tag: Tag;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductOnlineStoreInfo implements IProductOnlineStoreInfo {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    productId!: number;
    product!: Product;
    storeId!: string | undefined;
    onlineStoreName!: string | undefined;
    onlineStoreId!: number;
    pid!: string | undefined;
    price!: number | undefined;
    inventory!: number | undefined;
    qrcode!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductOnlineStoreInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductOnlineStoreInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOnlineStoreInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductOnlineStoreInfo {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    productId: number;
    product: Product;
    storeId: string | undefined;
    onlineStoreName: string | undefined;
    onlineStoreId: number;
    pid: string | undefined;
    price: number | undefined;
    inventory: number | undefined;
    qrcode: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Property implements IProperty {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    name!: string;
    isDefaultDecideImage!: boolean;
    isForSale!: boolean;
    fromType!: string | undefined;
    propertyValues!: PropertyValue[] | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProperty {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    name: string;
    isDefaultDecideImage: boolean;
    isForSale: boolean;
    fromType: string | undefined;
    propertyValues: PropertyValue[] | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PropertyValue implements IPropertyValue {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    propertyId!: number;
    property!: Property;
    value!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.propertyId = _data["propertyId"];
            this.property = _data["property"] ? Property.fromJS(_data["property"]) : <any>undefined;
            this.value = _data["value"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["propertyId"] = this.propertyId;
        data["property"] = this.property ? this.property.toJSON() : <any>undefined;
        data["value"] = this.value;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyValue {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    propertyId: number;
    property: Property;
    value: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Product_DecideImage implements IProduct_DecideImage {
    productId!: number;
    product!: Product;
    propertyValueId!: number;
    propertyValue!: PropertyValue;
    imageUrl!: string | undefined;
    syncImageUrl!: string | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProduct_DecideImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.propertyValueId = _data["propertyValueId"];
            this.propertyValue = _data["propertyValue"] ? PropertyValue.fromJS(_data["propertyValue"]) : <any>undefined;
            this.imageUrl = _data["imageUrl"];
            this.syncImageUrl = _data["syncImageUrl"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Product_DecideImage {
        data = typeof data === 'object' ? data : {};
        let result = new Product_DecideImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["propertyValueId"] = this.propertyValueId;
        data["propertyValue"] = this.propertyValue ? this.propertyValue.toJSON() : <any>undefined;
        data["imageUrl"] = this.imageUrl;
        data["syncImageUrl"] = this.syncImageUrl;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProduct_DecideImage {
    productId: number;
    product: Product;
    propertyValueId: number;
    propertyValue: PropertyValue;
    imageUrl: string | undefined;
    syncImageUrl: string | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Product_PropertyValue implements IProduct_PropertyValue {
    productId!: number;
    product!: Product;
    propertyValueId!: number;
    propertyValue!: PropertyValue;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProduct_PropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.propertyValueId = _data["propertyValueId"];
            this.propertyValue = _data["propertyValue"] ? PropertyValue.fromJS(_data["propertyValue"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Product_PropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new Product_PropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["propertyValueId"] = this.propertyValueId;
        data["propertyValue"] = this.propertyValue ? this.propertyValue.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProduct_PropertyValue {
    productId: number;
    product: Product;
    propertyValueId: number;
    propertyValue: PropertyValue;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Product implements IProduct {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    itemId!: string | undefined;
    description!: string | undefined;
    features!: string | undefined;
    hasDiscount!: boolean;
    hasShowcase!: boolean;
    is3D!: boolean;
    material3DUrl!: string | undefined;
    isXinpin!: boolean;
    itemSize!: string | undefined;
    itemWeight!: number;
    listTime!: DateTime | undefined;
    largeScreenImageUrl!: string | undefined;
    videoUrl!: string | undefined;
    quantity!: number;
    price!: number;
    props!: string | undefined;
    propsName!: string | undefined;
    sumPropsName!: string | undefined;
    subTitle!: string | undefined;
    title!: string | undefined;
    brandId!: number | undefined;
    brand!: Brand;
    detailUrl!: string | undefined;
    picUrl!: string | undefined;
    platformPicUrl!: string | undefined;
    itemImagesOrVideos!: ProductResourceFile[] | undefined;
    barcode!: string | undefined;
    skus!: Sku[] | undefined;
    fromType!: string | undefined;
    auditStatus!: AuditStatus;
    sellerId!: string | undefined;
    keywords!: string | undefined;
    outerId!: string | undefined;
    p_ProductCategories!: Product_ProductCategory[] | undefined;
    productTags!: ProductTag[] | undefined;
    onlineStoreInfos!: ProductOnlineStoreInfo[] | undefined;
    product_DecideImages!: Product_DecideImage[] | undefined;
    product_PropertyValues!: Product_PropertyValue[] | undefined;
    visualImagePropertyId!: number | undefined;
    visualImageProperty!: Property;
    ageScope!: string | undefined;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    price2!: number | undefined;
    salesVolume!: number;
    starLevel!: number | undefined;
    promPrice!: number;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.itemId = _data["itemId"];
            this.description = _data["description"];
            this.features = _data["features"];
            this.hasDiscount = _data["hasDiscount"];
            this.hasShowcase = _data["hasShowcase"];
            this.is3D = _data["is3D"];
            this.material3DUrl = _data["material3DUrl"];
            this.isXinpin = _data["isXinpin"];
            this.itemSize = _data["itemSize"];
            this.itemWeight = _data["itemWeight"];
            this.listTime = _data["listTime"] ? DateTime.fromISO(_data["listTime"].toString()) : <any>undefined;
            this.largeScreenImageUrl = _data["largeScreenImageUrl"];
            this.videoUrl = _data["videoUrl"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.props = _data["props"];
            this.propsName = _data["propsName"];
            this.sumPropsName = _data["sumPropsName"];
            this.subTitle = _data["subTitle"];
            this.title = _data["title"];
            this.brandId = _data["brandId"];
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : <any>undefined;
            this.detailUrl = _data["detailUrl"];
            this.picUrl = _data["picUrl"];
            this.platformPicUrl = _data["platformPicUrl"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(ProductResourceFile.fromJS(item));
            }
            this.barcode = _data["barcode"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(Sku.fromJS(item));
            }
            this.fromType = _data["fromType"];
            this.auditStatus = _data["auditStatus"];
            this.sellerId = _data["sellerId"];
            this.keywords = _data["keywords"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["p_ProductCategories"])) {
                this.p_ProductCategories = [] as any;
                for (let item of _data["p_ProductCategories"])
                    this.p_ProductCategories!.push(Product_ProductCategory.fromJS(item));
            }
            if (Array.isArray(_data["productTags"])) {
                this.productTags = [] as any;
                for (let item of _data["productTags"])
                    this.productTags!.push(ProductTag.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(ProductOnlineStoreInfo.fromJS(item));
            }
            if (Array.isArray(_data["product_DecideImages"])) {
                this.product_DecideImages = [] as any;
                for (let item of _data["product_DecideImages"])
                    this.product_DecideImages!.push(Product_DecideImage.fromJS(item));
            }
            if (Array.isArray(_data["product_PropertyValues"])) {
                this.product_PropertyValues = [] as any;
                for (let item of _data["product_PropertyValues"])
                    this.product_PropertyValues!.push(Product_PropertyValue.fromJS(item));
            }
            this.visualImagePropertyId = _data["visualImagePropertyId"];
            this.visualImageProperty = _data["visualImageProperty"] ? Property.fromJS(_data["visualImageProperty"]) : <any>undefined;
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.salesVolume = _data["salesVolume"];
            this.starLevel = _data["starLevel"];
            this.promPrice = _data["promPrice"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["itemId"] = this.itemId;
        data["description"] = this.description;
        data["features"] = this.features;
        data["hasDiscount"] = this.hasDiscount;
        data["hasShowcase"] = this.hasShowcase;
        data["is3D"] = this.is3D;
        data["material3DUrl"] = this.material3DUrl;
        data["isXinpin"] = this.isXinpin;
        data["itemSize"] = this.itemSize;
        data["itemWeight"] = this.itemWeight;
        data["listTime"] = this.listTime ? this.listTime.toString() : <any>undefined;
        data["largeScreenImageUrl"] = this.largeScreenImageUrl;
        data["videoUrl"] = this.videoUrl;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["props"] = this.props;
        data["propsName"] = this.propsName;
        data["sumPropsName"] = this.sumPropsName;
        data["subTitle"] = this.subTitle;
        data["title"] = this.title;
        data["brandId"] = this.brandId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["detailUrl"] = this.detailUrl;
        data["picUrl"] = this.picUrl;
        data["platformPicUrl"] = this.platformPicUrl;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["barcode"] = this.barcode;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        data["fromType"] = this.fromType;
        data["auditStatus"] = this.auditStatus;
        data["sellerId"] = this.sellerId;
        data["keywords"] = this.keywords;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.p_ProductCategories)) {
            data["p_ProductCategories"] = [];
            for (let item of this.p_ProductCategories)
                data["p_ProductCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productTags)) {
            data["productTags"] = [];
            for (let item of this.productTags)
                data["productTags"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.product_DecideImages)) {
            data["product_DecideImages"] = [];
            for (let item of this.product_DecideImages)
                data["product_DecideImages"].push(item.toJSON());
        }
        if (Array.isArray(this.product_PropertyValues)) {
            data["product_PropertyValues"] = [];
            for (let item of this.product_PropertyValues)
                data["product_PropertyValues"].push(item.toJSON());
        }
        data["visualImagePropertyId"] = this.visualImagePropertyId;
        data["visualImageProperty"] = this.visualImageProperty ? this.visualImageProperty.toJSON() : <any>undefined;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["salesVolume"] = this.salesVolume;
        data["starLevel"] = this.starLevel;
        data["promPrice"] = this.promPrice;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProduct {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    itemId: string | undefined;
    description: string | undefined;
    features: string | undefined;
    hasDiscount: boolean;
    hasShowcase: boolean;
    is3D: boolean;
    material3DUrl: string | undefined;
    isXinpin: boolean;
    itemSize: string | undefined;
    itemWeight: number;
    listTime: DateTime | undefined;
    largeScreenImageUrl: string | undefined;
    videoUrl: string | undefined;
    quantity: number;
    price: number;
    props: string | undefined;
    propsName: string | undefined;
    sumPropsName: string | undefined;
    subTitle: string | undefined;
    title: string | undefined;
    brandId: number | undefined;
    brand: Brand;
    detailUrl: string | undefined;
    picUrl: string | undefined;
    platformPicUrl: string | undefined;
    itemImagesOrVideos: ProductResourceFile[] | undefined;
    barcode: string | undefined;
    skus: Sku[] | undefined;
    fromType: string | undefined;
    auditStatus: AuditStatus;
    sellerId: string | undefined;
    keywords: string | undefined;
    outerId: string | undefined;
    p_ProductCategories: Product_ProductCategory[] | undefined;
    productTags: ProductTag[] | undefined;
    onlineStoreInfos: ProductOnlineStoreInfo[] | undefined;
    product_DecideImages: Product_DecideImage[] | undefined;
    product_PropertyValues: Product_PropertyValue[] | undefined;
    visualImagePropertyId: number | undefined;
    visualImageProperty: Property;
    ageScope: string | undefined;
    gender: string | undefined;
    rfidCode: string | undefined;
    price2: number | undefined;
    salesVolume: number;
    starLevel: number | undefined;
    promPrice: number;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class SkuPromotion implements ISkuPromotion {
    tenantId!: number;
    skuId!: number;
    sku!: Sku;
    productPromotionId!: number;
    productPromotion!: ProductPromotion;
    discountType!: DiscountType;
    discountValue!: number;
    price!: number;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISkuPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.skuId = _data["skuId"];
            this.sku = _data["sku"] ? Sku.fromJS(_data["sku"]) : <any>undefined;
            this.productPromotionId = _data["productPromotionId"];
            this.productPromotion = _data["productPromotion"] ? ProductPromotion.fromJS(_data["productPromotion"]) : <any>undefined;
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.price = _data["price"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkuPromotion {
        data = typeof data === 'object' ? data : {};
        let result = new SkuPromotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["skuId"] = this.skuId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["productPromotionId"] = this.productPromotionId;
        data["productPromotion"] = this.productPromotion ? this.productPromotion.toJSON() : <any>undefined;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["price"] = this.price;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISkuPromotion {
    tenantId: number;
    skuId: number;
    sku: Sku;
    productPromotionId: number;
    productPromotion: ProductPromotion;
    discountType: DiscountType;
    discountValue: number;
    price: number;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductPromotion implements IProductPromotion {
    tenantId!: number;
    productId!: number;
    product!: Product;
    promotionId!: number;
    promotion!: Promotion;
    price!: number;
    discountType!: DiscountType;
    discountValue!: number;
    skuPromotions!: SkuPromotion[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.promotionId = _data["promotionId"];
            this.promotion = _data["promotion"] ? Promotion.fromJS(_data["promotion"]) : <any>undefined;
            this.price = _data["price"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            if (Array.isArray(_data["skuPromotions"])) {
                this.skuPromotions = [] as any;
                for (let item of _data["skuPromotions"])
                    this.skuPromotions!.push(SkuPromotion.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductPromotion {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["promotionId"] = this.promotionId;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        if (Array.isArray(this.skuPromotions)) {
            data["skuPromotions"] = [];
            for (let item of this.skuPromotions)
                data["skuPromotions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductPromotion {
    tenantId: number;
    productId: number;
    product: Product;
    promotionId: number;
    promotion: Promotion;
    price: number;
    discountType: DiscountType;
    discountValue: number;
    skuPromotions: SkuPromotion[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Promotion implements IPromotion {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    attribute!: string | undefined;
    otherNeed!: string | undefined;
    otherSend!: string | undefined;
    fromType!: string | undefined;
    promotionType!: PromotionTypeEnum;
    discountType!: DiscountType;
    discountAmount!: number | undefined;
    productPromotions!: ProductPromotion[] | undefined;
    planId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.attribute = _data["attribute"];
            this.otherNeed = _data["otherNeed"];
            this.otherSend = _data["otherSend"];
            this.fromType = _data["fromType"];
            this.promotionType = _data["promotionType"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
            if (Array.isArray(_data["productPromotions"])) {
                this.productPromotions = [] as any;
                for (let item of _data["productPromotions"])
                    this.productPromotions!.push(ProductPromotion.fromJS(item));
            }
            this.planId = _data["planId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Promotion {
        data = typeof data === 'object' ? data : {};
        let result = new Promotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["attribute"] = this.attribute;
        data["otherNeed"] = this.otherNeed;
        data["otherSend"] = this.otherSend;
        data["fromType"] = this.fromType;
        data["promotionType"] = this.promotionType;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        if (Array.isArray(this.productPromotions)) {
            data["productPromotions"] = [];
            for (let item of this.productPromotions)
                data["productPromotions"].push(item.toJSON());
        }
        data["planId"] = this.planId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPromotion {
    tenantId: number;
    organizationUnitId: number | undefined;
    outerId: string | undefined;
    name: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    attribute: string | undefined;
    otherNeed: string | undefined;
    otherSend: string | undefined;
    fromType: string | undefined;
    promotionType: PromotionTypeEnum;
    discountType: DiscountType;
    discountAmount: number | undefined;
    productPromotions: ProductPromotion[] | undefined;
    planId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    creationTime!: DateTime;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.logoId = _data["logoId"];
            this.logoFileType = _data["logoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: DateTime;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: DateTime;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        this.features![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: DateTime;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    features: { [key: string]: boolean; } | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean;
    mobileFixedHeader!: boolean;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.desktopFixedHeader = _data["desktopFixedHeader"];
            this.mobileFixedHeader = _data["mobileFixedHeader"];
            this.headerSkin = _data["headerSkin"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStlye!: string | undefined;
    containerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStlye = _data["titleStlye"];
            this.containerStyle = _data["containerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStlye"] = this.titleStlye;
        data["containerStyle"] = this.containerStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStlye: string | undefined;
    containerStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class OrganizationUnitLoginInfoDot implements IOrganizationUnitLoginInfoDot {
    organizationUnits!: NameValueDto[] | undefined;

    constructor(data?: IOrganizationUnitLoginInfoDot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitLoginInfoDot {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitLoginInfoDot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationUnitLoginInfoDot {
    organizationUnits: NameValueDto[] | undefined;
}

export class GetCurrentLoginInformationsWithOrganizationUnitOutput implements IGetCurrentLoginInformationsWithOrganizationUnitOutput {
    organization!: OrganizationUnitLoginInfoDot;
    isAdmin!: boolean;
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsWithOrganizationUnitOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organization = _data["organization"] ? OrganizationUnitLoginInfoDot.fromJS(_data["organization"]) : <any>undefined;
            this.isAdmin = _data["isAdmin"];
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsWithOrganizationUnitOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsWithOrganizationUnitOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["isAdmin"] = this.isAdmin;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsWithOrganizationUnitOutput {
    organization: OrganizationUnitLoginInfoDot;
    isAdmin: boolean;
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class SettingInfo implements ISettingInfo {
    tenantId!: number | undefined;
    userId!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISettingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SettingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SettingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISettingInfo {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class UpdateShopSettingInput implements IUpdateShopSettingInput {
    id!: number;
    publicAccountId!: number | undefined;
    outerId!: string | undefined;
    displayName!: string | undefined;
    logoUrl!: string | undefined;
    phoneNumber!: string | undefined;
    address!: string | undefined;
    refundAddress!: string | undefined;
    description!: string | undefined;
    status!: ShopStatus;
    orderAutoCloseDays!: number;
    orderAutoSignDays!: number;
    orderAllowRefundDays!: number;
    shopUrl!: string | undefined;
    isEnablePointRule!: boolean;
    needCertification!: boolean | undefined;
    certificationUrl!: string | undefined;
    payPointRule!: PayPointRule;
    pointDeductionRule!: PointDeductionRule;

    constructor(data?: IUpdateShopSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.publicAccountId = _data["publicAccountId"];
            this.outerId = _data["outerId"];
            this.displayName = _data["displayName"];
            this.logoUrl = _data["logoUrl"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.refundAddress = _data["refundAddress"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.orderAutoCloseDays = _data["orderAutoCloseDays"];
            this.orderAutoSignDays = _data["orderAutoSignDays"];
            this.orderAllowRefundDays = _data["orderAllowRefundDays"];
            this.shopUrl = _data["shopUrl"];
            this.isEnablePointRule = _data["isEnablePointRule"];
            this.needCertification = _data["needCertification"];
            this.certificationUrl = _data["certificationUrl"];
            this.payPointRule = _data["payPointRule"] ? PayPointRule.fromJS(_data["payPointRule"]) : <any>undefined;
            this.pointDeductionRule = _data["pointDeductionRule"] ? PointDeductionRule.fromJS(_data["pointDeductionRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateShopSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["publicAccountId"] = this.publicAccountId;
        data["outerId"] = this.outerId;
        data["displayName"] = this.displayName;
        data["logoUrl"] = this.logoUrl;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["refundAddress"] = this.refundAddress;
        data["description"] = this.description;
        data["status"] = this.status;
        data["orderAutoCloseDays"] = this.orderAutoCloseDays;
        data["orderAutoSignDays"] = this.orderAutoSignDays;
        data["orderAllowRefundDays"] = this.orderAllowRefundDays;
        data["shopUrl"] = this.shopUrl;
        data["isEnablePointRule"] = this.isEnablePointRule;
        data["needCertification"] = this.needCertification;
        data["certificationUrl"] = this.certificationUrl;
        data["payPointRule"] = this.payPointRule ? this.payPointRule.toJSON() : <any>undefined;
        data["pointDeductionRule"] = this.pointDeductionRule ? this.pointDeductionRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateShopSettingInput {
    id: number;
    publicAccountId: number | undefined;
    outerId: string | undefined;
    displayName: string | undefined;
    logoUrl: string | undefined;
    phoneNumber: string | undefined;
    address: string | undefined;
    refundAddress: string | undefined;
    description: string | undefined;
    status: ShopStatus;
    orderAutoCloseDays: number;
    orderAutoSignDays: number;
    orderAllowRefundDays: number;
    shopUrl: string | undefined;
    isEnablePointRule: boolean;
    needCertification: boolean | undefined;
    certificationUrl: string | undefined;
    payPointRule: PayPointRule;
    pointDeductionRule: PointDeductionRule;
}

export class CreateShopSliderInput implements ICreateShopSliderInput {
    displayName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: ICreateShopSliderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): CreateShopSliderInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopSliderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface ICreateShopSliderInput {
    displayName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export class UpdateShopSliderInput implements IUpdateShopSliderInput {
    id!: number;
    displayName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: IUpdateShopSliderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateShopSliderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopSliderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateShopSliderInput {
    id: number;
    displayName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export class PagedResultDtoOfShopSliderDto implements IPagedResultDtoOfShopSliderDto {
    totalCount!: number;
    items!: ShopSliderDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopSliderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopSliderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopSliderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopSliderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopSliderDto {
    totalCount: number;
    items: ShopSliderDto[] | undefined;
}

export class CreateShopTagInput implements ICreateShopTagInput {
    tagId!: number;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    shopTag!: ShopTag;

    constructor(data?: ICreateShopTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.shopTag = _data["shopTag"];
        }
    }

    static fromJS(data: any): CreateShopTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["shopTag"] = this.shopTag;
        return data; 
    }
}

export interface ICreateShopTagInput {
    tagId: number;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    shopTag: ShopTag;
}

export class UpdateShopTagInput implements IUpdateShopTagInput {
    id!: number;
    tagId!: number;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    shopTag!: ShopTag;

    constructor(data?: IUpdateShopTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tagId = _data["tagId"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.shopTag = _data["shopTag"];
        }
    }

    static fromJS(data: any): UpdateShopTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tagId"] = this.tagId;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["shopTag"] = this.shopTag;
        return data; 
    }
}

export interface IUpdateShopTagInput {
    id: number;
    tagId: number;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    shopTag: ShopTag;
}

export class PagedResultDtoOfShopTagDto implements IPagedResultDtoOfShopTagDto {
    totalCount!: number;
    items!: ShopTagDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopTagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopTagDto {
    totalCount: number;
    items: ShopTagDto[] | undefined;
}

export class CreateShopCategoryInput implements ICreateShopCategoryInput {
    categoryId!: number;
    categoryName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: ICreateShopCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): CreateShopCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface ICreateShopCategoryInput {
    categoryId: number;
    categoryName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export class UpdateShopCategoryInput implements IUpdateShopCategoryInput {
    id!: number;
    categoryId!: number;
    categoryName!: string | undefined;
    pictureUrl!: string | undefined;
    turnUrl!: string | undefined;
    orderNumber!: string | undefined;

    constructor(data?: IUpdateShopCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.pictureUrl = _data["pictureUrl"];
            this.turnUrl = _data["turnUrl"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateShopCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["pictureUrl"] = this.pictureUrl;
        data["turnUrl"] = this.turnUrl;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateShopCategoryInput {
    id: number;
    categoryId: number;
    categoryName: string | undefined;
    pictureUrl: string | undefined;
    turnUrl: string | undefined;
    orderNumber: string | undefined;
}

export class PagedResultDtoOfShopCategoryDto implements IPagedResultDtoOfShopCategoryDto {
    totalCount!: number;
    items!: ShopCategoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopCategoryDto {
    totalCount: number;
    items: ShopCategoryDto[] | undefined;
}

export enum ShopFreightType {
    ByNumber = 0,
    ByWeight = 1,
}

export class AreaModel implements IAreaModel {
    city!: string | undefined;
    firstNumber!: number | undefined;
    secondNumber!: number | undefined;
    firstWeight!: number | undefined;
    secondWeight!: number | undefined;
    firstPrice!: number;
    secondPrice!: number;

    constructor(data?: IAreaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"];
            this.firstNumber = _data["firstNumber"];
            this.secondNumber = _data["secondNumber"];
            this.firstWeight = _data["firstWeight"];
            this.secondWeight = _data["secondWeight"];
            this.firstPrice = _data["firstPrice"];
            this.secondPrice = _data["secondPrice"];
        }
    }

    static fromJS(data: any): AreaModel {
        data = typeof data === 'object' ? data : {};
        let result = new AreaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["firstNumber"] = this.firstNumber;
        data["secondNumber"] = this.secondNumber;
        data["firstWeight"] = this.firstWeight;
        data["secondWeight"] = this.secondWeight;
        data["firstPrice"] = this.firstPrice;
        data["secondPrice"] = this.secondPrice;
        return data; 
    }
}

export interface IAreaModel {
    city: string | undefined;
    firstNumber: number | undefined;
    secondNumber: number | undefined;
    firstWeight: number | undefined;
    secondWeight: number | undefined;
    firstPrice: number;
    secondPrice: number;
}

export enum ShopFreightStatus {
    Offline = 0,
    Online = 1,
}

export class CreateShopFreightInput implements ICreateShopFreightInput {
    displayName!: string | undefined;
    orderNumber!: number;
    shopShopFreightType!: ShopFreightType;
    firstPrice!: number;
    secondPrice!: number;
    firstNumber!: number | undefined;
    secondNumber!: number | undefined;
    firstWeight!: number | undefined;
    secondWeight!: number | undefined;
    areas!: AreaModel[] | undefined;
    status!: ShopFreightStatus;
    isDefault!: boolean;

    constructor(data?: ICreateShopFreightInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.orderNumber = _data["orderNumber"];
            this.shopShopFreightType = _data["shopShopFreightType"];
            this.firstPrice = _data["firstPrice"];
            this.secondPrice = _data["secondPrice"];
            this.firstNumber = _data["firstNumber"];
            this.secondNumber = _data["secondNumber"];
            this.firstWeight = _data["firstWeight"];
            this.secondWeight = _data["secondWeight"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaModel.fromJS(item));
            }
            this.status = _data["status"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateShopFreightInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopFreightInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["orderNumber"] = this.orderNumber;
        data["shopShopFreightType"] = this.shopShopFreightType;
        data["firstPrice"] = this.firstPrice;
        data["secondPrice"] = this.secondPrice;
        data["firstNumber"] = this.firstNumber;
        data["secondNumber"] = this.secondNumber;
        data["firstWeight"] = this.firstWeight;
        data["secondWeight"] = this.secondWeight;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface ICreateShopFreightInput {
    displayName: string | undefined;
    orderNumber: number;
    shopShopFreightType: ShopFreightType;
    firstPrice: number;
    secondPrice: number;
    firstNumber: number | undefined;
    secondNumber: number | undefined;
    firstWeight: number | undefined;
    secondWeight: number | undefined;
    areas: AreaModel[] | undefined;
    status: ShopFreightStatus;
    isDefault: boolean;
}

export class UpdateShopFreightInput implements IUpdateShopFreightInput {
    id!: number;
    displayName!: string | undefined;
    orderNumber!: number;
    shopShopFreightType!: ShopFreightType;
    firstPrice!: number;
    secondPrice!: number;
    firstNumber!: number | undefined;
    secondNumber!: number | undefined;
    firstWeight!: number | undefined;
    secondWeight!: number | undefined;
    areas!: AreaModel[] | undefined;
    status!: ShopFreightStatus;
    isDefault!: boolean;

    constructor(data?: IUpdateShopFreightInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.orderNumber = _data["orderNumber"];
            this.shopShopFreightType = _data["shopShopFreightType"];
            this.firstPrice = _data["firstPrice"];
            this.secondPrice = _data["secondPrice"];
            this.firstNumber = _data["firstNumber"];
            this.secondNumber = _data["secondNumber"];
            this.firstWeight = _data["firstWeight"];
            this.secondWeight = _data["secondWeight"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaModel.fromJS(item));
            }
            this.status = _data["status"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateShopFreightInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShopFreightInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["orderNumber"] = this.orderNumber;
        data["shopShopFreightType"] = this.shopShopFreightType;
        data["firstPrice"] = this.firstPrice;
        data["secondPrice"] = this.secondPrice;
        data["firstNumber"] = this.firstNumber;
        data["secondNumber"] = this.secondNumber;
        data["firstWeight"] = this.firstWeight;
        data["secondWeight"] = this.secondWeight;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateShopFreightInput {
    id: number;
    displayName: string | undefined;
    orderNumber: number;
    shopShopFreightType: ShopFreightType;
    firstPrice: number;
    secondPrice: number;
    firstNumber: number | undefined;
    secondNumber: number | undefined;
    firstWeight: number | undefined;
    secondWeight: number | undefined;
    areas: AreaModel[] | undefined;
    status: ShopFreightStatus;
    isDefault: boolean;
}

export class ShopFreightDto implements IShopFreightDto {
    id!: number;
    tenantId!: number;
    displayName!: string | undefined;
    orderNumber!: number;
    shopShopFreightType!: ShopFreightType;
    firstPrice!: number;
    secondPrice!: number;
    firstNumber!: number | undefined;
    secondNumber!: number | undefined;
    firstWeight!: number | undefined;
    secondWeight!: number | undefined;
    areas!: AreaModel[] | undefined;
    status!: ShopFreightStatus;
    isDefault!: boolean;

    constructor(data?: IShopFreightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.displayName = _data["displayName"];
            this.orderNumber = _data["orderNumber"];
            this.shopShopFreightType = _data["shopShopFreightType"];
            this.firstPrice = _data["firstPrice"];
            this.secondPrice = _data["secondPrice"];
            this.firstNumber = _data["firstNumber"];
            this.secondNumber = _data["secondNumber"];
            this.firstWeight = _data["firstWeight"];
            this.secondWeight = _data["secondWeight"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(AreaModel.fromJS(item));
            }
            this.status = _data["status"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ShopFreightDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopFreightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["displayName"] = this.displayName;
        data["orderNumber"] = this.orderNumber;
        data["shopShopFreightType"] = this.shopShopFreightType;
        data["firstPrice"] = this.firstPrice;
        data["secondPrice"] = this.secondPrice;
        data["firstNumber"] = this.firstNumber;
        data["secondNumber"] = this.secondNumber;
        data["firstWeight"] = this.firstWeight;
        data["secondWeight"] = this.secondWeight;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IShopFreightDto {
    id: number;
    tenantId: number;
    displayName: string | undefined;
    orderNumber: number;
    shopShopFreightType: ShopFreightType;
    firstPrice: number;
    secondPrice: number;
    firstNumber: number | undefined;
    secondNumber: number | undefined;
    firstWeight: number | undefined;
    secondWeight: number | undefined;
    areas: AreaModel[] | undefined;
    status: ShopFreightStatus;
    isDefault: boolean;
}

export class PagedResultDtoOfShopFreightDto implements IPagedResultDtoOfShopFreightDto {
    totalCount!: number;
    items!: ShopFreightDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopFreightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopFreightDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopFreightDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopFreightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopFreightDto {
    totalCount: number;
    items: ShopFreightDto[] | undefined;
}

export class BindProductWithShopFreightInput implements IBindProductWithShopFreightInput {
    productId!: number;
    shopFreightId!: number;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;

    constructor(data?: IBindProductWithShopFreightInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
        }
    }

    static fromJS(data: any): BindProductWithShopFreightInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindProductWithShopFreightInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        return data; 
    }
}

export interface IBindProductWithShopFreightInput {
    productId: number;
    shopFreightId: number;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
}

export class CreateShopForHostInput implements ICreateShopForHostInput {
    displayName!: string | undefined;
    shopUrl!: string | undefined;
    tenantId!: number;

    constructor(data?: ICreateShopForHostInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.shopUrl = _data["shopUrl"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateShopForHostInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShopForHostInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["shopUrl"] = this.shopUrl;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateShopForHostInput {
    displayName: string | undefined;
    shopUrl: string | undefined;
    tenantId: number;
}

export class ShopDto implements IShopDto {
    id!: number;
    displayName!: string | undefined;
    shopUrl!: string | undefined;
    tenantId!: number;
    tenantName!: string | undefined;

    constructor(data?: IShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.shopUrl = _data["shopUrl"];
            this.tenantId = _data["tenantId"];
            this.tenantName = _data["tenantName"];
        }
    }

    static fromJS(data: any): ShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["shopUrl"] = this.shopUrl;
        data["tenantId"] = this.tenantId;
        data["tenantName"] = this.tenantName;
        return data; 
    }
}

export interface IShopDto {
    id: number;
    displayName: string | undefined;
    shopUrl: string | undefined;
    tenantId: number;
    tenantName: string | undefined;
}

export class PagedResultDtoOfShopDto implements IPagedResultDtoOfShopDto {
    totalCount!: number;
    items!: ShopDto[] | undefined;

    constructor(data?: IPagedResultDtoOfShopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShopDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfShopDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfShopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfShopDto {
    totalCount: number;
    items: ShopDto[] | undefined;
}

export class CreateSkuRfidInput implements ICreateSkuRfidInput {
    storeId!: number | undefined;
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    rfidCode!: string | undefined;

    constructor(data?: ICreateSkuRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.rfidCode = _data["rfidCode"];
        }
    }

    static fromJS(data: any): CreateSkuRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["rfidCode"] = this.rfidCode;
        return data; 
    }
}

export interface ICreateSkuRfidInput {
    storeId: number | undefined;
    skuId: number | undefined;
    sku_Id: string | undefined;
    rfidCode: string | undefined;
}

export class UpdateSkuRfidInput implements IUpdateSkuRfidInput {
    id!: number;
    storeId!: number | undefined;
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    rfidCode!: string | undefined;

    constructor(data?: IUpdateSkuRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.rfidCode = _data["rfidCode"];
        }
    }

    static fromJS(data: any): UpdateSkuRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["rfidCode"] = this.rfidCode;
        return data; 
    }
}

export interface IUpdateSkuRfidInput {
    id: number;
    storeId: number | undefined;
    skuId: number | undefined;
    sku_Id: string | undefined;
    rfidCode: string | undefined;
}

export enum SoftwareType {
    None = 0,
    GAME = 1,
    Behavior = 2,
    Shopping = 3,
    Customerize = 4,
}

export class AuthorizatedSoftwareDto implements IAuthorizatedSoftwareDto {
    alias!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    extensionData!: string | undefined;
    materialPacketUrl!: string | undefined;
    isDefault!: boolean;
    isExpired!: boolean;
    software!: SoftwareDto;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAuthorizatedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
            this.isExpired = _data["isExpired"];
            this.software = _data["software"] ? SoftwareDto.fromJS(_data["software"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuthorizatedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizatedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        data["isExpired"] = this.isExpired;
        data["software"] = this.software ? this.software.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuthorizatedSoftwareDto {
    alias: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    extensionData: string | undefined;
    materialPacketUrl: string | undefined;
    isDefault: boolean;
    isExpired: boolean;
    software: SoftwareDto;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfAuthorizatedSoftwareDto implements IPagedResultDtoOfAuthorizatedSoftwareDto {
    totalCount!: number;
    items!: AuthorizatedSoftwareDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuthorizatedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuthorizatedSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuthorizatedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuthorizatedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuthorizatedSoftwareDto {
    totalCount: number;
    items: AuthorizatedSoftwareDto[] | undefined;
}

export class PagedResultDtoOfSoftwareDto implements IPagedResultDtoOfSoftwareDto {
    totalCount!: number;
    items!: SoftwareDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSoftwareDto {
    totalCount: number;
    items: SoftwareDto[] | undefined;
}

export class GetSoftwareInput implements IGetSoftwareInput {
    softwareType!: SoftwareType;
    isShowToTenant!: boolean | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareType = _data["softwareType"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareType"] = this.softwareType;
        data["isShowToTenant"] = this.isShowToTenant;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetSoftwareInput {
    softwareType: SoftwareType;
    isShowToTenant: boolean | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export enum EnviormentEnum {
    H5Screen = 0,
    UWP = 1,
    WPF_Win32 = 2,
    Android = 3,
    IOS = 4,
}

export class CreateSoftwareInput implements ICreateSoftwareInput {
    name!: string | undefined;
    iconUrl!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: EnviormentEnum;
    versionNumber!: string | undefined;
    packageUrl!: string | undefined;
    exePath!: string | undefined;
    type!: SoftwareType;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean;
    isSendWechatBeforeGame!: boolean;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean;
    shareActionTabName!: string | undefined;

    constructor(data?: ICreateSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
        }
    }

    static fromJS(data: any): CreateSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        return data; 
    }
}

export interface ICreateSoftwareInput {
    name: string | undefined;
    iconUrl: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: EnviormentEnum;
    versionNumber: string | undefined;
    packageUrl: string | undefined;
    exePath: string | undefined;
    type: SoftwareType;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean;
    isSendWechatBeforeGame: boolean;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean;
    shareActionTabName: string | undefined;
}

export class UpdateSoftwareInput implements IUpdateSoftwareInput {
    id!: number;
    name!: string | undefined;
    iconUrl!: string | undefined;
    owner!: string | undefined;
    contact!: string | undefined;
    tenantId!: number | undefined;
    url!: string | undefined;
    logoUrl!: string | undefined;
    largeImageUrl!: string | undefined;
    envType!: EnviormentEnum;
    versionNumber!: string | undefined;
    packageUrl!: string | undefined;
    exePath!: string | undefined;
    type!: SoftwareType;
    targetResolution_Width!: number | undefined;
    targetResolution_Height!: number | undefined;
    setting!: string | undefined;
    language!: string | undefined;
    auditStatus!: AuditStatus;
    extensionData!: string | undefined;
    gameType!: GameTypeEnum;
    description!: string | undefined;
    isShowToTenant!: boolean;
    supportedPlayersCount!: number | undefined;
    isSupportAsync!: boolean;
    isSendWechatBeforeGame!: boolean;
    sendWeChatBeforGameTabName!: string | undefined;
    isSendWechatAfterGame!: boolean;
    sendWeChatAfterGameTabName!: string | undefined;
    isShareAction!: boolean;
    shareActionTabName!: string | undefined;

    constructor(data?: IUpdateSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.iconUrl = _data["iconUrl"];
            this.owner = _data["owner"];
            this.contact = _data["contact"];
            this.tenantId = _data["tenantId"];
            this.url = _data["url"];
            this.logoUrl = _data["logoUrl"];
            this.largeImageUrl = _data["largeImageUrl"];
            this.envType = _data["envType"];
            this.versionNumber = _data["versionNumber"];
            this.packageUrl = _data["packageUrl"];
            this.exePath = _data["exePath"];
            this.type = _data["type"];
            this.targetResolution_Width = _data["targetResolution_Width"];
            this.targetResolution_Height = _data["targetResolution_Height"];
            this.setting = _data["setting"];
            this.language = _data["language"];
            this.auditStatus = _data["auditStatus"];
            this.extensionData = _data["extensionData"];
            this.gameType = _data["gameType"];
            this.description = _data["description"];
            this.isShowToTenant = _data["isShowToTenant"];
            this.supportedPlayersCount = _data["supportedPlayersCount"];
            this.isSupportAsync = _data["isSupportAsync"];
            this.isSendWechatBeforeGame = _data["isSendWechatBeforeGame"];
            this.sendWeChatBeforGameTabName = _data["sendWeChatBeforGameTabName"];
            this.isSendWechatAfterGame = _data["isSendWechatAfterGame"];
            this.sendWeChatAfterGameTabName = _data["sendWeChatAfterGameTabName"];
            this.isShareAction = _data["isShareAction"];
            this.shareActionTabName = _data["shareActionTabName"];
        }
    }

    static fromJS(data: any): UpdateSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["iconUrl"] = this.iconUrl;
        data["owner"] = this.owner;
        data["contact"] = this.contact;
        data["tenantId"] = this.tenantId;
        data["url"] = this.url;
        data["logoUrl"] = this.logoUrl;
        data["largeImageUrl"] = this.largeImageUrl;
        data["envType"] = this.envType;
        data["versionNumber"] = this.versionNumber;
        data["packageUrl"] = this.packageUrl;
        data["exePath"] = this.exePath;
        data["type"] = this.type;
        data["targetResolution_Width"] = this.targetResolution_Width;
        data["targetResolution_Height"] = this.targetResolution_Height;
        data["setting"] = this.setting;
        data["language"] = this.language;
        data["auditStatus"] = this.auditStatus;
        data["extensionData"] = this.extensionData;
        data["gameType"] = this.gameType;
        data["description"] = this.description;
        data["isShowToTenant"] = this.isShowToTenant;
        data["supportedPlayersCount"] = this.supportedPlayersCount;
        data["isSupportAsync"] = this.isSupportAsync;
        data["isSendWechatBeforeGame"] = this.isSendWechatBeforeGame;
        data["sendWeChatBeforGameTabName"] = this.sendWeChatBeforGameTabName;
        data["isSendWechatAfterGame"] = this.isSendWechatAfterGame;
        data["sendWeChatAfterGameTabName"] = this.sendWeChatAfterGameTabName;
        data["isShareAction"] = this.isShareAction;
        data["shareActionTabName"] = this.shareActionTabName;
        return data; 
    }
}

export interface IUpdateSoftwareInput {
    id: number;
    name: string | undefined;
    iconUrl: string | undefined;
    owner: string | undefined;
    contact: string | undefined;
    tenantId: number | undefined;
    url: string | undefined;
    logoUrl: string | undefined;
    largeImageUrl: string | undefined;
    envType: EnviormentEnum;
    versionNumber: string | undefined;
    packageUrl: string | undefined;
    exePath: string | undefined;
    type: SoftwareType;
    targetResolution_Width: number | undefined;
    targetResolution_Height: number | undefined;
    setting: string | undefined;
    language: string | undefined;
    auditStatus: AuditStatus;
    extensionData: string | undefined;
    gameType: GameTypeEnum;
    description: string | undefined;
    isShowToTenant: boolean;
    supportedPlayersCount: number | undefined;
    isSupportAsync: boolean;
    isSendWechatBeforeGame: boolean;
    sendWeChatBeforGameTabName: string | undefined;
    isSendWechatAfterGame: boolean;
    sendWeChatAfterGameTabName: string | undefined;
    isShareAction: boolean;
    shareActionTabName: string | undefined;
}

export class AuthorizeSoftwareInput implements IAuthorizeSoftwareInput {
    softwareId!: number;
    alias!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    tenantId!: number;

    constructor(data?: IAuthorizeSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareId = _data["softwareId"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AuthorizeSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorizeSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareId"] = this.softwareId;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAuthorizeSoftwareInput {
    softwareId: number;
    alias: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    tenantId: number;
}

export class UpdateAuthorizeSoftwareInput implements IUpdateAuthorizeSoftwareInput {
    id!: number;
    alias!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    extensionData!: string | undefined;
    materialPacketUrl!: string | undefined;
    isDefault!: boolean;

    constructor(data?: IUpdateAuthorizeSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.extensionData = _data["extensionData"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateAuthorizeSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorizeSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["extensionData"] = this.extensionData;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IUpdateAuthorizeSoftwareInput {
    id: number;
    alias: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    extensionData: string | undefined;
    materialPacketUrl: string | undefined;
    isDefault: boolean;
}

export class DispatchedSoftwareDto implements IDispatchedSoftwareDto {
    id!: number;
    softwareId!: number;
    alias!: string | undefined;
    startTime!: DateTime | undefined;
    endTime!: DateTime | undefined;
    tenantName!: string | undefined;
    organizationUnitName!: string | undefined;
    tenantId!: number;

    constructor(data?: IDispatchedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.softwareId = _data["softwareId"];
            this.alias = _data["alias"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.tenantName = _data["tenantName"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): DispatchedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new DispatchedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["softwareId"] = this.softwareId;
        data["alias"] = this.alias;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["tenantName"] = this.tenantName;
        data["organizationUnitName"] = this.organizationUnitName;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IDispatchedSoftwareDto {
    id: number;
    softwareId: number;
    alias: string | undefined;
    startTime: DateTime | undefined;
    endTime: DateTime | undefined;
    tenantName: string | undefined;
    organizationUnitName: string | undefined;
    tenantId: number;
}

export class PagedResultDtoOfDispatchedSoftwareDto implements IPagedResultDtoOfDispatchedSoftwareDto {
    totalCount!: number;
    items!: DispatchedSoftwareDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDispatchedSoftwareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DispatchedSoftwareDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDispatchedSoftwareDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDispatchedSoftwareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDispatchedSoftwareDto {
    totalCount: number;
    items: DispatchedSoftwareDto[] | undefined;
}

export class UpdateDeviceSoftwareInput implements IUpdateDeviceSoftwareInput {
    softwareId!: number;
    deviceId!: number;
    isDefault!: boolean;
    hostingStatus!: string | undefined;
    materialPacketUrl!: string | undefined;
    extensionData!: string | undefined;
    alias!: string | undefined;

    constructor(data?: IUpdateDeviceSoftwareInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.softwareId = _data["softwareId"];
            this.deviceId = _data["deviceId"];
            this.isDefault = _data["isDefault"];
            this.hostingStatus = _data["hostingStatus"];
            this.materialPacketUrl = _data["materialPacketUrl"];
            this.extensionData = _data["extensionData"];
            this.alias = _data["alias"];
        }
    }

    static fromJS(data: any): UpdateDeviceSoftwareInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceSoftwareInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["softwareId"] = this.softwareId;
        data["deviceId"] = this.deviceId;
        data["isDefault"] = this.isDefault;
        data["hostingStatus"] = this.hostingStatus;
        data["materialPacketUrl"] = this.materialPacketUrl;
        data["extensionData"] = this.extensionData;
        data["alias"] = this.alias;
        return data; 
    }
}

export interface IUpdateDeviceSoftwareInput {
    softwareId: number;
    deviceId: number;
    isDefault: boolean;
    hostingStatus: string | undefined;
    materialPacketUrl: string | undefined;
    extensionData: string | undefined;
    alias: string | undefined;
}

export class AddOrUpdateStaff implements IAddOrUpdateStaff {
    account!: string | undefined;
    account_id!: number;
    alipay_account!: string | undefined;
    alipay_name!: string | undefined;
    authority!: string | undefined;
    erp_id!: string | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    post!: string | undefined;
    status!: number;
    store_id!: string | undefined;
    store_name!: string | undefined;

    constructor(data?: IAddOrUpdateStaff) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.account = _data["account"];
            this.account_id = _data["account_id"];
            this.alipay_account = _data["alipay_account"];
            this.alipay_name = _data["alipay_name"];
            this.authority = _data["authority"];
            this.erp_id = _data["erp_id"];
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.post = _data["post"];
            this.status = _data["status"];
            this.store_id = _data["store_id"];
            this.store_name = _data["store_name"];
        }
    }

    static fromJS(data: any): AddOrUpdateStaff {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateStaff();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account;
        data["account_id"] = this.account_id;
        data["alipay_account"] = this.alipay_account;
        data["alipay_name"] = this.alipay_name;
        data["authority"] = this.authority;
        data["erp_id"] = this.erp_id;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["post"] = this.post;
        data["status"] = this.status;
        data["store_id"] = this.store_id;
        data["store_name"] = this.store_name;
        return data; 
    }
}

export interface IAddOrUpdateStaff {
    account: string | undefined;
    account_id: number;
    alipay_account: string | undefined;
    alipay_name: string | undefined;
    authority: string | undefined;
    erp_id: string | undefined;
    name: string | undefined;
    phone: string | undefined;
    post: string | undefined;
    status: number;
    store_id: string | undefined;
    store_name: string | undefined;
}

export class AddOrUpdateStaffs implements IAddOrUpdateStaffs {
    staffs!: AddOrUpdateStaff[] | undefined;

    constructor(data?: IAddOrUpdateStaffs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["staffs"])) {
                this.staffs = [] as any;
                for (let item of _data["staffs"])
                    this.staffs!.push(AddOrUpdateStaff.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateStaffs {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateStaffs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.staffs)) {
            data["staffs"] = [];
            for (let item of this.staffs)
                data["staffs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateStaffs {
    staffs: AddOrUpdateStaff[] | undefined;
}

export class SimpleStorePositionDto implements ISimpleStorePositionDto {
    storeId!: number;
    city!: string | undefined;
    location!: string | undefined;

    constructor(data?: ISimpleStorePositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.city = _data["city"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): SimpleStorePositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleStorePositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["city"] = this.city;
        data["location"] = this.location;
        return data; 
    }
}

export interface ISimpleStorePositionDto {
    storeId: number;
    city: string | undefined;
    location: string | undefined;
}

export class SimpleStorePositionInput implements ISimpleStorePositionInput {
    lng!: number | undefined;
    lat!: number | undefined;
    storeId!: number;

    constructor(data?: ISimpleStorePositionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lng = _data["lng"];
            this.lat = _data["lat"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): SimpleStorePositionInput {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleStorePositionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lng"] = this.lng;
        data["lat"] = this.lat;
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface ISimpleStorePositionInput {
    lng: number | undefined;
    lat: number | undefined;
    storeId: number;
}

export class ListResultDtoOfStoresDto implements IListResultDtoOfStoresDto {
    items!: StoresDto[] | undefined;

    constructor(data?: IListResultDtoOfStoresDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoresDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfStoresDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfStoresDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfStoresDto {
    items: StoresDto[] | undefined;
}

export class GetStorseListInput implements IGetStorseListInput {
    organizationUnitId!: number[] | undefined;
    storeStatus!: StoreStatus;
    areas!: string[] | undefined;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetStorseListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["organizationUnitId"])) {
                this.organizationUnitId = [] as any;
                for (let item of _data["organizationUnitId"])
                    this.organizationUnitId!.push(item);
            }
            this.storeStatus = _data["storeStatus"];
            if (Array.isArray(_data["areas"])) {
                this.areas = [] as any;
                for (let item of _data["areas"])
                    this.areas!.push(item);
            }
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetStorseListInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStorseListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.organizationUnitId)) {
            data["organizationUnitId"] = [];
            for (let item of this.organizationUnitId)
                data["organizationUnitId"].push(item);
        }
        data["storeStatus"] = this.storeStatus;
        if (Array.isArray(this.areas)) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item);
        }
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetStorseListInput {
    organizationUnitId: number[] | undefined;
    storeStatus: StoreStatus;
    areas: string[] | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class StorePositionDto implements IStorePositionDto {
    id!: number;
    outerId!: string | undefined;
    displayName!: string | undefined;
    position!: PositionDto;

    constructor(data?: IStorePositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.displayName = _data["displayName"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StorePositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorePositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["displayName"] = this.displayName;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStorePositionDto {
    id: number;
    outerId: string | undefined;
    displayName: string | undefined;
    position: PositionDto;
}

export class PagedResultDtoOfStorePositionDto implements IPagedResultDtoOfStorePositionDto {
    totalCount!: number;
    items!: StorePositionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStorePositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StorePositionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStorePositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStorePositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStorePositionDto {
    totalCount: number;
    items: StorePositionDto[] | undefined;
}

export class CreateStoreInput implements ICreateStoreInput {
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    contact!: string | undefined;
    categoryId!: string | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    qrcodeRules!: string | undefined;
    defaultOnlineShopName!: string | undefined;
    type!: StoreType;
    displayName!: string;
    organizationUnitId!: number | undefined;
    taobaoStoreId!: string | undefined;
    storeType!: string | undefined;
    storeDevicesInfo!: string | undefined;
    roomIds!: string | undefined;
    brandId!: number | undefined;

    constructor(data?: ICreateStoreInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.contact = _data["contact"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrcodeRules = _data["qrcodeRules"];
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.type = _data["type"];
            this.displayName = _data["displayName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.storeType = _data["storeType"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.roomIds = _data["roomIds"];
            this.brandId = _data["brandId"];
        }
    }

    static fromJS(data: any): CreateStoreInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStoreInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["contact"] = this.contact;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrcodeRules"] = this.qrcodeRules;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["type"] = this.type;
        data["displayName"] = this.displayName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["storeType"] = this.storeType;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["roomIds"] = this.roomIds;
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface ICreateStoreInput {
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    contact: string | undefined;
    categoryId: string | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    qrcodeRules: string | undefined;
    defaultOnlineShopName: string | undefined;
    type: StoreType;
    displayName: string;
    organizationUnitId: number | undefined;
    taobaoStoreId: string | undefined;
    storeType: string | undefined;
    storeDevicesInfo: string | undefined;
    roomIds: string | undefined;
    brandId: number | undefined;
}

export class UpdateStoreInput implements IUpdateStoreInput {
    id!: number;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    contact!: string | undefined;
    categoryId!: string | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    qrcodeRules!: string | undefined;
    defaultOnlineShopName!: string | undefined;
    type!: StoreType;
    displayName!: string;
    organizationUnitId!: number | undefined;
    taobaoStoreId!: string | undefined;
    storeType!: string | undefined;
    storeDevicesInfo!: string | undefined;
    roomIds!: string | undefined;
    brandId!: number | undefined;

    constructor(data?: IUpdateStoreInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.contact = _data["contact"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrcodeRules = _data["qrcodeRules"];
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.type = _data["type"];
            this.displayName = _data["displayName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.storeType = _data["storeType"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.roomIds = _data["roomIds"];
            this.brandId = _data["brandId"];
        }
    }

    static fromJS(data: any): UpdateStoreInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["contact"] = this.contact;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrcodeRules"] = this.qrcodeRules;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["type"] = this.type;
        data["displayName"] = this.displayName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["storeType"] = this.storeType;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["roomIds"] = this.roomIds;
        data["brandId"] = this.brandId;
        return data; 
    }
}

export interface IUpdateStoreInput {
    id: number;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    contact: string | undefined;
    categoryId: string | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    qrcodeRules: string | undefined;
    defaultOnlineShopName: string | undefined;
    type: StoreType;
    displayName: string;
    organizationUnitId: number | undefined;
    taobaoStoreId: string | undefined;
    storeType: string | undefined;
    storeDevicesInfo: string | undefined;
    roomIds: string | undefined;
    brandId: number | undefined;
}

export class Position implements IPosition {
    state!: string | undefined;
    area!: string | undefined;
    province!: string | undefined;
    city!: string | undefined;
    county!: string | undefined;
    location!: string | undefined;
    zipCode!: string | undefined;
    longitude!: number | undefined;
    latitude!: number | undefined;
    code!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.area = _data["area"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.location = _data["location"];
            this.zipCode = _data["zipCode"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.code = _data["code"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["area"] = this.area;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["location"] = this.location;
        data["zipCode"] = this.zipCode;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["code"] = this.code;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPosition {
    state: string | undefined;
    area: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    location: string | undefined;
    zipCode: string | undefined;
    longitude: number | undefined;
    latitude: number | undefined;
    code: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class Store implements IStore {
    organizationUnitId!: number | undefined;
    isNeedThingApprove!: boolean;
    isNeedAdsApprove!: boolean;
    isNeedAppApprove!: boolean;
    isNeedDeviceApprove!: boolean;
    isNeedCouponApprove!: boolean;
    isAdsAutoSendDown!: boolean;
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    isCouponAutoSendDown!: boolean;
    canAcceptAdsAutoSendDown!: boolean;
    canAcceptAppAutoSendDown!: boolean;
    canAcceptProductAutoSendDown!: boolean;
    canAcceptCouponAutoSendDown!: boolean;
    position!: Position;
    storeType!: string | undefined;
    storeDevicesInfo!: string | undefined;
    storeStatus!: StoreStatus;
    roomIds!: string | undefined;
    brandId!: number | undefined;
    tenantId!: number;
    displayName!: string;
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    logoUrl!: string | undefined;
    webAddressUrl!: string | undefined;
    qrCodeUrl!: string | undefined;
    contact!: string | undefined;
    categoryId!: string | undefined;
    positionId!: number | undefined;
    addressDetail!: string | undefined;
    openingTime!: DateTime | undefined;
    closedTime!: DateTime | undefined;
    qrcodeRules!: string | undefined;
    defaultOnlineShopName!: string | undefined;
    type!: StoreType;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.storeType = _data["storeType"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.storeStatus = _data["storeStatus"];
            this.roomIds = _data["roomIds"];
            this.brandId = _data["brandId"];
            this.tenantId = _data["tenantId"];
            this.displayName = _data["displayName"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.contact = _data["contact"];
            this.categoryId = _data["categoryId"];
            this.positionId = _data["positionId"];
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? DateTime.fromISO(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? DateTime.fromISO(_data["closedTime"].toString()) : <any>undefined;
            this.qrcodeRules = _data["qrcodeRules"];
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.type = _data["type"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["storeType"] = this.storeType;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["storeStatus"] = this.storeStatus;
        data["roomIds"] = this.roomIds;
        data["brandId"] = this.brandId;
        data["tenantId"] = this.tenantId;
        data["displayName"] = this.displayName;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["contact"] = this.contact;
        data["categoryId"] = this.categoryId;
        data["positionId"] = this.positionId;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toString() : <any>undefined;
        data["qrcodeRules"] = this.qrcodeRules;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["type"] = this.type;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStore {
    organizationUnitId: number | undefined;
    isNeedThingApprove: boolean;
    isNeedAdsApprove: boolean;
    isNeedAppApprove: boolean;
    isNeedDeviceApprove: boolean;
    isNeedCouponApprove: boolean;
    isAdsAutoSendDown: boolean;
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    isCouponAutoSendDown: boolean;
    canAcceptAdsAutoSendDown: boolean;
    canAcceptAppAutoSendDown: boolean;
    canAcceptProductAutoSendDown: boolean;
    canAcceptCouponAutoSendDown: boolean;
    position: Position;
    storeType: string | undefined;
    storeDevicesInfo: string | undefined;
    storeStatus: StoreStatus;
    roomIds: string | undefined;
    brandId: number | undefined;
    tenantId: number;
    displayName: string;
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    logoUrl: string | undefined;
    webAddressUrl: string | undefined;
    qrCodeUrl: string | undefined;
    contact: string | undefined;
    categoryId: string | undefined;
    positionId: number | undefined;
    addressDetail: string | undefined;
    openingTime: DateTime | undefined;
    closedTime: DateTime | undefined;
    qrcodeRules: string | undefined;
    defaultOnlineShopName: string | undefined;
    type: StoreType;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PublishStoresInput implements IPublishStoresInput {
    entityIds!: number[] | undefined;
    ouList!: IdTypeDto[] | undefined;
    action!: string | undefined;

    constructor(data?: IPublishStoresInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(_data["ouList"])) {
                this.ouList = [] as any;
                for (let item of _data["ouList"])
                    this.ouList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): PublishStoresInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishStoresInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouList)) {
            data["ouList"] = [];
            for (let item of this.ouList)
                data["ouList"].push(item.toJSON());
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface IPublishStoresInput {
    entityIds: number[] | undefined;
    ouList: IdTypeDto[] | undefined;
    action: string | undefined;
}

export class StoreAuditInput implements IStoreAuditInput {
    storeIds!: number[] | undefined;
    currentAuditStatus!: StoreStatus;
    targetAuditStatus!: StoreStatus;

    constructor(data?: IStoreAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.currentAuditStatus = _data["currentAuditStatus"];
            this.targetAuditStatus = _data["targetAuditStatus"];
        }
    }

    static fromJS(data: any): StoreAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new StoreAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["currentAuditStatus"] = this.currentAuditStatus;
        data["targetAuditStatus"] = this.targetAuditStatus;
        return data; 
    }
}

export interface IStoreAuditInput {
    storeIds: number[] | undefined;
    currentAuditStatus: StoreStatus;
    targetAuditStatus: StoreStatus;
}

export class CreateStoreExtraInput implements ICreateStoreExtraInput {
    storeId!: number;
    platformType!: ExternalEnum;
    extraStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;

    constructor(data?: ICreateStoreExtraInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.platformType = _data["platformType"];
            this.extraStoreId = _data["extraStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
        }
    }

    static fromJS(data: any): CreateStoreExtraInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStoreExtraInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["platformType"] = this.platformType;
        data["extraStoreId"] = this.extraStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        return data; 
    }
}

export interface ICreateStoreExtraInput {
    storeId: number;
    platformType: ExternalEnum;
    extraStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
}

export class StoreExtraDto implements IStoreExtraDto {
    tenantId!: number;
    storeId!: number;
    storeName!: string | undefined;
    platformType!: ExternalEnum;
    extraStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IStoreExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.platformType = _data["platformType"];
            this.extraStoreId = _data["extraStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["platformType"] = this.platformType;
        data["extraStoreId"] = this.extraStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreExtraDto {
    tenantId: number;
    storeId: number;
    storeName: string | undefined;
    platformType: ExternalEnum;
    extraStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class UpdateStoreExtraInput implements IUpdateStoreExtraInput {
    id!: number;
    storeId!: number;
    platformType!: ExternalEnum;
    extraStoreId!: string | undefined;
    contact!: string | undefined;
    bizType!: string | undefined;
    categoryId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;

    constructor(data?: IUpdateStoreExtraInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.platformType = _data["platformType"];
            this.extraStoreId = _data["extraStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
        }
    }

    static fromJS(data: any): UpdateStoreExtraInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreExtraInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["platformType"] = this.platformType;
        data["extraStoreId"] = this.extraStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        return data; 
    }
}

export interface IUpdateStoreExtraInput {
    id: number;
    storeId: number;
    platformType: ExternalEnum;
    extraStoreId: string | undefined;
    contact: string | undefined;
    bizType: string | undefined;
    categoryId: string | undefined;
    qrCodeExtraInfo: string | undefined;
}

export class PagedResultDtoOfStoreExtraDto implements IPagedResultDtoOfStoreExtraDto {
    totalCount!: number;
    items!: StoreExtraDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreExtraDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStoreExtraDto {
    totalCount: number;
    items: StoreExtraDto[] | undefined;
}

export class StoreKPIDto implements IStoreKPIDto {
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    scaleTime!: DateTime;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IStoreKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.scaleTime = _data["scaleTime"] ? DateTime.fromISO(_data["scaleTime"].toString()) : <any>undefined;
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StoreKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["scaleTime"] = this.scaleTime ? this.scaleTime.toString() : <any>undefined;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStoreKPIDto {
    storeName: string | undefined;
    storeOuterId: string | undefined;
    scaleTime: DateTime;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfStoreKPIDto implements IPagedResultDtoOfStoreKPIDto {
    totalCount!: number;
    items!: StoreKPIDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStoreKPIDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreKPIDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStoreKPIDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStoreKPIDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfStoreKPIDto {
    totalCount: number;
    items: StoreKPIDto[] | undefined;
}

export class CreateStoreKpiDtoInput implements ICreateStoreKpiDtoInput {
    storeId!: number;
    scaleTime!: string | undefined;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;

    constructor(data?: ICreateStoreKpiDtoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.scaleTime = _data["scaleTime"];
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateStoreKpiDtoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStoreKpiDtoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["scaleTime"] = this.scaleTime;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateStoreKpiDtoInput {
    storeId: number;
    scaleTime: string | undefined;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
}

export class UpdateStoreKpiDtoInput implements IUpdateStoreKpiDtoInput {
    id!: number;
    storeId!: number;
    scaleTime!: string | undefined;
    kpiScale!: GroupKPIScaleEnum;
    name!: string | undefined;
    value!: number;
    description!: string | undefined;

    constructor(data?: IUpdateStoreKpiDtoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.scaleTime = _data["scaleTime"];
            this.kpiScale = _data["kpiScale"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateStoreKpiDtoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreKpiDtoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["scaleTime"] = this.scaleTime;
        data["kpiScale"] = this.kpiScale;
        data["name"] = this.name;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateStoreKpiDtoInput {
    id: number;
    storeId: number;
    scaleTime: string | undefined;
    kpiScale: GroupKPIScaleEnum;
    name: string | undefined;
    value: number;
    description: string | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data; 
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDone"] = this.paymentDone;
        return data; 
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class PagedResultDtoOfTagDto implements IPagedResultDtoOfTagDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTagDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    orderNumber: number;
    description: string | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    orderNumber: number;
    description: string | undefined;
}

export class TaobaoOpenPlatformDto implements ITaobaoOpenPlatformDto {
    appName!: string | undefined;
    appKey!: string | undefined;
    icon!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;
    id!: number;

    constructor(data?: ITaobaoOpenPlatformDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.appKey = _data["appKey"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaobaoOpenPlatformDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaobaoOpenPlatformDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["appKey"] = this.appKey;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["type"] = this.type;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaobaoOpenPlatformDto {
    appName: string | undefined;
    appKey: string | undefined;
    icon: string | undefined;
    name: string | undefined;
    type: string | undefined;
    id: number;
}

export class PagedResultDtoOfTaobaoOpenPlatformDto implements IPagedResultDtoOfTaobaoOpenPlatformDto {
    totalCount!: number;
    items!: TaobaoOpenPlatformDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaobaoOpenPlatformDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TaobaoOpenPlatformDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaobaoOpenPlatformDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaobaoOpenPlatformDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTaobaoOpenPlatformDto {
    totalCount: number;
    items: TaobaoOpenPlatformDto[] | undefined;
}

export class CreateTaobaoOpenPlatformInput implements ICreateTaobaoOpenPlatformInput {
    appName!: string | undefined;
    appKey!: string | undefined;
    icon!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: ICreateTaobaoOpenPlatformInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appName = _data["appName"];
            this.appKey = _data["appKey"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateTaobaoOpenPlatformInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTaobaoOpenPlatformInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["appKey"] = this.appKey;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICreateTaobaoOpenPlatformInput {
    appName: string | undefined;
    appKey: string | undefined;
    icon: string | undefined;
    name: string | undefined;
    type: string | undefined;
}

export class UpdateTaobaoOpenPlatformInput implements IUpdateTaobaoOpenPlatformInput {
    id!: number;
    appName!: string | undefined;
    appKey!: string | undefined;
    icon!: string | undefined;
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: IUpdateTaobaoOpenPlatformInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appName = _data["appName"];
            this.appKey = _data["appKey"];
            this.icon = _data["icon"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UpdateTaobaoOpenPlatformInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTaobaoOpenPlatformInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appName"] = this.appName;
        data["appKey"] = this.appKey;
        data["icon"] = this.icon;
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUpdateTaobaoOpenPlatformInput {
    id: number;
    appName: string | undefined;
    appKey: string | undefined;
    icon: string | undefined;
    name: string | undefined;
    type: string | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    subscriptionEndDateUtc!: DateTime | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    subscriptionEndDateUtc: DateTime | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data; 
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data; 
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class OssSettingEditDto implements IOssSettingEditDto {
    bucketName!: string | undefined;
    endpoint!: string | undefined;
    accessKeyId!: string | undefined;
    accessKeySecret!: string | undefined;

    constructor(data?: IOssSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bucketName = _data["bucketName"];
            this.endpoint = _data["endpoint"];
            this.accessKeyId = _data["accessKeyId"];
            this.accessKeySecret = _data["accessKeySecret"];
        }
    }

    static fromJS(data: any): OssSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OssSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bucketName"] = this.bucketName;
        data["endpoint"] = this.endpoint;
        data["accessKeyId"] = this.accessKeyId;
        data["accessKeySecret"] = this.accessKeySecret;
        return data; 
    }
}

export interface IOssSettingEditDto {
    bucketName: string | undefined;
    endpoint: string | undefined;
    accessKeyId: string | undefined;
    accessKeySecret: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;
    oss!: OssSettingEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
            this.oss = _data["oss"] ? OssSettingEditDto.fromJS(_data["oss"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        data["oss"] = this.oss ? this.oss.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
    oss: OssSettingEditDto;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class AuthenticateResultModelWithTenant implements IAuthenticateResultModelWithTenant {
    tenantId!: number | undefined;
    authenticateResultModel!: AuthenticateResultModel;

    constructor(data?: IAuthenticateResultModelWithTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.authenticateResultModel = _data["authenticateResultModel"] ? AuthenticateResultModel.fromJS(_data["authenticateResultModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticateResultModelWithTenant {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModelWithTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["authenticateResultModel"] = this.authenticateResultModel ? this.authenticateResultModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAuthenticateResultModelWithTenant {
    tenantId: number | undefined;
    authenticateResultModel: AuthenticateResultModel;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data; 
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter!: string | undefined;
    permissions!: string[] | undefined;
    role!: number | undefined;
    onlyLockedUsers!: boolean;
    organizationUnitId!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.role = _data["role"];
            this.onlyLockedUsers = _data["onlyLockedUsers"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["organizationUnitId"] = this.organizationUnitId;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permissions: string[] | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean;
    organizationUnitId: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    outerId!: string | undefined;
    canApiAccess!: boolean;
    isStaff!: boolean;
    gender!: string | undefined;
    rfidCode!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.outerId = _data["outerId"];
            this.canApiAccess = _data["canApiAccess"];
            this.isStaff = _data["isStaff"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["outerId"] = this.outerId;
        data["canApiAccess"] = this.canApiAccess;
        data["isStaff"] = this.isStaff;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    outerId: string | undefined;
    canApiAccess: boolean;
    isStaff: boolean;
    gender: string | undefined;
    rfidCode: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class CreateOrUpdateUserOnlineStoreProfileInput implements ICreateOrUpdateUserOnlineStoreProfileInput {
    id!: number | undefined;
    onlineStoreName!: string | undefined;
    code!: string | undefined;

    constructor(data?: ICreateOrUpdateUserOnlineStoreProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUserOnlineStoreProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserOnlineStoreProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["onlineStoreName"] = this.onlineStoreName;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICreateOrUpdateUserOnlineStoreProfileInput {
    id: number | undefined;
    onlineStoreName: string | undefined;
    code: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;
    onlineStoreProfiles!: CreateOrUpdateUserOnlineStoreProfileInput[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
            if (Array.isArray(_data["onlineStoreProfiles"])) {
                this.onlineStoreProfiles = [] as any;
                for (let item of _data["onlineStoreProfiles"])
                    this.onlineStoreProfiles!.push(CreateOrUpdateUserOnlineStoreProfileInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        if (Array.isArray(this.onlineStoreProfiles)) {
            data["onlineStoreProfiles"] = [];
            for (let item of this.onlineStoreProfiles)
                data["onlineStoreProfiles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    onlineStoreProfiles: CreateOrUpdateUserOnlineStoreProfileInput[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;
    isUpdateOrganizationUnit!: boolean;
    onlineStoreProfiles!: CreateOrUpdateUserOnlineStoreProfileInput[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
            this.isUpdateOrganizationUnit = _data["isUpdateOrganizationUnit"];
            if (Array.isArray(_data["onlineStoreProfiles"])) {
                this.onlineStoreProfiles = [] as any;
                for (let item of _data["onlineStoreProfiles"])
                    this.onlineStoreProfiles!.push(CreateOrUpdateUserOnlineStoreProfileInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        data["isUpdateOrganizationUnit"] = this.isUpdateOrganizationUnit;
        if (Array.isArray(this.onlineStoreProfiles)) {
            data["onlineStoreProfiles"] = [];
            for (let item of this.onlineStoreProfiles)
                data["onlineStoreProfiles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
    isUpdateOrganizationUnit: boolean;
    onlineStoreProfiles: CreateOrUpdateUserOnlineStoreProfileInput[] | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: DateTime;
    endTime!: DateTime;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: DateTime;
    endTime: DateTime;
    id: number;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        return data; 
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: DateTime;
    endTime: DateTime;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: DateTime;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: DateTime;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: DateTime | undefined;
    id!: string;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: DateTime;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: DateTime | undefined;
    id: string;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data; 
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        this.headers![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; };
    stripe!: { [key: string]: string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in _data["Paypal"]) {
                    if (_data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = _data["Paypal"][key];
                }
            }
            if (_data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in _data["Stripe"]) {
                    if (_data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = _data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; };
    stripe: { [key: string]: string; };
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}