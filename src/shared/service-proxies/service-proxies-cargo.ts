/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.3.0 (NJsonSchema v10.3.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_CARGO_URL = new InjectionToken<string>('API_CARGO_URL');

@Injectable()
export class AppPodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAppPods(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAppPodDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPods?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPods(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAppPodDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAppPodDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPods(response: HttpResponseBase): Observable<PagedResultDtoOfAppPodDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppPodDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAppPodDto>(<any>null);
    }

    /**
     * 获取单个apppod的版本信息
     * @param appPodId (optional) 
     * @param osType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAppPodVersions(appPodId: number | null | undefined, osType: OsType | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodVersions?";
        if (appPodId !== undefined && appPodId !== null)
            url_ += "AppPodId=" + encodeURIComponent("" + appPodId) + "&";
        if (osType !== undefined && osType !== null)
            url_ += "OsType=" + encodeURIComponent("" + osType) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodVersions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodVersions(response: HttpResponseBase): Observable<PagedResultDtoOfAppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAppPodVersionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAppPodVersionDetail(id: number | null | undefined): Observable<AppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodVersionDetail?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodVersionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodVersionDetail(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodVersionDetail(response: HttpResponseBase): Observable<AppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersionDto>(<any>null);
    }

    /**
     * 获取某个产品的最新版本信息
     * @param appPodId (optional) 
     * @return Success
     */
    getAppPodLatestVersionDetail(appPodId: number | null | undefined): Observable<AppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodLatestVersionDetail?";
        if (appPodId !== undefined && appPodId !== null)
            url_ += "appPodId=" + encodeURIComponent("" + appPodId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodLatestVersionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodLatestVersionDetail(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodLatestVersionDetail(response: HttpResponseBase): Observable<AppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersionDto>(<any>null);
    }

    /**
     * 创建Apppod version
     * @param input (optional) 
     * @return Success
     */
    createAppPodVersion(input: CreateAppPodVersionInput | null | undefined): Observable<AppPodVersion> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/CreateAppPodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersion>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersion>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppPodVersion(response: HttpResponseBase): Observable<AppPodVersion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersion.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersion>(<any>null);
    }

    /**
     * 更新appPod
     * @param input (optional) 
     * @return Success
     */
    updateAppPodVersion(input: UpdateAppPodVersionInput | null | undefined): Observable<AppPodVersion> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/UpdateAppPodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersion>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersion>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppPodVersion(response: HttpResponseBase): Observable<AppPodVersion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersion.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersion>(<any>null);
    }
}

@Injectable()
export class CargoRoadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param deviceId (optional) 
     * @param isEnabled (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoRoadsByDevice(deviceId: number | null | undefined, isEnabled: boolean | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCargoRoadDto> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/GetCargoRoadsByDevice?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (isEnabled !== undefined && isEnabled !== null)
            url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadsByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadsByDevice(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCargoRoadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCargoRoadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadsByDevice(response: HttpResponseBase): Observable<PagedResultDtoOfCargoRoadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCargoRoadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCargoRoadDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCargoRoadById(id: number | null | undefined): Observable<CargoRoadDto> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/GetCargoRoadById?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadById(<any>response_);
                } catch (e) {
                    return <Observable<CargoRoadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoRoadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadById(response: HttpResponseBase): Observable<CargoRoadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoRoadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoRoadDto>(<any>null);
    }

    /**
     * 创建货道
     * @param input (optional) 
     * @return Success
     */
    createCargoRoad(input: CreateCargoRoadsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/CreateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateStatus(input: UpdateCargoStatusInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/UpdateStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateCargoRoad(input: AddOrUpdateCargoRoadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/AddOrUpdateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新货道
     * @param input (optional) 
     * @return Success
     */
    updateCargoRoad(input: UpdateCargoRoadsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/UpdateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCargoRoadPost(input: UpdateCargoRoadsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/UpdateCargoRoadPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoRoadPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoRoadPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoRoadPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/Delete?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteMany(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/DeleteMany?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据code 批量删除
     * @param codes (optional) 
     * @return Success
     */
    deleteCargoRoadByCodes(codes: string[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/DeleteCargoRoadByCodes?";
        if (codes !== undefined && codes !== null)
            codes && codes.forEach(item => { url_ += "codes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCargoRoadByCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCargoRoadByCodes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCargoRoadByCodes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据subkey获取所有货道历史纪录
     * @param deviceId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoHisotory(deviceId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCargoHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/CargoRoad/GetCargoHisotory?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoHisotory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoHisotory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCargoHistoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCargoHistoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoHisotory(response: HttpResponseBase): Observable<PagedResultDtoOfCargoHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCargoHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCargoHistoryDto>(<any>null);
    }
}

@Injectable()
export class CounterAnalysisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建网关与客流分析设备绑定关系
     * @param input (optional) 
     * @return Success
     */
    bindDevicesToGateway(input: BindDevicesToGatewayInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/BindDevicesToGateway";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindDevicesToGateway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindDevicesToGateway(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindDevicesToGateway(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除网关后解除全部绑定关系
     * @param deviceId (optional) 
     * @return Success
     */
    getGatewayByDeviceId(deviceId: number | null | undefined): Observable<GetGatewayInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetGatewayByDeviceId?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatewayByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatewayByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<GetGatewayInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGatewayInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatewayByDeviceId(response: HttpResponseBase): Observable<GetGatewayInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGatewayInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGatewayInfoDto>(<any>null);
    }

    /**
     * 批量删除设备后解除全部绑定关系
     * @param deviceIds (optional) 
     * @return Success
     */
    deleteBindByDeleteDevices(deviceIds: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/DeleteBindByDeleteDevices?";
        if (deviceIds !== undefined && deviceIds !== null)
            deviceIds && deviceIds.forEach(item => { url_ += "DeviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBindByDeleteDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBindByDeleteDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBindByDeleteDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据网关查询客流设备信息
     * @param gatewayId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDevicesBygatewayId(gatewayId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGatewayBindDeviceDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetDevicesBygatewayId?";
        if (gatewayId !== undefined && gatewayId !== null)
            url_ += "GatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevicesBygatewayId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevicesBygatewayId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGatewayBindDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGatewayBindDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevicesBygatewayId(response: HttpResponseBase): Observable<PagedResultDtoOfGatewayBindDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGatewayBindDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGatewayBindDeviceDto>(<any>null);
    }

    /**
     * 创建设备计数器
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateCounters(input: CreateCounterInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/AddOrUpdateCounters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateCounters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateCounters(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateCounters(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备计数器详情
     * @param id (optional) 
     * @return Success
     */
    getDeviceCounterDetails(id: number | null | undefined): Observable<GetCounerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetDeviceCounterDetails?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetCounerInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCounerInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterDetails(response: HttpResponseBase): Observable<GetCounerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCounerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCounerInfoDto>(<any>null);
    }

    /**
     * 删除设备计数器
     * @param id (optional) 
     * @return Success
     */
    deleteDeviceCounter(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/DeleteDeviceCounter?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceCounter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceCounter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceCounter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询设备计数器
     * @param id (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCountersByDeviceId(id: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetDeviceCounterDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetCountersByDeviceId?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountersByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountersByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetDeviceCounterDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetDeviceCounterDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountersByDeviceId(response: HttpResponseBase): Observable<PagedResultDtoOfGetDeviceCounterDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDeviceCounterDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetDeviceCounterDto>(<any>null);
    }

    /**
     * 写入计数流水
     * @param input (optional) 
     * @return Success
     */
    createCountRecords(input: CreateCountRecordInput[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/CreateCountRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCountRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCountRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCountRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 统计计数
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getCountByDeviceIds(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, counterId: number | null | undefined, deviceId: number[] | null | undefined): Observable<GetCountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetCountByDeviceIds?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId !== undefined && counterId !== null)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<GetCountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountByDeviceIds(response: HttpResponseBase): Observable<GetCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountDto[]>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getDigitCountByDeviceIds(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, counterId: number | null | undefined, deviceId: number[] | null | undefined): Observable<GetCountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetDigitCountByDeviceIds?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId !== undefined && counterId !== null)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDigitCountByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDigitCountByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<GetCountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDigitCountByDeviceIds(response: HttpResponseBase): Observable<GetCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountDto[]>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getDigitCountToExcel(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, counterId: number | null | undefined, deviceId: number[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetDigitCountToExcel?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId !== undefined && counterId !== null)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDigitCountToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDigitCountToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDigitCountToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getCountToExcel(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, counterId: number | null | undefined, deviceId: number[] | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetCountToExcel?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId !== undefined && counterId !== null)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 写入计数器标签
     * @param input (optional) 
     * @return Success
     */
    bindCounterTags(input: CreateCounterTagInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/BindCounterTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindCounterTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindCounterTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindCounterTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询计数器标签
     * @param counterId (optional) 
     * @return Success
     */
    getCounterTags(counterId: number | null | undefined): Observable<GetCounterTagInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetCounterTags?";
        if (counterId !== undefined && counterId !== null)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterTags(<any>response_);
                } catch (e) {
                    return <Observable<GetCounterTagInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCounterTagInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounterTags(response: HttpResponseBase): Observable<GetCounterTagInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCounterTagInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCounterTagInfoDto[]>(<any>null);
    }

    /**
     * 绑定计数器标签
     * @param input (optional) 
     * @return Success
     */
    updateCounterTags(input: UpdateCounterTagInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/UpdateCounterTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCounterTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCounterTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCounterTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateGatewayInfo(input: AddOrUpdateGatewayInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/AddOrUpdateGatewayInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateGatewayInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateGatewayInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateGatewayInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateSensorInfo(input: AddOrUpdateSensorInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/AddOrUpdateSensorInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateSensorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateSensorInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateSensorInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param deviceId (optional) 
     * @return Success
     */
    getGatewayOrSensorInfo(id: number | null | undefined, deviceId: number | null | undefined): Observable<GetGatewayOrSensorDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetGatewayOrSensorInfo?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatewayOrSensorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatewayOrSensorInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetGatewayOrSensorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGatewayOrSensorDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatewayOrSensorInfo(response: HttpResponseBase): Observable<GetGatewayOrSensorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGatewayOrSensorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGatewayOrSensorDto>(<any>null);
    }

    /**
     * @param gatewayId (optional) 
     * @return Success
     */
    getSensorAdd(gatewayId: number | null | undefined): Observable<GetAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/GetSensorAdd?";
        if (gatewayId !== undefined && gatewayId !== null)
            url_ += "GatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSensorAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSensorAdd(<any>response_);
                } catch (e) {
                    return <Observable<GetAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSensorAdd(response: HttpResponseBase): Observable<GetAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAddressDto>(<any>null);
    }

    /**
     * @param gatewayId (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifySensorAdd(gatewayId: number | null | undefined, address: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/CounterAnalysis/VerifySensorAdd?";
        if (gatewayId !== undefined && gatewayId !== null)
            url_ += "GatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        if (address !== undefined && address !== null)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySensorAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySensorAdd(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySensorAdd(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class DeviceAppPodVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 新建设备后，调用接口绑定最新版本
     * @param input (optional) 
     * @return Success
     */
    setDefaultAppPod(input: SetDefaultAppPodVersionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAppPodVersion/SetDefaultAppPod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultAppPod(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultAppPod(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultAppPod(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备下的appPod版本信息
     * @param deviceId (optional) 
     * @param osType (optional) 
     * @return Success
     */
    getDeviceAppPodVersion(deviceId: number | null | undefined, osType: OsType2 | null | undefined): Observable<DeviceAppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAppPodVersion/GetDeviceAppPodVersion?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (osType !== undefined && osType !== null)
            url_ += "OsType=" + encodeURIComponent("" + osType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceAppPodVersion(response: HttpResponseBase): Observable<DeviceAppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceAppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAppPodVersionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeDeviceApppodVersion(input: ChangeDeviceAppPodVersionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAppPodVersion/ChangeDeviceApppodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDeviceApppodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDeviceApppodVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeDeviceApppodVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getDeviceScreenshot(deviceId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DeviceAppPodVersion/GetDeviceScreenshot?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceScreenshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceScreenshot(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceScreenshot(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 上传传感器协议文件
     * @param id (optional) 
     * @param name (optional) 
     * @param description (optional) 
     * @param datas (optional) 
     * @param postFile (optional) 
     * @return Success
     */
    postDllFile(id: number | null | undefined, name: string | null | undefined, description: string | null | undefined, datas: string[] | null | undefined, postFile: FileParameter | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/PostDllFile?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (datas !== undefined && datas !== null)
            datas && datas.forEach(item => { url_ += "Datas=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (postFile !== null && postFile !== undefined)
            content_.append("PostFile", postFile.data, postFile.fileName ? postFile.fileName : "PostFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostDllFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostDllFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostDllFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAgreementById(id: number | null | undefined): Observable<GetAgreementFileDto> {
        let url_ = this.baseUrl + "/api/File/GetAgreementById?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreementById(<any>response_);
                } catch (e) {
                    return <Observable<GetAgreementFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgreementFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreementById(response: HttpResponseBase): Observable<GetAgreementFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgreementFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgreementFileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAgreements(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetAgreementsDto> {
        let url_ = this.baseUrl + "/api/File/GetAgreements?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreements(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAgreementsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAgreementsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreements(response: HttpResponseBase): Observable<PagedResultDtoOfGetAgreementsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAgreementsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAgreementsDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAgreementList(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDeviceAgreement> {
        let url_ = this.baseUrl + "/api/File/GetAgreementList?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreementList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceAgreement>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceAgreement>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreementList(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceAgreement> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfDeviceAgreement.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceAgreement>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteAgreementByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DeleteAgreementByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAgreementByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAgreementByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAgreementByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GroupAnalysisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 创建计数器分组
     * @param input (optional) 
     * @return Success
     */
    createCounterGroup(input: CreateCounterGroupInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupAnalysis/CreateCounterGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCounterGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询计数器分组
     * @param storeId (optional) 
     * @param creationStart (optional) 
     * @param creationEnd (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCounterGroup(storeId: number | null | undefined, creationStart: moment.Moment | null | undefined, creationEnd: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetCounterGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/GroupAnalysis/GetCounterGroup?";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (creationStart !== undefined && creationStart !== null)
            url_ += "CreationStart=" + encodeURIComponent(creationStart ? "" + creationStart.toJSON() : "") + "&";
        if (creationEnd !== undefined && creationEnd !== null)
            url_ += "CreationEnd=" + encodeURIComponent(creationEnd ? "" + creationEnd.toJSON() : "") + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<GetCounterGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCounterGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounterGroup(response: HttpResponseBase): Observable<GetCounterGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCounterGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCounterGroupDto[]>(<any>null);
    }

    /**
     * 删除计数器分组
     * @param id (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    deleteCounterGroup(id: number | null | undefined, storeId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupAnalysis/DeleteCounterGroup?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (storeId !== undefined && storeId !== null)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCounterGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ImportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param deviceId (optional) 
     * @param inputFile (optional) 
     * @return Success
     */
    postImportFile(deviceId: number | null | undefined, inputFile: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Import/PostImportFile?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputFile !== null && inputFile !== undefined)
            content_.append("InputFile", inputFile.data, inputFile.fileName ? inputFile.fileName : "InputFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostImportFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPostImportFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class IndustryReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getCurentDataReport(subkey: string | null | undefined): Observable<IndustryCurentDataReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IndustryReport/GetCurentDataReport?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurentDataReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurentDataReport(<any>response_);
                } catch (e) {
                    return <Observable<IndustryCurentDataReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustryCurentDataReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurentDataReport(response: HttpResponseBase): Observable<IndustryCurentDataReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndustryCurentDataReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustryCurentDataReportDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param counterId (optional) 
     * @return Success
     */
    getHistoryDataReport(subkey: string | null | undefined, counterId: number | null | undefined): Observable<GetCountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IndustryReport/GetHistoryDataReport?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        if (counterId !== undefined && counterId !== null)
            url_ += "counterId=" + encodeURIComponent("" + counterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryDataReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryDataReport(<any>response_);
                } catch (e) {
                    return <Observable<GetCountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistoryDataReport(response: HttpResponseBase): Observable<GetCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountDto[]>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getSwitchStatus(subkey: string | null | undefined): Observable<GetSwitchStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/IndustryReport/GetSwitchStatus?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSwitchStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSwitchStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetSwitchStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSwitchStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSwitchStatus(response: HttpResponseBase): Observable<GetSwitchStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSwitchStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSwitchStatusDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getWarnningRecords(subkey: string | null | undefined): Observable<GetWarnningRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/IndustryReport/GetWarnningRecords?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarnningRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarnningRecords(<any>response_);
                } catch (e) {
                    return <Observable<GetWarnningRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarnningRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarnningRecords(response: HttpResponseBase): Observable<GetWarnningRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWarnningRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarnningRecordDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getDataRecord(subkey: string | null | undefined): Observable<GetDatasDto> {
        let url_ = this.baseUrl + "/api/services/app/IndustryReport/GetDataRecord?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataRecord(<any>response_);
                } catch (e) {
                    return <Observable<GetDatasDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDatasDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataRecord(response: HttpResponseBase): Observable<GetDatasDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDatasDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDatasDto>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateReportTemplate(input: AddOrUpdateReportTemplateInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/AddOrUpdateReportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateReportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateReportTemplate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateReportTemplate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getReportTemplates(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetReportTemplateDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReportTemplates?";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplates(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetReportTemplateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetReportTemplateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplates(response: HttpResponseBase): Observable<PagedResultDtoOfGetReportTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetReportTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetReportTemplateDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteReportTemplateByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/DeleteReportTemplateByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReportTemplateByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportTemplateByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReportTemplateByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateReport(input: AddOrUpdateReportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/AddOrUpdateReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param reportTemplateId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getReports(tenantId: number | null | undefined, reportTemplateId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetReportDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReports?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (reportTemplateId !== undefined && reportTemplateId !== null)
            url_ += "ReportTemplateId=" + encodeURIComponent("" + reportTemplateId) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReports(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetReportDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetReportDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReports(response: HttpResponseBase): Observable<PagedResultDtoOfGetReportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetReportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetReportDto>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteReportByIds(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Report/DeleteReportByIds?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReportByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReportByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getReportDetailById(id: number | null | undefined): Observable<GetReportDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReportDetailById?";
        if (id !== undefined && id !== null)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportDetailById(<any>response_);
                } catch (e) {
                    return <Observable<GetReportDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportDetailById(response: HttpResponseBase): Observable<GetReportDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportDetailDto>(<any>null);
    }

    /**
     * @param deviceIds (optional) 
     * @return Success
     */
    getCounterTagsByDeviceIds(deviceIds: number[] | null | undefined): Observable<Tag[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCounterTagsByDeviceIds?";
        if (deviceIds !== undefined && deviceIds !== null)
            deviceIds && deviceIds.forEach(item => { url_ += "DeviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterTagsByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterTagsByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<Tag[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tag[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounterTagsByDeviceIds(response: HttpResponseBase): Observable<Tag[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Tag.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tag[]>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 
     * @return Success
     */
    getReport(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, reportId: number | null | undefined): Observable<GetCountDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReport?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId !== undefined && reportId !== null)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReport(<any>response_);
                } catch (e) {
                    return <Observable<GetCountDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCountDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReport(response: HttpResponseBase): Observable<GetCountDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetCountDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCountDto[]>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 
     * @return Success
     */
    getReportToExcel(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, reportId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetReportToExcel?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId !== undefined && reportId !== null)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 
     * @return Success
     */
    getGuestCount(startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined, reportId: number | null | undefined): Observable<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetGuestCount?";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId !== undefined && reportId !== null)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuestCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuestCount(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: number; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: number; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetGuestCount(response: HttpResponseBase): Observable<{ [key: string]: number; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: number; }>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 根据subkey获取所有货道
     * @param isEnabled (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoRoads(subkey: string, isEnabled: boolean | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCargoRoadDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoRoads?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (isEnabled !== undefined && isEnabled !== null)
            url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoads(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCargoRoadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCargoRoadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoads(response: HttpResponseBase): Observable<PagedResultDtoOfCargoRoadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCargoRoadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCargoRoadDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @return Success
     */
    getCargoRoadsAwards(subkey: string | null | undefined): Observable<IdOuterIdValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoRoadsAwards?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadsAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadsAwards(<any>response_);
                } catch (e) {
                    return <Observable<IdOuterIdValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdOuterIdValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadsAwards(response: HttpResponseBase): Observable<IdOuterIdValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdOuterIdValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdOuterIdValueDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param type (optional) 
     * @return Success
     */
    getGuestChart(tenantId: number | null | undefined, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, type: string | null | undefined): Observable<GetGuestChartDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetGuestChart?";
        if (tenantId !== undefined && tenantId !== null)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type !== undefined && type !== null)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuestChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuestChart(<any>response_);
                } catch (e) {
                    return <Observable<GetGuestChartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGuestChartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGuestChart(response: HttpResponseBase): Observable<GetGuestChartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGuestChartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGuestChartDto>(<any>null);
    }

    /**
     * 根据subkey获取所有货道历史纪录
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoHisotory(subkey: string, startTime: moment.Moment | null | undefined, endTime: moment.Moment | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfCargoHistoryDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoHisotory?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (startTime !== undefined && startTime !== null)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoHisotory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoHisotory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCargoHistoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCargoHistoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoHisotory(response: HttpResponseBase): Observable<PagedResultDtoOfCargoHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCargoHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCargoHistoryDto>(<any>null);
    }

    /**
     * 删除一个库存
     * @param input (optional) 
     * @return Success
     */
    dropCargo(input: DropCargoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DropCargo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCargo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCargo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 补货
     * @param input (optional) 
     * @return Success
     */
    updateCargoStock(input: UpdateCargoStockInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UpdateCargoStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除多个库存
     * @param input (optional) 
     * @return Success
     */
    dropCargos(input: MutipleDropCargoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DropCargos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCargos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCargos(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCargos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 线下升级完成后，需要更新当前机器版本信息
     * @param input (optional) 
     * @return Success
     */
    changeDeviceApppodVersion(input: ChangeDeviceAppPodCurrentVersionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/ChangeDeviceApppodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDeviceApppodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDeviceApppodVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeDeviceApppodVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备下的appPod版本信息
     * @param subkey (optional) 
     * @return Success
     */
    getDeviceAppPodVersion(subkey: string | null | undefined): Observable<DeviceAppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDeviceAppPodVersion?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceAppPodVersion(response: HttpResponseBase): Observable<DeviceAppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceAppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAppPodVersionDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    uploadScreenShot(subKey: string, input: AppPodScreenInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UploadScreenShot?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadScreenShot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadScreenShot(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadScreenShot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建计数器
     * @param deviceInfo (optional) 
     * @return Success
     */
    createChildDeviceAndCountersByDevice(deviceInfo: CreateChildDeviceAndCountersDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/CreateChildDeviceAndCountersByDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChildDeviceAndCountersByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChildDeviceAndCountersByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateChildDeviceAndCountersByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param input (optional) 
     * @return Success
     */
    controlGateway(subkey: string | null | undefined, input: ControlGatewayInput | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/ControlGateway?";
        if (subkey !== undefined && subkey !== null)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processControlGateway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processControlGateway(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processControlGateway(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 写入计数流水
     * @param input (optional) 
     * @return Success
     */
    postCounterRecordsByDevice(input: DeviceCounterRecords | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostCounterRecordsByDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostCounterRecordsByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCounterRecordsByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostCounterRecordsByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    keepIISAlive(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/KeepIISAlive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processKeepIISAlive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processKeepIISAlive(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processKeepIISAlive(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getShelfProducts(subKey: string | null | undefined): Observable<SimpleProductDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetShelfProducts?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShelfProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShelfProducts(<any>response_);
                } catch (e) {
                    return <Observable<SimpleProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShelfProducts(response: HttpResponseBase): Observable<SimpleProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleProductDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleProductDto[]>(<any>null);
    }

    /**
     * @param deviceIds (optional) 
     * @return Success
     */
    getRepertoryByDeviceIds(deviceIds: number[] | null | undefined): Observable<DeviceCargoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetRepertoryByDeviceIds?";
        if (deviceIds !== undefined && deviceIds !== null)
            deviceIds && deviceIds.forEach(item => { url_ += "deviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRepertoryByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRepertoryByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<DeviceCargoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceCargoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRepertoryByDeviceIds(response: HttpResponseBase): Observable<DeviceCargoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceCargoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceCargoDto[]>(<any>null);
    }
}

@Injectable()
export class SensingShelfAppSerivceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * 线下获取智能云货架信息API
    若Subkey为智能云货架设备，返回仅有该智能货架的集合;若Subkey为其他设备类型，返回所有智能货架集合
     * @param subKey (optional) 设备唯一标识Key
     * @return Success
     */
    getShelfBySubKey(subKey: string | null | undefined): Observable<ShelfDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingShelfAppSerivce/GetShelfBySubKey?";
        if (subKey !== undefined && subKey !== null)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShelfBySubKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShelfBySubKey(<any>response_);
                } catch (e) {
                    return <Observable<ShelfDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShelfDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShelfBySubKey(response: HttpResponseBase): Observable<ShelfDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShelfDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShelfDto[]>(<any>null);
    }
}

@Injectable()
export class ShelfServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_CARGO_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateShelfInfo(input: AddOrUpdateShelfInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shelf/AddOrUpdateShelfInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateShelfInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateShelfInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateShelfInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @param toDeviceIds (optional) 
     * @return Success
     */
    getSingleShelf(deviceId: number | null | undefined, toDeviceIds: number[] | null | undefined): Observable<ShelfDto> {
        let url_ = this.baseUrl + "/api/services/app/Shelf/GetSingleShelf?";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (toDeviceIds !== undefined && toDeviceIds !== null)
            toDeviceIds && toDeviceIds.forEach(item => { url_ += "ToDeviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleShelf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleShelf(<any>response_);
                } catch (e) {
                    return <Observable<ShelfDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShelfDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleShelf(response: HttpResponseBase): Observable<ShelfDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelfDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShelfDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addOrDeleteCargoRoadByLayerId(input: AddOrUpdateCargoRoadByLayerIdInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shelf/AddOrDeleteCargoRoadByLayerId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrDeleteCargoRoadByLayerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrDeleteCargoRoadByLayerId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrDeleteCargoRoadByLayerId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    exchangeCargoRoadSku(input: ExchangeCargoRoadSkuInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shelf/ExchangeCargoRoadSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeCargoRoadSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeCargoRoadSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExchangeCargoRoadSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deviceMirrorPublish(input: GetSingleShelfInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Shelf/DeviceMirrorPublish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeviceMirrorPublish(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeviceMirrorPublish(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeviceMirrorPublish(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export class PagedResultDtoOfAppPodDto implements IPagedResultDtoOfAppPodDto {
    totalCount!: number | undefined;
    items!: AppPodDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAppPodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppPodDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppPodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAppPodDto {
    totalCount: number | undefined;
    items: AppPodDto[] | undefined;
}

export class AppPodDto implements IAppPodDto {
    id!: number | undefined;
    name!: string | undefined;
    icon!: string | undefined;
    os!: string | undefined;
    isDefault!: boolean | undefined;
    latestVersion!: string | undefined;
    downloadUrl!: string | undefined;
    /** 最新版本 最后更新时间 */
    latestDatetime!: moment.Moment | undefined;

    constructor(data?: IAppPodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.os = _data["os"];
            this.isDefault = _data["isDefault"];
            this.latestVersion = _data["latestVersion"];
            this.downloadUrl = _data["downloadUrl"];
            this.latestDatetime = _data["latestDatetime"] ? moment(_data["latestDatetime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppPodDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["os"] = this.os;
        data["isDefault"] = this.isDefault;
        data["latestVersion"] = this.latestVersion;
        data["downloadUrl"] = this.downloadUrl;
        data["latestDatetime"] = this.latestDatetime ? this.latestDatetime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAppPodDto {
    id: number | undefined;
    name: string | undefined;
    icon: string | undefined;
    os: string | undefined;
    isDefault: boolean | undefined;
    latestVersion: string | undefined;
    downloadUrl: string | undefined;
    /** 最新版本 最后更新时间 */
    latestDatetime: moment.Moment | undefined;
}

export class PagedResultDtoOfAppPodVersionDto implements IPagedResultDtoOfAppPodVersionDto {
    totalCount!: number | undefined;
    items!: AppPodVersionDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAppPodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPodVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppPodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppPodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAppPodVersionDto {
    totalCount: number | undefined;
    items: AppPodVersionDto[] | undefined;
}

export class AppPodVersionDto implements IAppPodVersionDto {
    version!: string | undefined;
    downloadUrl!: string | undefined;
    appSetting!: string | undefined;
    description!: string | undefined;
    appPodName!: string | undefined;
    os!: string | undefined;
    md5!: string | undefined;
    isNeedRestart!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAppPodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.description = _data["description"];
            this.appPodName = _data["appPodName"];
            this.os = _data["os"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppPodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["description"] = this.description;
        data["appPodName"] = this.appPodName;
        data["os"] = this.os;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAppPodVersionDto {
    version: string | undefined;
    downloadUrl: string | undefined;
    appSetting: string | undefined;
    description: string | undefined;
    appPodName: string | undefined;
    os: string | undefined;
    md5: string | undefined;
    isNeedRestart: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateAppPodVersionInput implements ICreateAppPodVersionInput {
    appPodId!: number | undefined;
    version!: string;
    description!: string | undefined;
    downloadUrl!: string;
    appSetting!: string | undefined;
    md5!: string | undefined;
    isNeedRestart!: boolean | undefined;

    constructor(data?: ICreateAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appPodId = _data["appPodId"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): CreateAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appPodId"] = this.appPodId;
        data["version"] = this.version;
        data["description"] = this.description;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

export interface ICreateAppPodVersionInput {
    appPodId: number | undefined;
    version: string;
    description: string | undefined;
    downloadUrl: string;
    appSetting: string | undefined;
    md5: string | undefined;
    isNeedRestart: boolean | undefined;
}

export class AppPodVersion implements IAppPodVersion {
    version!: string | undefined;
    downloadUrl!: string | undefined;
    appSetting!: string | undefined;
    description!: string | undefined;
    apppodId!: number | undefined;
    apppod!: Apppod | undefined;
    owner!: string | undefined;
    md5!: string | undefined;
    isNeedRestart!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAppPodVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.description = _data["description"];
            this.apppodId = _data["apppodId"];
            this.apppod = _data["apppod"] ? Apppod.fromJS(_data["apppod"]) : <any>undefined;
            this.owner = _data["owner"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppPodVersion {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["description"] = this.description;
        data["apppodId"] = this.apppodId;
        data["apppod"] = this.apppod ? this.apppod.toJSON() : <any>undefined;
        data["owner"] = this.owner;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAppPodVersion {
    version: string | undefined;
    downloadUrl: string | undefined;
    appSetting: string | undefined;
    description: string | undefined;
    apppodId: number | undefined;
    apppod: Apppod | undefined;
    owner: string | undefined;
    md5: string | undefined;
    isNeedRestart: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Apppod implements IApppod {
    name!: string | undefined;
    icon!: string | undefined;
    os!: string | undefined;
    isDefault!: boolean | undefined;
    owner!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApppod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.os = _data["os"];
            this.isDefault = _data["isDefault"];
            this.owner = _data["owner"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Apppod {
        data = typeof data === 'object' ? data : {};
        let result = new Apppod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["os"] = this.os;
        data["isDefault"] = this.isDefault;
        data["owner"] = this.owner;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApppod {
    name: string | undefined;
    icon: string | undefined;
    os: string | undefined;
    isDefault: boolean | undefined;
    owner: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UpdateAppPodVersionInput implements IUpdateAppPodVersionInput {
    id!: number | undefined;
    appPodId!: number | undefined;
    version!: string;
    description!: string | undefined;
    downloadUrl!: string;
    appSetting!: string | undefined;
    md5!: string | undefined;
    isNeedRestart!: boolean | undefined;

    constructor(data?: IUpdateAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appPodId = _data["appPodId"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): UpdateAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appPodId"] = this.appPodId;
        data["version"] = this.version;
        data["description"] = this.description;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

export interface IUpdateAppPodVersionInput {
    id: number | undefined;
    appPodId: number | undefined;
    version: string;
    description: string | undefined;
    downloadUrl: string;
    appSetting: string | undefined;
    md5: string | undefined;
    isNeedRestart: boolean | undefined;
}

export class PagedResultDtoOfCargoRoadDto implements IPagedResultDtoOfCargoRoadDto {
    totalCount!: number | undefined;
    items!: CargoRoadDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCargoRoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CargoRoadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCargoRoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCargoRoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCargoRoadDto {
    totalCount: number | undefined;
    items: CargoRoadDto[] | undefined;
}

export class CargoRoadDto implements ICargoRoadDto {
    deviceId!: number | undefined;
    tenantId!: number | undefined;
    /** 货道名称 */
    name!: string | undefined;
    /** 货道编号. */
    outerId!: string | undefined;
    isEnabled!: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity!: number | undefined;
    description!: string | undefined;
    cargoType!: CargoRoadDtoCargoType | undefined;
    extensionData!: string | undefined;
    spanRows!: number | undefined;
    spanColumns!: number | undefined;
    cargoThings!: CargoThingDto[] | undefined;
    layerId!: number | undefined;
    resolution_Length!: number | undefined;
    startPoint_X!: number | undefined;
    resolution_Height!: number | undefined;
    startPoint_Z!: number | undefined;
    grossWeight!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICargoRoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.cargoType = _data["cargoType"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CargoThingDto.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CargoRoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoRoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["cargoType"] = this.cargoType;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICargoRoadDto {
    deviceId: number | undefined;
    tenantId: number | undefined;
    /** 货道名称 */
    name: string | undefined;
    /** 货道编号. */
    outerId: string | undefined;
    isEnabled: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity: number | undefined;
    description: string | undefined;
    cargoType: CargoRoadDtoCargoType | undefined;
    extensionData: string | undefined;
    spanRows: number | undefined;
    spanColumns: number | undefined;
    cargoThings: CargoThingDto[] | undefined;
    layerId: number | undefined;
    resolution_Length: number | undefined;
    startPoint_X: number | undefined;
    resolution_Height: number | undefined;
    startPoint_Z: number | undefined;
    grossWeight: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CargoThingDto implements ICargoThingDto {
    id!: number | undefined;
    cargoThingId!: number | undefined;
    cargoRoadId!: number | undefined;
    thingId!: number | undefined;
    type!: CargoThingDtoType | undefined;
    thingName!: string | undefined;
    stock!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    /** 货道Icon. */
    iconUrl!: string | undefined;
    orderNumber!: number | undefined;
    thingOuterId!: string | undefined;

    constructor(data?: ICargoThingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cargoThingId = _data["cargoThingId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.thingName = _data["thingName"];
            this.stock = _data["stock"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.iconUrl = _data["iconUrl"];
            this.orderNumber = _data["orderNumber"];
            this.thingOuterId = _data["thingOuterId"];
        }
    }

    static fromJS(data: any): CargoThingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoThingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cargoThingId"] = this.cargoThingId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["thingName"] = this.thingName;
        data["stock"] = this.stock;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["iconUrl"] = this.iconUrl;
        data["orderNumber"] = this.orderNumber;
        data["thingOuterId"] = this.thingOuterId;
        return data; 
    }
}

export interface ICargoThingDto {
    id: number | undefined;
    cargoThingId: number | undefined;
    cargoRoadId: number | undefined;
    thingId: number | undefined;
    type: CargoThingDtoType | undefined;
    thingName: string | undefined;
    stock: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    /** 货道Icon. */
    iconUrl: string | undefined;
    orderNumber: number | undefined;
    thingOuterId: string | undefined;
}

export class CreateCargoRoadsInput implements ICreateCargoRoadsInput {
    deviceId!: number | undefined;
    /** 货道名称 */
    name!: string;
    /** 货道编号. */
    outerId!: string | undefined;
    isEnabled!: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    spanRows!: number | undefined;
    spanColumns!: number | undefined;
    cargoType!: CreateCargoRoadsInputCargoType | undefined;
    cargoThings!: CreateCargoThingInput[] | undefined;
    layerId!: number | undefined;
    resolution_Length!: number | undefined;
    startPoint_X!: number | undefined;
    resolution_Height!: number | undefined;
    startPoint_Z!: number | undefined;
    grossWeight!: number | undefined;

    constructor(data?: ICreateCargoRoadsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            this.cargoType = _data["cargoType"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CreateCargoThingInput.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): CreateCargoRoadsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCargoRoadsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        data["cargoType"] = this.cargoType;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

export interface ICreateCargoRoadsInput {
    deviceId: number | undefined;
    /** 货道名称 */
    name: string;
    /** 货道编号. */
    outerId: string | undefined;
    isEnabled: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    spanRows: number | undefined;
    spanColumns: number | undefined;
    cargoType: CreateCargoRoadsInputCargoType | undefined;
    cargoThings: CreateCargoThingInput[] | undefined;
    layerId: number | undefined;
    resolution_Length: number | undefined;
    startPoint_X: number | undefined;
    resolution_Height: number | undefined;
    startPoint_Z: number | undefined;
    grossWeight: number | undefined;
}

export class CreateCargoThingInput implements ICreateCargoThingInput {
    thingId!: number | undefined;
    type!: CreateCargoThingInputType | undefined;
    thingName!: string | undefined;
    stock!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    orderNumber!: number | undefined;
    /** 货道Icon. */
    iconUrl!: string | undefined;
    thingOuterId!: string | undefined;

    constructor(data?: ICreateCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.thingName = _data["thingName"];
            this.stock = _data["stock"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.orderNumber = _data["orderNumber"];
            this.iconUrl = _data["iconUrl"];
            this.thingOuterId = _data["thingOuterId"];
        }
    }

    static fromJS(data: any): CreateCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["thingName"] = this.thingName;
        data["stock"] = this.stock;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["orderNumber"] = this.orderNumber;
        data["iconUrl"] = this.iconUrl;
        data["thingOuterId"] = this.thingOuterId;
        return data; 
    }
}

export interface ICreateCargoThingInput {
    thingId: number | undefined;
    type: CreateCargoThingInputType | undefined;
    thingName: string | undefined;
    stock: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    orderNumber: number | undefined;
    /** 货道Icon. */
    iconUrl: string | undefined;
    thingOuterId: string | undefined;
}

export class UpdateCargoStatusInput implements IUpdateCargoStatusInput {
    cargoStatus!: CargoStatus[] | undefined;

    constructor(data?: IUpdateCargoStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cargoStatus"])) {
                this.cargoStatus = [] as any;
                for (let item of _data["cargoStatus"])
                    this.cargoStatus!.push(CargoStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCargoStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cargoStatus)) {
            data["cargoStatus"] = [];
            for (let item of this.cargoStatus)
                data["cargoStatus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateCargoStatusInput {
    cargoStatus: CargoStatus[] | undefined;
}

export class CargoStatus implements ICargoStatus {
    id!: number | undefined;
    isEnable!: boolean | undefined;

    constructor(data?: ICargoStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isEnable = _data["isEnable"];
        }
    }

    static fromJS(data: any): CargoStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEnable"] = this.isEnable;
        return data; 
    }
}

export interface ICargoStatus {
    id: number | undefined;
    isEnable: boolean | undefined;
}

export class AddOrUpdateCargoRoadInput implements IAddOrUpdateCargoRoadInput {
    deviceCode!: string;
    code!: string;
    name!: string;
    stockCapacity!: number | undefined;
    type!: number | undefined;
    description!: string | undefined;
    things!: CargoThingInput[] | undefined;

    constructor(data?: IAddOrUpdateCargoRoadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceCode = _data["deviceCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.stockCapacity = _data["stockCapacity"];
            this.type = _data["type"];
            this.description = _data["description"];
            if (Array.isArray(_data["things"])) {
                this.things = [] as any;
                for (let item of _data["things"])
                    this.things!.push(CargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateCargoRoadInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateCargoRoadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceCode"] = this.deviceCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["stockCapacity"] = this.stockCapacity;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.things)) {
            data["things"] = [];
            for (let item of this.things)
                data["things"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateCargoRoadInput {
    deviceCode: string;
    code: string;
    name: string;
    stockCapacity: number | undefined;
    type: number | undefined;
    description: string | undefined;
    things: CargoThingInput[] | undefined;
}

export class CargoThingInput implements ICargoThingInput {
    type!: number | undefined;
    thingOuterId!: string;
    stock!: number | undefined;
    iconUrl!: string | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;
    layerId!: number | undefined;
    resolution_Length!: number | undefined;
    startPoint_X!: number | undefined;
    resolution_Height!: number | undefined;
    startPoint_Z!: number | undefined;
    grossWeight!: number | undefined;

    constructor(data?: ICargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.thingOuterId = _data["thingOuterId"];
            this.stock = _data["stock"];
            this.iconUrl = _data["iconUrl"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): CargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["thingOuterId"] = this.thingOuterId;
        data["stock"] = this.stock;
        data["iconUrl"] = this.iconUrl;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

export interface ICargoThingInput {
    type: number | undefined;
    thingOuterId: string;
    stock: number | undefined;
    iconUrl: string | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
    layerId: number | undefined;
    resolution_Length: number | undefined;
    startPoint_X: number | undefined;
    resolution_Height: number | undefined;
    startPoint_Z: number | undefined;
    grossWeight: number | undefined;
}

export class UpdateCargoRoadsInput implements IUpdateCargoRoadsInput {
    id!: number | undefined;
    deviceId!: number | undefined;
    /** 货道名称 */
    name!: string;
    /** 货道编号. */
    outerId!: string | undefined;
    isEnabled!: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity!: number | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    spanRows!: number | undefined;
    spanColumns!: number | undefined;
    cargoType!: UpdateCargoRoadsInputCargoType | undefined;
    cargoThings!: CreateCargoThingInput[] | undefined;
    layerId!: number | undefined;
    resolution_Length!: number | undefined;
    startPoint_X!: number | undefined;
    resolution_Height!: number | undefined;
    startPoint_Z!: number | undefined;
    grossWeight!: number | undefined;

    constructor(data?: IUpdateCargoRoadsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            this.cargoType = _data["cargoType"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CreateCargoThingInput.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): UpdateCargoRoadsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoRoadsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        data["cargoType"] = this.cargoType;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

export interface IUpdateCargoRoadsInput {
    id: number | undefined;
    deviceId: number | undefined;
    /** 货道名称 */
    name: string;
    /** 货道编号. */
    outerId: string | undefined;
    isEnabled: boolean | undefined;
    /** Cargo Road max Capacity. */
    stockCapacity: number | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    spanRows: number | undefined;
    spanColumns: number | undefined;
    cargoType: UpdateCargoRoadsInputCargoType | undefined;
    cargoThings: CreateCargoThingInput[] | undefined;
    layerId: number | undefined;
    resolution_Length: number | undefined;
    startPoint_X: number | undefined;
    resolution_Height: number | undefined;
    startPoint_Z: number | undefined;
    grossWeight: number | undefined;
}

export class PagedResultDtoOfCargoHistoryDto implements IPagedResultDtoOfCargoHistoryDto {
    totalCount!: number | undefined;
    items!: CargoHistoryDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCargoHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CargoHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCargoHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCargoHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCargoHistoryDto {
    totalCount: number | undefined;
    items: CargoHistoryDto[] | undefined;
}

export class CargoHistoryDto implements ICargoHistoryDto {
    /** 货道Icon. */
    iconUrl!: string | undefined;
    /** 货道名称 */
    name!: string | undefined;
    cargoRoadId!: number | undefined;
    cargoThingId!: number | undefined;
    thingName!: string | undefined;
    quantity!: number | undefined;
    cargoAction!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICargoHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconUrl = _data["iconUrl"];
            this.name = _data["name"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.thingName = _data["thingName"];
            this.quantity = _data["quantity"];
            this.cargoAction = _data["cargoAction"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CargoHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconUrl"] = this.iconUrl;
        data["name"] = this.name;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["thingName"] = this.thingName;
        data["quantity"] = this.quantity;
        data["cargoAction"] = this.cargoAction;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICargoHistoryDto {
    /** 货道Icon. */
    iconUrl: string | undefined;
    /** 货道名称 */
    name: string | undefined;
    cargoRoadId: number | undefined;
    cargoThingId: number | undefined;
    thingName: string | undefined;
    quantity: number | undefined;
    cargoAction: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class BindDevicesToGatewayInput implements IBindDevicesToGatewayInput {
    gatewayId!: number | undefined;
    deviceIds!: number[] | undefined;
    type!: string | undefined;
    thingId!: string | undefined;
    orderNumber!: number | undefined;

    constructor(data?: IBindDevicesToGatewayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.type = _data["type"];
            this.thingId = _data["thingId"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): BindDevicesToGatewayInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindDevicesToGatewayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["type"] = this.type;
        data["thingId"] = this.thingId;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IBindDevicesToGatewayInput {
    gatewayId: number | undefined;
    deviceIds: number[] | undefined;
    type: string | undefined;
    thingId: string | undefined;
    orderNumber: number | undefined;
}

export class GetGatewayInfoDto implements IGetGatewayInfoDto {
    gatewayId!: number | undefined;
    gatewayName!: string | undefined;
    type!: string | undefined;
    thingId!: string | undefined;
    orderNumber!: number | undefined;

    constructor(data?: IGetGatewayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.gatewayName = _data["gatewayName"];
            this.type = _data["type"];
            this.thingId = _data["thingId"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): GetGatewayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGatewayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["gatewayName"] = this.gatewayName;
        data["type"] = this.type;
        data["thingId"] = this.thingId;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IGetGatewayInfoDto {
    gatewayId: number | undefined;
    gatewayName: string | undefined;
    type: string | undefined;
    thingId: string | undefined;
    orderNumber: number | undefined;
}

export class PagedResultDtoOfGatewayBindDeviceDto implements IPagedResultDtoOfGatewayBindDeviceDto {
    totalCount!: number | undefined;
    items!: GatewayBindDeviceDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGatewayBindDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GatewayBindDeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGatewayBindDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGatewayBindDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGatewayBindDeviceDto {
    totalCount: number | undefined;
    items: GatewayBindDeviceDto[] | undefined;
}

export class GatewayBindDeviceDto implements IGatewayBindDeviceDto {
    id!: number | undefined;
    name!: string | undefined;
    mac!: string | undefined;
    /** 设备审核的状态. */
    deviceTypeId!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    hardwareCode!: string | undefined;
    /** Customize image to understand well. e.g Snapshot for Image. */
    outerId!: string | undefined;

    constructor(data?: IGatewayBindDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.hardwareCode = _data["hardwareCode"];
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): GatewayBindDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GatewayBindDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["deviceTypeId"] = this.deviceTypeId;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["hardwareCode"] = this.hardwareCode;
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface IGatewayBindDeviceDto {
    id: number | undefined;
    name: string | undefined;
    mac: string | undefined;
    /** 设备审核的状态. */
    deviceTypeId: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    hardwareCode: string | undefined;
    /** Customize image to understand well. e.g Snapshot for Image. */
    outerId: string | undefined;
}

export class CreateCounterInput implements ICreateCounterInput {
    deviceId!: number | undefined;
    deleteOtherCounters!: boolean | undefined;
    counterInfos!: CounterInfo[] | undefined;

    constructor(data?: ICreateCounterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deleteOtherCounters = _data["deleteOtherCounters"];
            if (Array.isArray(_data["counterInfos"])) {
                this.counterInfos = [] as any;
                for (let item of _data["counterInfos"])
                    this.counterInfos!.push(CounterInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCounterInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deleteOtherCounters"] = this.deleteOtherCounters;
        if (Array.isArray(this.counterInfos)) {
            data["counterInfos"] = [];
            for (let item of this.counterInfos)
                data["counterInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateCounterInput {
    deviceId: number | undefined;
    deleteOtherCounters: boolean | undefined;
    counterInfos: CounterInfo[] | undefined;
}

export class CounterInfo implements ICounterInfo {
    id!: number | undefined;
    counterName!: string | undefined;
    displayName!: string | undefined;
    describution!: string | undefined;
    totalCount!: number | undefined;
    tagId!: number[] | undefined;

    constructor(data?: ICounterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterName = _data["counterName"];
            this.displayName = _data["displayName"];
            this.describution = _data["describution"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["tagId"])) {
                this.tagId = [] as any;
                for (let item of _data["tagId"])
                    this.tagId!.push(item);
            }
        }
    }

    static fromJS(data: any): CounterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CounterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterName"] = this.counterName;
        data["displayName"] = this.displayName;
        data["describution"] = this.describution;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.tagId)) {
            data["tagId"] = [];
            for (let item of this.tagId)
                data["tagId"].push(item);
        }
        return data; 
    }
}

export interface ICounterInfo {
    id: number | undefined;
    counterName: string | undefined;
    displayName: string | undefined;
    describution: string | undefined;
    totalCount: number | undefined;
    tagId: number[] | undefined;
}

export class GetCounerInfoDto implements IGetCounerInfoDto {
    childDeviceId!: number | undefined;
    tenantId!: number | undefined;
    counterName!: string | undefined;
    description!: string | undefined;
    totalCount!: number | undefined;
    counterTagInfoDto!: GetCounterTagInfoDto[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IGetCounerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.childDeviceId = _data["childDeviceId"];
            this.tenantId = _data["tenantId"];
            this.counterName = _data["counterName"];
            this.description = _data["description"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["counterTagInfoDto"])) {
                this.counterTagInfoDto = [] as any;
                for (let item of _data["counterTagInfoDto"])
                    this.counterTagInfoDto!.push(GetCounterTagInfoDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetCounerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCounerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childDeviceId"] = this.childDeviceId;
        data["tenantId"] = this.tenantId;
        data["counterName"] = this.counterName;
        data["description"] = this.description;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.counterTagInfoDto)) {
            data["counterTagInfoDto"] = [];
            for (let item of this.counterTagInfoDto)
                data["counterTagInfoDto"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetCounerInfoDto {
    childDeviceId: number | undefined;
    tenantId: number | undefined;
    counterName: string | undefined;
    description: string | undefined;
    totalCount: number | undefined;
    counterTagInfoDto: GetCounterTagInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetCounterTagInfoDto implements IGetCounterTagInfoDto {
    tagId!: number | undefined;
    value!: string | undefined;

    constructor(data?: IGetCounterTagInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetCounterTagInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCounterTagInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["value"] = this.value;
        return data; 
    }
}

export interface IGetCounterTagInfoDto {
    tagId: number | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfGetDeviceCounterDto implements IPagedResultDtoOfGetDeviceCounterDto {
    totalCount!: number | undefined;
    items!: GetDeviceCounterDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDeviceCounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDeviceCounterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDeviceCounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDeviceCounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetDeviceCounterDto {
    totalCount: number | undefined;
    items: GetDeviceCounterDto[] | undefined;
}

export class GetDeviceCounterDto implements IGetDeviceCounterDto {
    id!: number | undefined;
    counterName!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    totalCount!: number | undefined;
    tags!: GetCounterTagInfoDto[] | undefined;

    constructor(data?: IGetDeviceCounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterName = _data["counterName"];
            this.displayName = _data["displayName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(GetCounterTagInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceCounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterName"] = this.counterName;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDeviceCounterDto {
    id: number | undefined;
    counterName: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    totalCount: number | undefined;
    tags: GetCounterTagInfoDto[] | undefined;
}

export class CreateCountRecordInput implements ICreateCountRecordInput {
    deviceId!: number | undefined;
    counterId!: number | undefined;
    increment!: number | undefined;
    collectionTime!: moment.Moment | undefined;
    collectEndTime!: moment.Moment | undefined;

    constructor(data?: ICreateCountRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.counterId = _data["counterId"];
            this.increment = _data["increment"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCountRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["counterId"] = this.counterId;
        data["increment"] = this.increment;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateCountRecordInput {
    deviceId: number | undefined;
    counterId: number | undefined;
    increment: number | undefined;
    collectionTime: moment.Moment | undefined;
    collectEndTime: moment.Moment | undefined;
}

export class GetCountDto implements IGetCountDto {
    title!: string | undefined;
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IGetCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of _data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetCountDto {
    title: string | undefined;
    chartItems: ChartItem[] | undefined;
}

export class ChartItem implements IChartItem {
    date!: string | undefined;
    value!: number | undefined;
    thingId!: number | undefined;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.value = _data["value"];
            this.thingId = _data["thingId"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IChartItem {
    date: string | undefined;
    value: number | undefined;
    thingId: number | undefined;
}

export class CreateCounterTagInput implements ICreateCounterTagInput {
    counterId!: number | undefined;
    tagId!: number[] | undefined;

    constructor(data?: ICreateCounterTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterId = _data["counterId"];
            if (Array.isArray(_data["tagId"])) {
                this.tagId = [] as any;
                for (let item of _data["tagId"])
                    this.tagId!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCounterTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterId"] = this.counterId;
        if (Array.isArray(this.tagId)) {
            data["tagId"] = [];
            for (let item of this.tagId)
                data["tagId"].push(item);
        }
        return data; 
    }
}

export interface ICreateCounterTagInput {
    counterId: number | undefined;
    tagId: number[] | undefined;
}

export class UpdateCounterTagInput implements IUpdateCounterTagInput {
    counterIds!: number[] | undefined;
    tagIds!: number[] | undefined;

    constructor(data?: IUpdateCounterTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["counterIds"])) {
                this.counterIds = [] as any;
                for (let item of _data["counterIds"])
                    this.counterIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateCounterTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCounterTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.counterIds)) {
            data["counterIds"] = [];
            for (let item of this.counterIds)
                data["counterIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

export interface IUpdateCounterTagInput {
    counterIds: number[] | undefined;
    tagIds: number[] | undefined;
}

export class AddOrUpdateGatewayInput implements IAddOrUpdateGatewayInput {
    deviceId!: number | undefined;
    agreementId!: number | undefined;
    gatewayType!: AddOrUpdateGatewayInputGatewayType | undefined;
    pollingTime!: number | undefined;

    constructor(data?: IAddOrUpdateGatewayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.agreementId = _data["agreementId"];
            this.gatewayType = _data["gatewayType"];
            this.pollingTime = _data["pollingTime"];
        }
    }

    static fromJS(data: any): AddOrUpdateGatewayInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateGatewayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["agreementId"] = this.agreementId;
        data["gatewayType"] = this.gatewayType;
        data["pollingTime"] = this.pollingTime;
        return data; 
    }
}

export interface IAddOrUpdateGatewayInput {
    deviceId: number | undefined;
    agreementId: number | undefined;
    gatewayType: AddOrUpdateGatewayInputGatewayType | undefined;
    pollingTime: number | undefined;
}

export class AddOrUpdateSensorInput implements IAddOrUpdateSensorInput {
    gatewayId!: number | undefined;
    deviceId!: number | undefined;
    address!: number | undefined;
    command!: string | undefined;
    agreementId!: number | undefined;

    constructor(data?: IAddOrUpdateSensorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.deviceId = _data["deviceId"];
            this.address = _data["address"];
            this.command = _data["command"];
            this.agreementId = _data["agreementId"];
        }
    }

    static fromJS(data: any): AddOrUpdateSensorInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSensorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["deviceId"] = this.deviceId;
        data["address"] = this.address;
        data["command"] = this.command;
        data["agreementId"] = this.agreementId;
        return data; 
    }
}

export interface IAddOrUpdateSensorInput {
    gatewayId: number | undefined;
    deviceId: number | undefined;
    address: number | undefined;
    command: string | undefined;
    agreementId: number | undefined;
}

export class GetGatewayOrSensorDto implements IGetGatewayOrSensorDto {
    gatewayId!: number | undefined;
    deviceId!: number | undefined;
    address!: number | undefined;
    command!: string | undefined;
    agreementId!: number | undefined;
    deviceType!: GetGatewayOrSensorDtoDeviceType | undefined;
    gatewayType!: GetGatewayOrSensorDtoGatewayType | undefined;
    pollingTime!: number | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IGetGatewayOrSensorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.deviceId = _data["deviceId"];
            this.address = _data["address"];
            this.command = _data["command"];
            this.agreementId = _data["agreementId"];
            this.deviceType = _data["deviceType"];
            this.gatewayType = _data["gatewayType"];
            this.pollingTime = _data["pollingTime"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetGatewayOrSensorDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGatewayOrSensorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["deviceId"] = this.deviceId;
        data["address"] = this.address;
        data["command"] = this.command;
        data["agreementId"] = this.agreementId;
        data["deviceType"] = this.deviceType;
        data["gatewayType"] = this.gatewayType;
        data["pollingTime"] = this.pollingTime;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGetGatewayOrSensorDto {
    gatewayId: number | undefined;
    deviceId: number | undefined;
    address: number | undefined;
    command: string | undefined;
    agreementId: number | undefined;
    deviceType: GetGatewayOrSensorDtoDeviceType | undefined;
    gatewayType: GetGatewayOrSensorDtoGatewayType | undefined;
    pollingTime: number | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetAddressDto implements IGetAddressDto {
    address!: number | undefined;
    gatewayType!: GetAddressDtoGatewayType | undefined;

    constructor(data?: IGetAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.gatewayType = _data["gatewayType"];
        }
    }

    static fromJS(data: any): GetAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["gatewayType"] = this.gatewayType;
        return data; 
    }
}

export interface IGetAddressDto {
    address: number | undefined;
    gatewayType: GetAddressDtoGatewayType | undefined;
}

export class SetDefaultAppPodVersionInput implements ISetDefaultAppPodVersionInput {
    deviceId!: number | undefined;
    osType!: SetDefaultAppPodVersionInputOsType | undefined;

    constructor(data?: ISetDefaultAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.osType = _data["osType"];
        }
    }

    static fromJS(data: any): SetDefaultAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["osType"] = this.osType;
        return data; 
    }
}

export interface ISetDefaultAppPodVersionInput {
    deviceId: number | undefined;
    osType: SetDefaultAppPodVersionInputOsType | undefined;
}

export class DeviceAppPodVersionDto implements IDeviceAppPodVersionDto {
    currentAppPodVersionId!: number | undefined;
    currentVersion!: string | undefined;
    currentDownloadUrl!: string | undefined;
    targetAppPodVersionId!: number | undefined;
    targetVersion!: string | undefined;
    targetDownloadUrl!: string | undefined;
    currentAppPodName!: string | undefined;
    targetAppPodName!: string | undefined;
    os!: string | undefined;
    targetVersionAppSetting!: string | undefined;
    description!: string | undefined;
    isLocked!: boolean | undefined;
    extensionData!: string | undefined;
    md5!: string | undefined;
    isNeedRestart!: boolean | undefined;

    constructor(data?: IDeviceAppPodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentAppPodVersionId = _data["currentAppPodVersionId"];
            this.currentVersion = _data["currentVersion"];
            this.currentDownloadUrl = _data["currentDownloadUrl"];
            this.targetAppPodVersionId = _data["targetAppPodVersionId"];
            this.targetVersion = _data["targetVersion"];
            this.targetDownloadUrl = _data["targetDownloadUrl"];
            this.currentAppPodName = _data["currentAppPodName"];
            this.targetAppPodName = _data["targetAppPodName"];
            this.os = _data["os"];
            this.targetVersionAppSetting = _data["targetVersionAppSetting"];
            this.description = _data["description"];
            this.isLocked = _data["isLocked"];
            this.extensionData = _data["extensionData"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): DeviceAppPodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAppPodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentAppPodVersionId"] = this.currentAppPodVersionId;
        data["currentVersion"] = this.currentVersion;
        data["currentDownloadUrl"] = this.currentDownloadUrl;
        data["targetAppPodVersionId"] = this.targetAppPodVersionId;
        data["targetVersion"] = this.targetVersion;
        data["targetDownloadUrl"] = this.targetDownloadUrl;
        data["currentAppPodName"] = this.currentAppPodName;
        data["targetAppPodName"] = this.targetAppPodName;
        data["os"] = this.os;
        data["targetVersionAppSetting"] = this.targetVersionAppSetting;
        data["description"] = this.description;
        data["isLocked"] = this.isLocked;
        data["extensionData"] = this.extensionData;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

export interface IDeviceAppPodVersionDto {
    currentAppPodVersionId: number | undefined;
    currentVersion: string | undefined;
    currentDownloadUrl: string | undefined;
    targetAppPodVersionId: number | undefined;
    targetVersion: string | undefined;
    targetDownloadUrl: string | undefined;
    currentAppPodName: string | undefined;
    targetAppPodName: string | undefined;
    os: string | undefined;
    targetVersionAppSetting: string | undefined;
    description: string | undefined;
    isLocked: boolean | undefined;
    extensionData: string | undefined;
    md5: string | undefined;
    isNeedRestart: boolean | undefined;
}

export class ChangeDeviceAppPodVersionInput implements IChangeDeviceAppPodVersionInput {
    deviceId!: number | undefined;
    targetAppPodVersionId!: number | undefined;
    extensionData!: string | undefined;
    isLock!: boolean | undefined;

    constructor(data?: IChangeDeviceAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.targetAppPodVersionId = _data["targetAppPodVersionId"];
            this.extensionData = _data["extensionData"];
            this.isLock = _data["isLock"];
        }
    }

    static fromJS(data: any): ChangeDeviceAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDeviceAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["targetAppPodVersionId"] = this.targetAppPodVersionId;
        data["extensionData"] = this.extensionData;
        data["isLock"] = this.isLock;
        return data; 
    }
}

export interface IChangeDeviceAppPodVersionInput {
    deviceId: number | undefined;
    targetAppPodVersionId: number | undefined;
    extensionData: string | undefined;
    isLock: boolean | undefined;
}

export class IFormFile implements IIFormFile {
    readonly contentType!: string | undefined;
    readonly contentDisposition!: string | undefined;
    readonly headers!: { [key: string]: string[]; } | undefined;
    readonly length!: number | undefined;
    readonly name!: string | undefined;
    readonly fileName!: string | undefined;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).contentType = _data["contentType"];
            (<any>this).contentDisposition = _data["contentDisposition"];
            if (_data["headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this).headers![key] = _data["headers"][key] !== undefined ? _data["headers"][key] : [];
                }
            }
            (<any>this).length = _data["length"];
            (<any>this).name = _data["name"];
            (<any>this).fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["contentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["length"] = this.length;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IIFormFile {
    contentType: string | undefined;
    contentDisposition: string | undefined;
    headers: { [key: string]: string[]; } | undefined;
    length: number | undefined;
    name: string | undefined;
    fileName: string | undefined;
}

export class GetAgreementFileDto implements IGetAgreementFileDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    datas!: string[] | undefined;
    creationTime!: moment.Moment | undefined;
    fileName!: string | undefined;

    constructor(data?: IGetAgreementFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datas"])) {
                this.datas = [] as any;
                for (let item of _data["datas"])
                    this.datas!.push(item);
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): GetAgreementFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgreementFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datas)) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IGetAgreementFileDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    datas: string[] | undefined;
    creationTime: moment.Moment | undefined;
    fileName: string | undefined;
}

export class PagedResultDtoOfGetAgreementsDto implements IPagedResultDtoOfGetAgreementsDto {
    totalCount!: number | undefined;
    items!: GetAgreementsDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAgreementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAgreementsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAgreementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAgreementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAgreementsDto {
    totalCount: number | undefined;
    items: GetAgreementsDto[] | undefined;
}

export class GetAgreementsDto implements IGetAgreementsDto {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAgreementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAgreementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgreementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IGetAgreementsDto {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfDeviceAgreement implements IPagedResultDtoOfDeviceAgreement {
    totalCount!: number | undefined;
    items!: DeviceAgreement[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceAgreement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceAgreement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceAgreement {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceAgreement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfDeviceAgreement {
    totalCount: number | undefined;
    items: DeviceAgreement[] | undefined;
}

export class DeviceAgreement implements IDeviceAgreement {
    name!: string | undefined;
    agreement!: string | undefined;
    description!: string | undefined;
    datas!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IDeviceAgreement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.agreement = _data["agreement"];
            this.description = _data["description"];
            this.datas = _data["datas"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceAgreement {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAgreement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["agreement"] = this.agreement;
        data["description"] = this.description;
        data["datas"] = this.datas;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceAgreement {
    name: string | undefined;
    agreement: string | undefined;
    description: string | undefined;
    datas: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateCounterGroupInput implements ICreateCounterGroupInput {
    storeId!: number | undefined;
    groupName!: string | undefined;

    constructor(data?: ICreateCounterGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): CreateCounterGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["groupName"] = this.groupName;
        return data; 
    }
}

export interface ICreateCounterGroupInput {
    storeId: number | undefined;
    groupName: string | undefined;
}

export class GetCounterGroupDto implements IGetCounterGroupDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    groupName!: string | undefined;
    memberCount!: number | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IGetCounterGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.groupName = _data["groupName"];
            this.memberCount = _data["memberCount"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCounterGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCounterGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["groupName"] = this.groupName;
        data["memberCount"] = this.memberCount;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetCounterGroupDto {
    id: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    groupName: string | undefined;
    memberCount: number | undefined;
    creationTime: moment.Moment | undefined;
}

export class IndustryCurentDataReportDto implements IIndustryCurentDataReportDto {
    counterId!: number | undefined;
    counterName!: string | undefined;
    data!: number | undefined;
    upLimit1!: number | undefined;
    upLimit2!: number | undefined;
    upLimit3!: number | undefined;
    downLimit1!: number | undefined;
    downLimit2!: number | undefined;
    downLimit3!: number | undefined;

    constructor(data?: IIndustryCurentDataReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterId = _data["counterId"];
            this.counterName = _data["counterName"];
            this.data = _data["data"];
            this.upLimit1 = _data["upLimit1"];
            this.upLimit2 = _data["upLimit2"];
            this.upLimit3 = _data["upLimit3"];
            this.downLimit1 = _data["downLimit1"];
            this.downLimit2 = _data["downLimit2"];
            this.downLimit3 = _data["downLimit3"];
        }
    }

    static fromJS(data: any): IndustryCurentDataReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryCurentDataReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterId"] = this.counterId;
        data["counterName"] = this.counterName;
        data["data"] = this.data;
        data["upLimit1"] = this.upLimit1;
        data["upLimit2"] = this.upLimit2;
        data["upLimit3"] = this.upLimit3;
        data["downLimit1"] = this.downLimit1;
        data["downLimit2"] = this.downLimit2;
        data["downLimit3"] = this.downLimit3;
        return data; 
    }
}

export interface IIndustryCurentDataReportDto {
    counterId: number | undefined;
    counterName: string | undefined;
    data: number | undefined;
    upLimit1: number | undefined;
    upLimit2: number | undefined;
    upLimit3: number | undefined;
    downLimit1: number | undefined;
    downLimit2: number | undefined;
    downLimit3: number | undefined;
}

export class GetSwitchStatusDto implements IGetSwitchStatusDto {
    switches!: SwitchInfo[] | undefined;
    operateRecords!: OperateRecord[] | undefined;

    constructor(data?: IGetSwitchStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["switches"])) {
                this.switches = [] as any;
                for (let item of _data["switches"])
                    this.switches!.push(SwitchInfo.fromJS(item));
            }
            if (Array.isArray(_data["operateRecords"])) {
                this.operateRecords = [] as any;
                for (let item of _data["operateRecords"])
                    this.operateRecords!.push(OperateRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSwitchStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSwitchStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.switches)) {
            data["switches"] = [];
            for (let item of this.switches)
                data["switches"].push(item.toJSON());
        }
        if (Array.isArray(this.operateRecords)) {
            data["operateRecords"] = [];
            for (let item of this.operateRecords)
                data["operateRecords"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSwitchStatusDto {
    switches: SwitchInfo[] | undefined;
    operateRecords: OperateRecord[] | undefined;
}

export class SwitchInfo implements ISwitchInfo {
    id!: number | undefined;
    gatewayId!: number | undefined;
    name!: string | undefined;
    status!: SwitchInfoStatus | undefined;

    constructor(data?: ISwitchInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gatewayId = _data["gatewayId"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SwitchInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gatewayId"] = this.gatewayId;
        data["name"] = this.name;
        data["status"] = this.status;
        return data; 
    }
}

export interface ISwitchInfo {
    id: number | undefined;
    gatewayId: number | undefined;
    name: string | undefined;
    status: SwitchInfoStatus | undefined;
}

export class OperateRecord implements IOperateRecord {
    switchId!: number | undefined;
    switchName!: string | undefined;
    switchStatus!: OperateRecordSwitchStatus | undefined;
    startTime!: moment.Moment | undefined;
    currentData!: number | undefined;
    limitData!: number | undefined;
    description!: string | undefined;
    controlType!: OperateRecordControlType | undefined;
    isSuccess!: boolean | undefined;

    constructor(data?: IOperateRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchId = _data["switchId"];
            this.switchName = _data["switchName"];
            this.switchStatus = _data["switchStatus"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.currentData = _data["currentData"];
            this.limitData = _data["limitData"];
            this.description = _data["description"];
            this.controlType = _data["controlType"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): OperateRecord {
        data = typeof data === 'object' ? data : {};
        let result = new OperateRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchId"] = this.switchId;
        data["switchName"] = this.switchName;
        data["switchStatus"] = this.switchStatus;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["currentData"] = this.currentData;
        data["limitData"] = this.limitData;
        data["description"] = this.description;
        data["controlType"] = this.controlType;
        data["isSuccess"] = this.isSuccess;
        return data; 
    }
}

export interface IOperateRecord {
    switchId: number | undefined;
    switchName: string | undefined;
    switchStatus: OperateRecordSwitchStatus | undefined;
    startTime: moment.Moment | undefined;
    currentData: number | undefined;
    limitData: number | undefined;
    description: string | undefined;
    controlType: OperateRecordControlType | undefined;
    isSuccess: boolean | undefined;
}

export class GetWarnningRecordDto implements IGetWarnningRecordDto {
    totalCount!: number | undefined;
    unHandledCount!: number | undefined;
    handledCount!: number | undefined;
    warnningRecords!: WarnningRecordDto[] | undefined;
    warnningRecordsHandled!: WarnningRecordDto[] | undefined;
    warnningRecordsUnHandled!: WarnningRecordDto[] | undefined;

    constructor(data?: IGetWarnningRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.unHandledCount = _data["unHandledCount"];
            this.handledCount = _data["handledCount"];
            if (Array.isArray(_data["warnningRecords"])) {
                this.warnningRecords = [] as any;
                for (let item of _data["warnningRecords"])
                    this.warnningRecords!.push(WarnningRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["warnningRecordsHandled"])) {
                this.warnningRecordsHandled = [] as any;
                for (let item of _data["warnningRecordsHandled"])
                    this.warnningRecordsHandled!.push(WarnningRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["warnningRecordsUnHandled"])) {
                this.warnningRecordsUnHandled = [] as any;
                for (let item of _data["warnningRecordsUnHandled"])
                    this.warnningRecordsUnHandled!.push(WarnningRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWarnningRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarnningRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["unHandledCount"] = this.unHandledCount;
        data["handledCount"] = this.handledCount;
        if (Array.isArray(this.warnningRecords)) {
            data["warnningRecords"] = [];
            for (let item of this.warnningRecords)
                data["warnningRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.warnningRecordsHandled)) {
            data["warnningRecordsHandled"] = [];
            for (let item of this.warnningRecordsHandled)
                data["warnningRecordsHandled"].push(item.toJSON());
        }
        if (Array.isArray(this.warnningRecordsUnHandled)) {
            data["warnningRecordsUnHandled"] = [];
            for (let item of this.warnningRecordsUnHandled)
                data["warnningRecordsUnHandled"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetWarnningRecordDto {
    totalCount: number | undefined;
    unHandledCount: number | undefined;
    handledCount: number | undefined;
    warnningRecords: WarnningRecordDto[] | undefined;
    warnningRecordsHandled: WarnningRecordDto[] | undefined;
    warnningRecordsUnHandled: WarnningRecordDto[] | undefined;
}

export class WarnningRecordDto implements IWarnningRecordDto {
    id!: number | undefined;
    collectionTime!: moment.Moment | undefined;
    description!: string | undefined;
    handlerStatus!: WarnningRecordDtoHandlerStatus | undefined;

    constructor(data?: IWarnningRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.handlerStatus = _data["handlerStatus"];
        }
    }

    static fromJS(data: any): WarnningRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarnningRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["handlerStatus"] = this.handlerStatus;
        return data; 
    }
}

export interface IWarnningRecordDto {
    id: number | undefined;
    collectionTime: moment.Moment | undefined;
    description: string | undefined;
    handlerStatus: WarnningRecordDtoHandlerStatus | undefined;
}

export class GetDatasDto implements IGetDatasDto {
    totalCount!: number | undefined;
    normalCount!: number | undefined;
    abnormalCount!: number | undefined;
    dataRecords!: DataRecordDto[] | undefined;
    dataRecordsNormal!: DataRecordDto[] | undefined;
    dataRecordsAbnormal!: DataRecordDto[] | undefined;

    constructor(data?: IGetDatasDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.normalCount = _data["normalCount"];
            this.abnormalCount = _data["abnormalCount"];
            if (Array.isArray(_data["dataRecords"])) {
                this.dataRecords = [] as any;
                for (let item of _data["dataRecords"])
                    this.dataRecords!.push(DataRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["dataRecordsNormal"])) {
                this.dataRecordsNormal = [] as any;
                for (let item of _data["dataRecordsNormal"])
                    this.dataRecordsNormal!.push(DataRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["dataRecordsAbnormal"])) {
                this.dataRecordsAbnormal = [] as any;
                for (let item of _data["dataRecordsAbnormal"])
                    this.dataRecordsAbnormal!.push(DataRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDatasDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDatasDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["normalCount"] = this.normalCount;
        data["abnormalCount"] = this.abnormalCount;
        if (Array.isArray(this.dataRecords)) {
            data["dataRecords"] = [];
            for (let item of this.dataRecords)
                data["dataRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.dataRecordsNormal)) {
            data["dataRecordsNormal"] = [];
            for (let item of this.dataRecordsNormal)
                data["dataRecordsNormal"].push(item.toJSON());
        }
        if (Array.isArray(this.dataRecordsAbnormal)) {
            data["dataRecordsAbnormal"] = [];
            for (let item of this.dataRecordsAbnormal)
                data["dataRecordsAbnormal"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDatasDto {
    totalCount: number | undefined;
    normalCount: number | undefined;
    abnormalCount: number | undefined;
    dataRecords: DataRecordDto[] | undefined;
    dataRecordsNormal: DataRecordDto[] | undefined;
    dataRecordsAbnormal: DataRecordDto[] | undefined;
}

export class DataRecordDto implements IDataRecordDto {
    id!: number | undefined;
    collectionTime!: moment.Moment | undefined;
    dataName!: string | undefined;
    data!: number | undefined;
    dataStatus!: DataRecordDtoDataStatus | undefined;

    constructor(data?: IDataRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.dataName = _data["dataName"];
            this.data = _data["data"];
            this.dataStatus = _data["dataStatus"];
        }
    }

    static fromJS(data: any): DataRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["dataName"] = this.dataName;
        data["data"] = this.data;
        data["dataStatus"] = this.dataStatus;
        return data; 
    }
}

export interface IDataRecordDto {
    id: number | undefined;
    collectionTime: moment.Moment | undefined;
    dataName: string | undefined;
    data: number | undefined;
    dataStatus: DataRecordDtoDataStatus | undefined;
}

export class AddOrUpdateReportTemplateInput implements IAddOrUpdateReportTemplateInput {
    id!: number | undefined;
    name!: string | undefined;
    counterTagRules!: AddOrUpdateReportTemplateInputCounterTagRules | undefined;
    deviceTagRules!: AddOrUpdateReportTemplateInputDeviceTagRules | undefined;
    reportType!: AddOrUpdateReportTemplateInputReportType | undefined;
    isNeedExternalData!: boolean | undefined;
    description!: string | undefined;
    maxReportDataCount!: number | undefined;
    minReportDataCount!: number | undefined;
    canChangeReportDataName!: boolean | undefined;
    canMultiToOne!: boolean | undefined;
    reportDataNames!: string | undefined;
    calcFormat!: string | undefined;
    multiToOneName!: string | undefined;
    reportCompareType!: AddOrUpdateReportTemplateInputReportCompareType | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;
    isShowMolecule!: boolean | undefined;
    isShowDenominator!: boolean | undefined;
    canChangeDigitTitle!: boolean | undefined;
    privilege!: string | undefined;
    moleculeBackGroudClassName!: string | undefined;
    moleculeIconClassName!: string | undefined;
    denominatorBackGroudClassName!: string | undefined;
    denominatorIconClassName!: string | undefined;

    constructor(data?: IAddOrUpdateReportTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.counterTagRules = _data["counterTagRules"];
            this.deviceTagRules = _data["deviceTagRules"];
            this.reportType = _data["reportType"];
            this.isNeedExternalData = _data["isNeedExternalData"];
            this.description = _data["description"];
            this.maxReportDataCount = _data["maxReportDataCount"];
            this.minReportDataCount = _data["minReportDataCount"];
            this.canChangeReportDataName = _data["canChangeReportDataName"];
            this.canMultiToOne = _data["canMultiToOne"];
            this.reportDataNames = _data["reportDataNames"];
            this.calcFormat = _data["calcFormat"];
            this.multiToOneName = _data["multiToOneName"];
            this.reportCompareType = _data["reportCompareType"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            this.isShowMolecule = _data["isShowMolecule"];
            this.isShowDenominator = _data["isShowDenominator"];
            this.canChangeDigitTitle = _data["canChangeDigitTitle"];
            this.privilege = _data["privilege"];
            this.moleculeBackGroudClassName = _data["moleculeBackGroudClassName"];
            this.moleculeIconClassName = _data["moleculeIconClassName"];
            this.denominatorBackGroudClassName = _data["denominatorBackGroudClassName"];
            this.denominatorIconClassName = _data["denominatorIconClassName"];
        }
    }

    static fromJS(data: any): AddOrUpdateReportTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateReportTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["counterTagRules"] = this.counterTagRules;
        data["deviceTagRules"] = this.deviceTagRules;
        data["reportType"] = this.reportType;
        data["isNeedExternalData"] = this.isNeedExternalData;
        data["description"] = this.description;
        data["maxReportDataCount"] = this.maxReportDataCount;
        data["minReportDataCount"] = this.minReportDataCount;
        data["canChangeReportDataName"] = this.canChangeReportDataName;
        data["canMultiToOne"] = this.canMultiToOne;
        data["reportDataNames"] = this.reportDataNames;
        data["calcFormat"] = this.calcFormat;
        data["multiToOneName"] = this.multiToOneName;
        data["reportCompareType"] = this.reportCompareType;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        data["isShowMolecule"] = this.isShowMolecule;
        data["isShowDenominator"] = this.isShowDenominator;
        data["canChangeDigitTitle"] = this.canChangeDigitTitle;
        data["privilege"] = this.privilege;
        data["moleculeBackGroudClassName"] = this.moleculeBackGroudClassName;
        data["moleculeIconClassName"] = this.moleculeIconClassName;
        data["denominatorBackGroudClassName"] = this.denominatorBackGroudClassName;
        data["denominatorIconClassName"] = this.denominatorIconClassName;
        return data; 
    }
}

export interface IAddOrUpdateReportTemplateInput {
    id: number | undefined;
    name: string | undefined;
    counterTagRules: AddOrUpdateReportTemplateInputCounterTagRules | undefined;
    deviceTagRules: AddOrUpdateReportTemplateInputDeviceTagRules | undefined;
    reportType: AddOrUpdateReportTemplateInputReportType | undefined;
    isNeedExternalData: boolean | undefined;
    description: string | undefined;
    maxReportDataCount: number | undefined;
    minReportDataCount: number | undefined;
    canChangeReportDataName: boolean | undefined;
    canMultiToOne: boolean | undefined;
    reportDataNames: string | undefined;
    calcFormat: string | undefined;
    multiToOneName: string | undefined;
    reportCompareType: AddOrUpdateReportTemplateInputReportCompareType | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
    isShowMolecule: boolean | undefined;
    isShowDenominator: boolean | undefined;
    canChangeDigitTitle: boolean | undefined;
    privilege: string | undefined;
    moleculeBackGroudClassName: string | undefined;
    moleculeIconClassName: string | undefined;
    denominatorBackGroudClassName: string | undefined;
    denominatorIconClassName: string | undefined;
}

export class PagedResultDtoOfGetReportTemplateDto implements IPagedResultDtoOfGetReportTemplateDto {
    totalCount!: number | undefined;
    items!: GetReportTemplateDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetReportTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetReportTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetReportTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetReportTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetReportTemplateDto {
    totalCount: number | undefined;
    items: GetReportTemplateDto[] | undefined;
}

export class GetReportTemplateDto implements IGetReportTemplateDto {
    id!: number | undefined;
    name!: string | undefined;
    counterTagRules!: GetReportTemplateDtoCounterTagRules | undefined;
    deviceTagRules!: GetReportTemplateDtoDeviceTagRules | undefined;
    reportType!: GetReportTemplateDtoReportType | undefined;
    isNeedExternalData!: boolean | undefined;
    description!: string | undefined;
    maxReportDataCount!: number | undefined;
    minReportDataCount!: number | undefined;
    canChangeReportDataName!: boolean | undefined;
    canMultiToOne!: boolean | undefined;
    reportDataNames!: string | undefined;
    calcFormat!: string | undefined;
    multiToOneName!: string | undefined;
    reportCompareType!: GetReportTemplateDtoReportCompareType | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;
    isShowMolecule!: boolean | undefined;
    isShowDenominator!: boolean | undefined;
    canChangeDigitTitle!: boolean | undefined;
    privilege!: string | undefined;
    moleculeBackGroudClassName!: string | undefined;
    moleculeIconClassName!: string | undefined;
    denominatorBackGroudClassName!: string | undefined;
    denominatorIconClassName!: string | undefined;

    constructor(data?: IGetReportTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.counterTagRules = _data["counterTagRules"];
            this.deviceTagRules = _data["deviceTagRules"];
            this.reportType = _data["reportType"];
            this.isNeedExternalData = _data["isNeedExternalData"];
            this.description = _data["description"];
            this.maxReportDataCount = _data["maxReportDataCount"];
            this.minReportDataCount = _data["minReportDataCount"];
            this.canChangeReportDataName = _data["canChangeReportDataName"];
            this.canMultiToOne = _data["canMultiToOne"];
            this.reportDataNames = _data["reportDataNames"];
            this.calcFormat = _data["calcFormat"];
            this.multiToOneName = _data["multiToOneName"];
            this.reportCompareType = _data["reportCompareType"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            this.isShowMolecule = _data["isShowMolecule"];
            this.isShowDenominator = _data["isShowDenominator"];
            this.canChangeDigitTitle = _data["canChangeDigitTitle"];
            this.privilege = _data["privilege"];
            this.moleculeBackGroudClassName = _data["moleculeBackGroudClassName"];
            this.moleculeIconClassName = _data["moleculeIconClassName"];
            this.denominatorBackGroudClassName = _data["denominatorBackGroudClassName"];
            this.denominatorIconClassName = _data["denominatorIconClassName"];
        }
    }

    static fromJS(data: any): GetReportTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["counterTagRules"] = this.counterTagRules;
        data["deviceTagRules"] = this.deviceTagRules;
        data["reportType"] = this.reportType;
        data["isNeedExternalData"] = this.isNeedExternalData;
        data["description"] = this.description;
        data["maxReportDataCount"] = this.maxReportDataCount;
        data["minReportDataCount"] = this.minReportDataCount;
        data["canChangeReportDataName"] = this.canChangeReportDataName;
        data["canMultiToOne"] = this.canMultiToOne;
        data["reportDataNames"] = this.reportDataNames;
        data["calcFormat"] = this.calcFormat;
        data["multiToOneName"] = this.multiToOneName;
        data["reportCompareType"] = this.reportCompareType;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        data["isShowMolecule"] = this.isShowMolecule;
        data["isShowDenominator"] = this.isShowDenominator;
        data["canChangeDigitTitle"] = this.canChangeDigitTitle;
        data["privilege"] = this.privilege;
        data["moleculeBackGroudClassName"] = this.moleculeBackGroudClassName;
        data["moleculeIconClassName"] = this.moleculeIconClassName;
        data["denominatorBackGroudClassName"] = this.denominatorBackGroudClassName;
        data["denominatorIconClassName"] = this.denominatorIconClassName;
        return data; 
    }
}

export interface IGetReportTemplateDto {
    id: number | undefined;
    name: string | undefined;
    counterTagRules: GetReportTemplateDtoCounterTagRules | undefined;
    deviceTagRules: GetReportTemplateDtoDeviceTagRules | undefined;
    reportType: GetReportTemplateDtoReportType | undefined;
    isNeedExternalData: boolean | undefined;
    description: string | undefined;
    maxReportDataCount: number | undefined;
    minReportDataCount: number | undefined;
    canChangeReportDataName: boolean | undefined;
    canMultiToOne: boolean | undefined;
    reportDataNames: string | undefined;
    calcFormat: string | undefined;
    multiToOneName: string | undefined;
    reportCompareType: GetReportTemplateDtoReportCompareType | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
    isShowMolecule: boolean | undefined;
    isShowDenominator: boolean | undefined;
    canChangeDigitTitle: boolean | undefined;
    privilege: string | undefined;
    moleculeBackGroudClassName: string | undefined;
    moleculeIconClassName: string | undefined;
    denominatorBackGroudClassName: string | undefined;
    denominatorIconClassName: string | undefined;
}

export class AddOrUpdateReportInput implements IAddOrUpdateReportInput {
    id!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    reportDataType!: AddOrUpdateReportInputReportDataType | undefined;
    name!: string | undefined;
    reportTemplateID!: number | undefined;
    externalDataId!: number | undefined;
    description!: string | undefined;
    calcFormat!: string | undefined;
    orderSequece!: number | undefined;
    multiToOneName!: string | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;
    reportDataInput!: ReportDataInput[] | undefined;

    constructor(data?: IAddOrUpdateReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            if (Array.isArray(_data["reportDataInput"])) {
                this.reportDataInput = [] as any;
                for (let item of _data["reportDataInput"])
                    this.reportDataInput!.push(ReportDataInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        if (Array.isArray(this.reportDataInput)) {
            data["reportDataInput"] = [];
            for (let item of this.reportDataInput)
                data["reportDataInput"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateReportInput {
    id: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    reportDataType: AddOrUpdateReportInputReportDataType | undefined;
    name: string | undefined;
    reportTemplateID: number | undefined;
    externalDataId: number | undefined;
    description: string | undefined;
    calcFormat: string | undefined;
    orderSequece: number | undefined;
    multiToOneName: string | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
    reportDataInput: ReportDataInput[] | undefined;
}

export class ReportDataInput implements IReportDataInput {
    name!: string | undefined;
    calculateType!: ReportDataInputCalculateType | undefined;
    counterTags!: number[] | undefined;
    deviceIds!: number[] | undefined;

    constructor(data?: IReportDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.calculateType = _data["calculateType"];
            if (Array.isArray(_data["counterTags"])) {
                this.counterTags = [] as any;
                for (let item of _data["counterTags"])
                    this.counterTags!.push(item);
            }
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ReportDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["calculateType"] = this.calculateType;
        if (Array.isArray(this.counterTags)) {
            data["counterTags"] = [];
            for (let item of this.counterTags)
                data["counterTags"].push(item);
        }
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        return data; 
    }
}

export interface IReportDataInput {
    name: string | undefined;
    calculateType: ReportDataInputCalculateType | undefined;
    counterTags: number[] | undefined;
    deviceIds: number[] | undefined;
}

export class PagedResultDtoOfGetReportDto implements IPagedResultDtoOfGetReportDto {
    totalCount!: number | undefined;
    items!: GetReportDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetReportDto {
    totalCount: number | undefined;
    items: GetReportDto[] | undefined;
}

export class GetReportDto implements IGetReportDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    reportDataType!: GetReportDtoReportDataType | undefined;
    name!: string | undefined;
    reportTemplateID!: number | undefined;
    reportTemplateName!: string | undefined;
    reportTemplate!: GetReportTemplateDto | undefined;
    externalDataId!: number | undefined;
    description!: string | undefined;
    calcFormat!: string | undefined;
    orderSequece!: number | undefined;
    multiToOneName!: string | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;

    constructor(data?: IGetReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.reportTemplateName = _data["reportTemplateName"];
            this.reportTemplate = _data["reportTemplate"] ? GetReportTemplateDto.fromJS(_data["reportTemplate"]) : <any>undefined;
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
        }
    }

    static fromJS(data: any): GetReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["reportTemplateName"] = this.reportTemplateName;
        data["reportTemplate"] = this.reportTemplate ? this.reportTemplate.toJSON() : <any>undefined;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        return data; 
    }
}

export interface IGetReportDto {
    id: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    reportDataType: GetReportDtoReportDataType | undefined;
    name: string | undefined;
    reportTemplateID: number | undefined;
    reportTemplateName: string | undefined;
    reportTemplate: GetReportTemplateDto | undefined;
    externalDataId: number | undefined;
    description: string | undefined;
    calcFormat: string | undefined;
    orderSequece: number | undefined;
    multiToOneName: string | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
}

export class GetReportDetailDto implements IGetReportDetailDto {
    reportDatas!: GetReportDataDto[] | undefined;
    id!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    reportDataType!: GetReportDetailDtoReportDataType | undefined;
    name!: string | undefined;
    reportTemplateID!: number | undefined;
    reportTemplateName!: string | undefined;
    reportTemplate!: GetReportTemplateDto | undefined;
    externalDataId!: number | undefined;
    description!: string | undefined;
    calcFormat!: string | undefined;
    orderSequece!: number | undefined;
    multiToOneName!: string | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;

    constructor(data?: IGetReportDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportDatas"])) {
                this.reportDatas = [] as any;
                for (let item of _data["reportDatas"])
                    this.reportDatas!.push(GetReportDataDto.fromJS(item));
            }
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.reportTemplateName = _data["reportTemplateName"];
            this.reportTemplate = _data["reportTemplate"] ? GetReportTemplateDto.fromJS(_data["reportTemplate"]) : <any>undefined;
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
        }
    }

    static fromJS(data: any): GetReportDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportDatas)) {
            data["reportDatas"] = [];
            for (let item of this.reportDatas)
                data["reportDatas"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["reportTemplateName"] = this.reportTemplateName;
        data["reportTemplate"] = this.reportTemplate ? this.reportTemplate.toJSON() : <any>undefined;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        return data; 
    }
}

export interface IGetReportDetailDto {
    reportDatas: GetReportDataDto[] | undefined;
    id: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    reportDataType: GetReportDetailDtoReportDataType | undefined;
    name: string | undefined;
    reportTemplateID: number | undefined;
    reportTemplateName: string | undefined;
    reportTemplate: GetReportTemplateDto | undefined;
    externalDataId: number | undefined;
    description: string | undefined;
    calcFormat: string | undefined;
    orderSequece: number | undefined;
    multiToOneName: string | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
}

export class GetReportDataDto implements IGetReportDataDto {
    name!: string | undefined;
    calculateType!: GetReportDataDtoCalculateType | undefined;
    counterTags!: GetCounterTagInfoDto[] | undefined;
    deviceInfos!: GetDeviceInfoDto[] | undefined;

    constructor(data?: IGetReportDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.calculateType = _data["calculateType"];
            if (Array.isArray(_data["counterTags"])) {
                this.counterTags = [] as any;
                for (let item of _data["counterTags"])
                    this.counterTags!.push(GetCounterTagInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["deviceInfos"])) {
                this.deviceInfos = [] as any;
                for (let item of _data["deviceInfos"])
                    this.deviceInfos!.push(GetDeviceInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReportDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["calculateType"] = this.calculateType;
        if (Array.isArray(this.counterTags)) {
            data["counterTags"] = [];
            for (let item of this.counterTags)
                data["counterTags"].push(item.toJSON());
        }
        if (Array.isArray(this.deviceInfos)) {
            data["deviceInfos"] = [];
            for (let item of this.deviceInfos)
                data["deviceInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReportDataDto {
    name: string | undefined;
    calculateType: GetReportDataDtoCalculateType | undefined;
    counterTags: GetCounterTagInfoDto[] | undefined;
    deviceInfos: GetDeviceInfoDto[] | undefined;
}

export class GetDeviceInfoDto implements IGetDeviceInfoDto {
    id!: number | undefined;
    deviceName!: string | undefined;

    constructor(data?: IGetDeviceInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceName = _data["deviceName"];
        }
    }

    static fromJS(data: any): GetDeviceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceName"] = this.deviceName;
        return data; 
    }
}

export interface IGetDeviceInfoDto {
    id: number | undefined;
    deviceName: string | undefined;
}

export class Tag implements ITag {
    value!: string;
    type!: TagType | undefined;
    iconUrl!: string | undefined;
    isSpecial!: boolean | undefined;
    tenantId!: number | undefined;
    organizationUnitId!: number | undefined;
    orderNumber!: number | undefined;
    description!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType | undefined;
    iconUrl: string | undefined;
    isSpecial: boolean | undefined;
    tenantId: number | undefined;
    organizationUnitId: number | undefined;
    orderNumber: number | undefined;
    description: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class IdOuterIdValueDto implements IIdOuterIdValueDto {
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: IIdOuterIdValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdOuterIdValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdOuterIdValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIdOuterIdValueDto {
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

export class GetGuestChartDto implements IGetGuestChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number | undefined;
    yesterday!: number | undefined;

    constructor(data?: IGetGuestChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.today = _data["today"];
            this.yesterday = _data["yesterday"];
        }
    }

    static fromJS(data: any): GetGuestChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuestChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

export interface IGetGuestChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number | undefined;
    yesterday: number | undefined;
}

export class DropCargoInput implements IDropCargoInput {
    subkey!: string;
    cargoRoadId!: number | undefined;
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: IDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.extensionData = _data["extensionData"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): DropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new DropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface IDropCargoInput {
    subkey: string;
    cargoRoadId: number | undefined;
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    actionId: number | undefined;
}

export class UpdateCargoStockInput implements IUpdateCargoStockInput {
    subkey!: string;
    cargoStocks!: CargoStock[] | undefined;

    constructor(data?: IUpdateCargoStockInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            if (Array.isArray(_data["cargoStocks"])) {
                this.cargoStocks = [] as any;
                for (let item of _data["cargoStocks"])
                    this.cargoStocks!.push(CargoStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCargoStockInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoStockInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        if (Array.isArray(this.cargoStocks)) {
            data["cargoStocks"] = [];
            for (let item of this.cargoStocks)
                data["cargoStocks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateCargoStockInput {
    subkey: string;
    cargoStocks: CargoStock[] | undefined;
}

export class CargoStock implements ICargoStock {
    cargoRoadId!: number | undefined;
    replenishCargoThing!: ReplenishCargoThingInput[] | undefined;

    constructor(data?: ICargoStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cargoRoadId = _data["cargoRoadId"];
            if (Array.isArray(_data["replenishCargoThing"])) {
                this.replenishCargoThing = [] as any;
                for (let item of _data["replenishCargoThing"])
                    this.replenishCargoThing!.push(ReplenishCargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoStock {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargoRoadId"] = this.cargoRoadId;
        if (Array.isArray(this.replenishCargoThing)) {
            data["replenishCargoThing"] = [];
            for (let item of this.replenishCargoThing)
                data["replenishCargoThing"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoStock {
    cargoRoadId: number | undefined;
    replenishCargoThing: ReplenishCargoThingInput[] | undefined;
}

export class ReplenishCargoThingInput implements IReplenishCargoThingInput {
    thingId!: number | undefined;
    stock!: number | undefined;

    constructor(data?: IReplenishCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): ReplenishCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["stock"] = this.stock;
        return data; 
    }
}

export interface IReplenishCargoThingInput {
    thingId: number | undefined;
    stock: number | undefined;
}

export class MutipleDropCargoInput implements IMutipleDropCargoInput {
    quantity!: number | undefined;
    subkey!: string;
    cargoRoadId!: number | undefined;
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    actionId!: number | undefined;

    constructor(data?: IMutipleDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.subkey = _data["subkey"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.extensionData = _data["extensionData"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): MutipleDropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new MutipleDropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface IMutipleDropCargoInput {
    quantity: number | undefined;
    subkey: string;
    cargoRoadId: number | undefined;
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    actionId: number | undefined;
}

export class ChangeDeviceAppPodCurrentVersionInput implements IChangeDeviceAppPodCurrentVersionInput {
    subkey!: string;
    currentAppPodVersionId!: number | undefined;

    constructor(data?: IChangeDeviceAppPodCurrentVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.currentAppPodVersionId = _data["currentAppPodVersionId"];
        }
    }

    static fromJS(data: any): ChangeDeviceAppPodCurrentVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDeviceAppPodCurrentVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["currentAppPodVersionId"] = this.currentAppPodVersionId;
        return data; 
    }
}

export interface IChangeDeviceAppPodCurrentVersionInput {
    subkey: string;
    currentAppPodVersionId: number | undefined;
}

export class AppPodScreenInput implements IAppPodScreenInput {
    /** 人脸照片的二进制图片. */
    screenShot!: string | undefined;

    constructor(data?: IAppPodScreenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.screenShot = _data["screenShot"];
        }
    }

    static fromJS(data: any): AppPodScreenInput {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodScreenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["screenShot"] = this.screenShot;
        return data; 
    }
}

export interface IAppPodScreenInput {
    /** 人脸照片的二进制图片. */
    screenShot: string | undefined;
}

export class CreateChildDeviceAndCountersDto implements ICreateChildDeviceAndCountersDto {
    subKey!: string | undefined;
    mac!: string | undefined;
    name!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    status!: string | undefined;
    licenseInfo!: string | undefined;
    type!: string | undefined;
    hardwareCode!: string | undefined;
    counters!: CounterDto[] | undefined;

    constructor(data?: ICreateChildDeviceAndCountersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.mac = _data["mac"];
            this.name = _data["name"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.status = _data["status"];
            this.licenseInfo = _data["licenseInfo"];
            this.type = _data["type"];
            this.hardwareCode = _data["hardwareCode"];
            if (Array.isArray(_data["counters"])) {
                this.counters = [] as any;
                for (let item of _data["counters"])
                    this.counters!.push(CounterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateChildDeviceAndCountersDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChildDeviceAndCountersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["mac"] = this.mac;
        data["name"] = this.name;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["status"] = this.status;
        data["licenseInfo"] = this.licenseInfo;
        data["type"] = this.type;
        data["hardwareCode"] = this.hardwareCode;
        if (Array.isArray(this.counters)) {
            data["counters"] = [];
            for (let item of this.counters)
                data["counters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateChildDeviceAndCountersDto {
    subKey: string | undefined;
    mac: string | undefined;
    name: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    status: string | undefined;
    licenseInfo: string | undefined;
    type: string | undefined;
    hardwareCode: string | undefined;
    counters: CounterDto[] | undefined;
}

export class CounterDto implements ICounterDto {
    name!: string | undefined;

    constructor(data?: ICounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICounterDto {
    name: string | undefined;
}

export class ControlGatewayInput implements IControlGatewayInput {
    gatewayId!: number | undefined;
    switchId!: number | undefined;
    switchStatus!: ControlGatewayInputSwitchStatus | undefined;

    constructor(data?: IControlGatewayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.switchId = _data["switchId"];
            this.switchStatus = _data["switchStatus"];
        }
    }

    static fromJS(data: any): ControlGatewayInput {
        data = typeof data === 'object' ? data : {};
        let result = new ControlGatewayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["switchId"] = this.switchId;
        data["switchStatus"] = this.switchStatus;
        return data; 
    }
}

export interface IControlGatewayInput {
    gatewayId: number | undefined;
    switchId: number | undefined;
    switchStatus: ControlGatewayInputSwitchStatus | undefined;
}

export class DeviceCounterRecords implements IDeviceCounterRecords {
    subKey!: string | undefined;
    mac!: string | undefined;
    counters!: CounterRecordsDto[] | undefined;

    constructor(data?: IDeviceCounterRecords) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.mac = _data["mac"];
            if (Array.isArray(_data["counters"])) {
                this.counters = [] as any;
                for (let item of _data["counters"])
                    this.counters!.push(CounterRecordsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceCounterRecords {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCounterRecords();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["mac"] = this.mac;
        if (Array.isArray(this.counters)) {
            data["counters"] = [];
            for (let item of this.counters)
                data["counters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceCounterRecords {
    subKey: string | undefined;
    mac: string | undefined;
    counters: CounterRecordsDto[] | undefined;
}

export class CounterRecordsDto implements ICounterRecordsDto {
    name!: string | undefined;
    records!: CounterRecordDto[] | undefined;

    constructor(data?: ICounterRecordsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(CounterRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CounterRecordsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterRecordsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICounterRecordsDto {
    name: string | undefined;
    records: CounterRecordDto[] | undefined;
}

export class CounterRecordDto implements ICounterRecordDto {
    collectionTime!: moment.Moment | undefined;
    collectEndTime!: moment.Moment | undefined;
    total!: number | undefined;
    increment!: number | undefined;

    constructor(data?: ICounterRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
            this.total = _data["total"];
            this.increment = _data["increment"];
        }
    }

    static fromJS(data: any): CounterRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["total"] = this.total;
        data["increment"] = this.increment;
        return data; 
    }
}

export interface ICounterRecordDto {
    collectionTime: moment.Moment | undefined;
    collectEndTime: moment.Moment | undefined;
    total: number | undefined;
    increment: number | undefined;
}

export class SimpleProductDto implements ISimpleProductDto {
    thingId!: number | undefined;
    type!: SimpleProductDtoType | undefined;
    title!: string | undefined;
    price!: number | undefined;
    promPrice!: number | undefined;
    picUrl!: string | undefined;
    quantity!: number | undefined;
    description!: string | undefined;

    constructor(data?: ISimpleProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.picUrl = _data["picUrl"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SimpleProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["picUrl"] = this.picUrl;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISimpleProductDto {
    thingId: number | undefined;
    type: SimpleProductDtoType | undefined;
    title: string | undefined;
    price: number | undefined;
    promPrice: number | undefined;
    picUrl: string | undefined;
    quantity: number | undefined;
    description: string | undefined;
}

export class DeviceCargoDto implements IDeviceCargoDto {
    thingId!: number | undefined;
    thingName!: string | undefined;
    cargoRoadId!: number | undefined;
    cargoRoadName!: string | undefined;
    deviceName!: string | undefined;
    deviceId!: number | undefined;

    constructor(data?: IDeviceCargoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.thingName = _data["thingName"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoRoadName = _data["cargoRoadName"];
            this.deviceName = _data["deviceName"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): DeviceCargoDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCargoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["thingName"] = this.thingName;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoRoadName"] = this.cargoRoadName;
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        return data; 
    }
}

export interface IDeviceCargoDto {
    thingId: number | undefined;
    thingName: string | undefined;
    cargoRoadId: number | undefined;
    cargoRoadName: string | undefined;
    deviceName: string | undefined;
    deviceId: number | undefined;
}

export class ShelfDto implements IShelfDto {
    /** 设备Id */
    id!: number | undefined;
    /** 设备名称 */
    name!: string | undefined;
    /** 设备MAC地址 */
    mac!: string | undefined;
    /** 设备是否锁定 */
    isLocked!: boolean | undefined;
    /** 设备类型名称 */
    deviceTypeName!: string | undefined;
    /** 设备地址 */
    address!: string | undefined;
    /** 描述字段 */
    description!: string | undefined;
    /** 硬件编码 */
    hardwareCode!: string | undefined;
    /** 关机时间 */
    shutdownTime!: moment.Moment | undefined;
    /** 以某一标准正方向设定的摆放角度 */
    shelfDirectionAngle!: number | undefined;
    /** X方向长度 */
    resolution_Length!: number | undefined;
    /** 以房间某个角落为起点，货架摆放位置离起点在X方向的距离 */
    startPoint_X!: number | undefined;
    /** Y方向长度 */
    resolution_Width!: number | undefined;
    /** 以房间某个角落为起点，货架摆放位置离起点在Y方向的距离 */
    startPoint_Y!: number | undefined;
    /** Z方向长度 */
    resolution_Height!: number | undefined;
    /** 设备Subkey */
    subKey!: string | undefined;
    /** 设备系统 */
    os!: string | undefined;
    /** 租户名称 */
    tenantName!: string | undefined;
    /** 租户Id */
    tenantId!: number | undefined;
    /** 组织机构名称 */
    organizationUnitName!: string | undefined;
    /** 组织机构Id */
    organizationUnitId!: number | undefined;
    outType!: string | undefined;
    /** 设备垫高 */
    footerHeight!: number | undefined;
    /** 隔板厚度 */
    outerPartitionHeight!: number | undefined;
    /** 层板厚度 */
    layerPartitionHeight!: number | undefined;
    /** 设备层,一个智能货架有多个层 */
    layers!: LayerDto[] | undefined;
    /** 智能货架里绑定的其他一些设备，包括条形屏等 */
    childDevices!: ChildDeviceDto[] | undefined;

    constructor(data?: IShelfDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.isLocked = _data["isLocked"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.description = _data["description"];
            this.hardwareCode = _data["hardwareCode"];
            this.shutdownTime = _data["shutdownTime"] ? moment(_data["shutdownTime"].toString()) : <any>undefined;
            this.shelfDirectionAngle = _data["shelfDirectionAngle"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Width = _data["resolution_Width"];
            this.startPoint_Y = _data["startPoint_Y"];
            this.resolution_Height = _data["resolution_Height"];
            this.subKey = _data["subKey"];
            this.os = _data["os"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outType = _data["outType"];
            this.footerHeight = _data["footerHeight"];
            this.outerPartitionHeight = _data["outerPartitionHeight"];
            this.layerPartitionHeight = _data["layerPartitionHeight"];
            if (Array.isArray(_data["layers"])) {
                this.layers = [] as any;
                for (let item of _data["layers"])
                    this.layers!.push(LayerDto.fromJS(item));
            }
            if (Array.isArray(_data["childDevices"])) {
                this.childDevices = [] as any;
                for (let item of _data["childDevices"])
                    this.childDevices!.push(ChildDeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShelfDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["isLocked"] = this.isLocked;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["description"] = this.description;
        data["hardwareCode"] = this.hardwareCode;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toISOString() : <any>undefined;
        data["shelfDirectionAngle"] = this.shelfDirectionAngle;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Width"] = this.resolution_Width;
        data["startPoint_Y"] = this.startPoint_Y;
        data["resolution_Height"] = this.resolution_Height;
        data["subKey"] = this.subKey;
        data["os"] = this.os;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outType"] = this.outType;
        data["footerHeight"] = this.footerHeight;
        data["outerPartitionHeight"] = this.outerPartitionHeight;
        data["layerPartitionHeight"] = this.layerPartitionHeight;
        if (Array.isArray(this.layers)) {
            data["layers"] = [];
            for (let item of this.layers)
                data["layers"].push(item.toJSON());
        }
        if (Array.isArray(this.childDevices)) {
            data["childDevices"] = [];
            for (let item of this.childDevices)
                data["childDevices"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShelfDto {
    /** 设备Id */
    id: number | undefined;
    /** 设备名称 */
    name: string | undefined;
    /** 设备MAC地址 */
    mac: string | undefined;
    /** 设备是否锁定 */
    isLocked: boolean | undefined;
    /** 设备类型名称 */
    deviceTypeName: string | undefined;
    /** 设备地址 */
    address: string | undefined;
    /** 描述字段 */
    description: string | undefined;
    /** 硬件编码 */
    hardwareCode: string | undefined;
    /** 关机时间 */
    shutdownTime: moment.Moment | undefined;
    /** 以某一标准正方向设定的摆放角度 */
    shelfDirectionAngle: number | undefined;
    /** X方向长度 */
    resolution_Length: number | undefined;
    /** 以房间某个角落为起点，货架摆放位置离起点在X方向的距离 */
    startPoint_X: number | undefined;
    /** Y方向长度 */
    resolution_Width: number | undefined;
    /** 以房间某个角落为起点，货架摆放位置离起点在Y方向的距离 */
    startPoint_Y: number | undefined;
    /** Z方向长度 */
    resolution_Height: number | undefined;
    /** 设备Subkey */
    subKey: string | undefined;
    /** 设备系统 */
    os: string | undefined;
    /** 租户名称 */
    tenantName: string | undefined;
    /** 租户Id */
    tenantId: number | undefined;
    /** 组织机构名称 */
    organizationUnitName: string | undefined;
    /** 组织机构Id */
    organizationUnitId: number | undefined;
    outType: string | undefined;
    /** 设备垫高 */
    footerHeight: number | undefined;
    /** 隔板厚度 */
    outerPartitionHeight: number | undefined;
    /** 层板厚度 */
    layerPartitionHeight: number | undefined;
    /** 设备层,一个智能货架有多个层 */
    layers: LayerDto[] | undefined;
    /** 智能货架里绑定的其他一些设备，包括条形屏等 */
    childDevices: ChildDeviceDto[] | undefined;
}

export class LayerDto implements ILayerDto {
    /** 层Id */
    layerId!: number | undefined;
    /** 当前层的货道，一个层可以有多个货道 */
    cargoRoads!: ShelfCargoRoadDto[] | undefined;
    /** 当前层的层高，该设备的每个层的层高可以不一样 */
    layerHeight!: number | undefined;
    /** 当前层的起始高度 */
    startPoint_Z!: number | undefined;
    /** Layer编号，自下而上，从1累加 */
    index!: number | undefined;
    /** 当前层的货道数量 */
    cargoRoadCount!: number | undefined;

    constructor(data?: ILayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layerId = _data["layerId"];
            if (Array.isArray(_data["cargoRoads"])) {
                this.cargoRoads = [] as any;
                for (let item of _data["cargoRoads"])
                    this.cargoRoads!.push(ShelfCargoRoadDto.fromJS(item));
            }
            this.layerHeight = _data["layerHeight"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.index = _data["index"];
            this.cargoRoadCount = _data["cargoRoadCount"];
        }
    }

    static fromJS(data: any): LayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        if (Array.isArray(this.cargoRoads)) {
            data["cargoRoads"] = [];
            for (let item of this.cargoRoads)
                data["cargoRoads"].push(item.toJSON());
        }
        data["layerHeight"] = this.layerHeight;
        data["startPoint_Z"] = this.startPoint_Z;
        data["index"] = this.index;
        data["cargoRoadCount"] = this.cargoRoadCount;
        return data; 
    }
}

export interface ILayerDto {
    /** 层Id */
    layerId: number | undefined;
    /** 当前层的货道，一个层可以有多个货道 */
    cargoRoads: ShelfCargoRoadDto[] | undefined;
    /** 当前层的层高，该设备的每个层的层高可以不一样 */
    layerHeight: number | undefined;
    /** 当前层的起始高度 */
    startPoint_Z: number | undefined;
    /** Layer编号，自下而上，从1累加 */
    index: number | undefined;
    /** 当前层的货道数量 */
    cargoRoadCount: number | undefined;
}

export class ChildDeviceDto implements IChildDeviceDto {
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    thingId!: string | undefined;
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    type!: string | undefined;
    /** 如果一层安装多个条形屏，用ordernumber来确定安装顺序，从左到右依次递增 */
    orderNumber!: number | undefined;
    /** 绑定的设备信息 */
    device!: DeviceDto | undefined;

    constructor(data?: IChildDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.orderNumber = _data["orderNumber"];
            this.device = _data["device"] ? DeviceDto.fromJS(_data["device"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChildDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["orderNumber"] = this.orderNumber;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChildDeviceDto {
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    thingId: string | undefined;
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    type: string | undefined;
    /** 如果一层安装多个条形屏，用ordernumber来确定安装顺序，从左到右依次递增 */
    orderNumber: number | undefined;
    /** 绑定的设备信息 */
    device: DeviceDto | undefined;
}

export class ShelfCargoRoadDto implements IShelfCargoRoadDto {
    /** 货道Id */
    id!: number | undefined;
    /** 货道绑定的设备Id */
    deviceId!: number | undefined;
    /** 货道类型 0:Sequence 顺序掉 1:Random 随机掉 */
    cargoType!: ShelfCargoRoadDtoCargoType | undefined;
    /** 货道Id */
    cargoRoadId!: number | undefined;
    /** 货道的起始长度（货架左右有隔板） */
    startLength!: number | undefined;
    /** 绑定的传感器之类设备 */
    sensors!: SensorDto[] | undefined;
    /** 毛重 */
    grossWeight!: number | undefined;
    /** 货道名称，目前统一，系统生成 */
    name!: string | undefined;
    /** 货道编号，目前统一，系统生成 */
    outerId!: string | undefined;
    /** 货道是否启用 */
    isEnabled!: boolean | undefined;
    /** 库存容量 */
    stockCapacity!: number | undefined;
    /** 描述 */
    description!: string | undefined;
    /** 扩展字段 */
    extensionData!: string | undefined;
    /** 货道里的货物，若为顺序货道，仅有一条记录，若为随机货道，可能会有多条记录 */
    cargoThings!: CargoThingDto[] | undefined;
    /** 货道所处的层Id */
    layerId!: number | undefined;
    /** 货道长度 */
    resolution_Length!: number | undefined;
    /** 货道宽度 */
    resolution_Width!: number | undefined;
    /** 以货道当前层左下角为起始位置，货道位置离起点在X方向的距离 */
    startPoint_X!: number | undefined;
    /** 货道高度 */
    resolution_Height!: number | undefined;
    /** 以货道当前层左下角为起始位置，货道位置离起点在Z方向的距离 */
    startPoint_Z!: number | undefined;
    /** 跨行 */
    spanRows!: number | undefined;
    /** 跨列 */
    spanColumns!: number | undefined;

    constructor(data?: IShelfCargoRoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.cargoType = _data["cargoType"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.startLength = _data["startLength"];
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(SensorDto.fromJS(item));
            }
            this.grossWeight = _data["grossWeight"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CargoThingDto.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.resolution_Width = _data["resolution_Width"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
        }
    }

    static fromJS(data: any): ShelfCargoRoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfCargoRoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["cargoType"] = this.cargoType;
        data["cargoRoadId"] = this.cargoRoadId;
        data["startLength"] = this.startLength;
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item.toJSON());
        }
        data["grossWeight"] = this.grossWeight;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["resolution_Width"] = this.resolution_Width;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        return data; 
    }
}

export interface IShelfCargoRoadDto {
    /** 货道Id */
    id: number | undefined;
    /** 货道绑定的设备Id */
    deviceId: number | undefined;
    /** 货道类型 0:Sequence 顺序掉 1:Random 随机掉 */
    cargoType: ShelfCargoRoadDtoCargoType | undefined;
    /** 货道Id */
    cargoRoadId: number | undefined;
    /** 货道的起始长度（货架左右有隔板） */
    startLength: number | undefined;
    /** 绑定的传感器之类设备 */
    sensors: SensorDto[] | undefined;
    /** 毛重 */
    grossWeight: number | undefined;
    /** 货道名称，目前统一，系统生成 */
    name: string | undefined;
    /** 货道编号，目前统一，系统生成 */
    outerId: string | undefined;
    /** 货道是否启用 */
    isEnabled: boolean | undefined;
    /** 库存容量 */
    stockCapacity: number | undefined;
    /** 描述 */
    description: string | undefined;
    /** 扩展字段 */
    extensionData: string | undefined;
    /** 货道里的货物，若为顺序货道，仅有一条记录，若为随机货道，可能会有多条记录 */
    cargoThings: CargoThingDto[] | undefined;
    /** 货道所处的层Id */
    layerId: number | undefined;
    /** 货道长度 */
    resolution_Length: number | undefined;
    /** 货道宽度 */
    resolution_Width: number | undefined;
    /** 以货道当前层左下角为起始位置，货道位置离起点在X方向的距离 */
    startPoint_X: number | undefined;
    /** 货道高度 */
    resolution_Height: number | undefined;
    /** 以货道当前层左下角为起始位置，货道位置离起点在Z方向的距离 */
    startPoint_Z: number | undefined;
    /** 跨行 */
    spanRows: number | undefined;
    /** 跨列 */
    spanColumns: number | undefined;
}

export class DeviceDto implements IDeviceDto {
    id!: number | undefined;
    name!: string | undefined;
    mac!: string | undefined;
    isLocked!: boolean | undefined;
    deviceTypeName!: string | undefined;
    address!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    /** 设备是否已被注册，如果已注册，另外的机器不能再注册. 同时管理员可以清空，允许其它设备进行注册. */
    isRegistered!: boolean | undefined;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    shutdownTime!: moment.Moment | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    /** 访问此设备的唯一凭证，通过Subkey可调用平台api，拿到设备相关的信息，如,ads,apps,products等.同时可用户注册. */
    subKey!: string | undefined;
    os!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    tenantName!: string | undefined;
    tenantId!: number | undefined;
    organizationUnitName!: string | undefined;
    organizationUnitId!: number | undefined;
    outType!: string | undefined;
    taobaoDeviceId!: string | undefined;
    osType!: DeviceDtoOsType | undefined;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.isLocked = _data["isLocked"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.isRegistered = _data["isRegistered"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.shutdownTime = _data["shutdownTime"] ? moment(_data["shutdownTime"].toString()) : <any>undefined;
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.subKey = _data["subKey"];
            this.os = _data["os"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outType = _data["outType"];
            this.taobaoDeviceId = _data["taobaoDeviceId"];
            this.osType = _data["osType"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["isLocked"] = this.isLocked;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["isRegistered"] = this.isRegistered;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toISOString() : <any>undefined;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["subKey"] = this.subKey;
        data["os"] = this.os;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outType"] = this.outType;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["osType"] = this.osType;
        return data; 
    }
}

export interface IDeviceDto {
    id: number | undefined;
    name: string | undefined;
    mac: string | undefined;
    isLocked: boolean | undefined;
    deviceTypeName: string | undefined;
    address: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    /** 设备是否已被注册，如果已注册，另外的机器不能再注册. 同时管理员可以清空，允许其它设备进行注册. */
    isRegistered: boolean | undefined;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    shutdownTime: moment.Moment | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    /** 访问此设备的唯一凭证，通过Subkey可调用平台api，拿到设备相关的信息，如,ads,apps,products等.同时可用户注册. */
    subKey: string | undefined;
    os: string | undefined;
    onlineTrafficTarget: string | undefined;
    tenantName: string | undefined;
    tenantId: number | undefined;
    organizationUnitName: string | undefined;
    organizationUnitId: number | undefined;
    outType: string | undefined;
    taobaoDeviceId: string | undefined;
    osType: DeviceDtoOsType | undefined;
}

export class SensorDto implements ISensorDto {
    /** 传感器Id */
    id!: number | undefined;
    /** 传感器名称 */
    name!: string | undefined;

    constructor(data?: ISensorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SensorDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISensorDto {
    /** 传感器Id */
    id: number | undefined;
    /** 传感器名称 */
    name: string | undefined;
}

export class AddOrUpdateShelfInfoInput implements IAddOrUpdateShelfInfoInput {
    deviceId!: number | undefined;
    resolution_Length!: number | undefined;
    resolution_Width!: number | undefined;
    resolution_Height!: number | undefined;
    footerHeight!: number | undefined;
    outerPartitionHeight!: number | undefined;
    layerPartitionHeight!: number | undefined;
    shelfDirectionAngle!: number | undefined;
    startPoint_X!: number | undefined;
    startPoint_Y!: number | undefined;
    layers!: LayerInput[] | undefined;

    constructor(data?: IAddOrUpdateShelfInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.resolution_Length = _data["resolution_Length"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.footerHeight = _data["footerHeight"];
            this.outerPartitionHeight = _data["outerPartitionHeight"];
            this.layerPartitionHeight = _data["layerPartitionHeight"];
            this.shelfDirectionAngle = _data["shelfDirectionAngle"];
            this.startPoint_X = _data["startPoint_X"];
            this.startPoint_Y = _data["startPoint_Y"];
            if (Array.isArray(_data["layers"])) {
                this.layers = [] as any;
                for (let item of _data["layers"])
                    this.layers!.push(LayerInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateShelfInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateShelfInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["resolution_Length"] = this.resolution_Length;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["footerHeight"] = this.footerHeight;
        data["outerPartitionHeight"] = this.outerPartitionHeight;
        data["layerPartitionHeight"] = this.layerPartitionHeight;
        data["shelfDirectionAngle"] = this.shelfDirectionAngle;
        data["startPoint_X"] = this.startPoint_X;
        data["startPoint_Y"] = this.startPoint_Y;
        if (Array.isArray(this.layers)) {
            data["layers"] = [];
            for (let item of this.layers)
                data["layers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateShelfInfoInput {
    deviceId: number | undefined;
    resolution_Length: number | undefined;
    resolution_Width: number | undefined;
    resolution_Height: number | undefined;
    footerHeight: number | undefined;
    outerPartitionHeight: number | undefined;
    layerPartitionHeight: number | undefined;
    shelfDirectionAngle: number | undefined;
    startPoint_X: number | undefined;
    startPoint_Y: number | undefined;
    layers: LayerInput[] | undefined;
}

export class LayerInput implements ILayerInput {
    id!: number | undefined;
    cargoRoadCount!: number | undefined;
    layerHeight!: number | undefined;

    constructor(data?: ILayerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cargoRoadCount = _data["cargoRoadCount"];
            this.layerHeight = _data["layerHeight"];
        }
    }

    static fromJS(data: any): LayerInput {
        data = typeof data === 'object' ? data : {};
        let result = new LayerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cargoRoadCount"] = this.cargoRoadCount;
        data["layerHeight"] = this.layerHeight;
        return data; 
    }
}

export interface ILayerInput {
    id: number | undefined;
    cargoRoadCount: number | undefined;
    layerHeight: number | undefined;
}

export class AddOrUpdateCargoRoadByLayerIdInput implements IAddOrUpdateCargoRoadByLayerIdInput {
    /** 123 */
    layerId!: number | undefined;
    /** 123 */
    cargoRoadId!: number | undefined;

    constructor(data?: IAddOrUpdateCargoRoadByLayerIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layerId = _data["layerId"];
            this.cargoRoadId = _data["cargoRoadId"];
        }
    }

    static fromJS(data: any): AddOrUpdateCargoRoadByLayerIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateCargoRoadByLayerIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        data["cargoRoadId"] = this.cargoRoadId;
        return data; 
    }
}

export interface IAddOrUpdateCargoRoadByLayerIdInput {
    /** 123 */
    layerId: number | undefined;
    /** 123 */
    cargoRoadId: number | undefined;
}

export class ExchangeCargoRoadSkuInput implements IExchangeCargoRoadSkuInput {
    sourceCargoRoadId!: number | undefined;
    targetCargoRoadId!: number | undefined;

    constructor(data?: IExchangeCargoRoadSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceCargoRoadId = _data["sourceCargoRoadId"];
            this.targetCargoRoadId = _data["targetCargoRoadId"];
        }
    }

    static fromJS(data: any): ExchangeCargoRoadSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeCargoRoadSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCargoRoadId"] = this.sourceCargoRoadId;
        data["targetCargoRoadId"] = this.targetCargoRoadId;
        return data; 
    }
}

export interface IExchangeCargoRoadSkuInput {
    sourceCargoRoadId: number | undefined;
    targetCargoRoadId: number | undefined;
}

export class GetSingleShelfInput implements IGetSingleShelfInput {
    deviceId!: number | undefined;
    toDeviceIds!: number[] | undefined;

    constructor(data?: IGetSingleShelfInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["toDeviceIds"])) {
                this.toDeviceIds = [] as any;
                for (let item of _data["toDeviceIds"])
                    this.toDeviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetSingleShelfInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSingleShelfInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.toDeviceIds)) {
            data["toDeviceIds"] = [];
            for (let item of this.toDeviceIds)
                data["toDeviceIds"].push(item);
        }
        return data; 
    }
}

export interface IGetSingleShelfInput {
    deviceId: number | undefined;
    toDeviceIds: number[] | undefined;
}

export enum OsType {
    Windows = "Windows",
    Android = "Android",
}

export enum OsType2 {
    Windows = "Windows",
    Android = "Android",
}

export enum CargoRoadDtoCargoType {
    Sequence = "Sequence",
    Random = "Random",
}

export enum CargoThingDtoType {
    Product = "Product",
    Sku = "Sku",
    Award = "Award",
}

export enum CreateCargoRoadsInputCargoType {
    Sequence = "Sequence",
    Random = "Random",
}

export enum CreateCargoThingInputType {
    Product = "Product",
    Sku = "Sku",
    Award = "Award",
}

export enum UpdateCargoRoadsInputCargoType {
    Sequence = "Sequence",
    Random = "Random",
}

export enum AddOrUpdateGatewayInputGatewayType {
    Passive = "Passive",
    Active = "Active",
}

export enum GetGatewayOrSensorDtoDeviceType {
    Gateway = "Gateway",
    Sensor = "Sensor",
}

export enum GetGatewayOrSensorDtoGatewayType {
    Passive = "Passive",
    Active = "Active",
}

export enum GetAddressDtoGatewayType {
    Passive = "Passive",
    Active = "Active",
}

export enum SetDefaultAppPodVersionInputOsType {
    Windows = "Windows",
    Android = "Android",
}

export enum SwitchInfoStatus {
    Off = "Off",
    On = "On",
}

export enum OperateRecordSwitchStatus {
    Off = "Off",
    On = "On",
}

export enum OperateRecordControlType {
    Limit = "Limit",
    Timing = "Timing",
    Manual = "Manual",
    Reverse = "Reverse",
}

export enum WarnningRecordDtoHandlerStatus {
    UnHandled = "UnHandled",
    Handled = "Handled",
    Ignored = "Ignored",
    AutoRecover = "AutoRecover",
}

export enum DataRecordDtoDataStatus {
    Normal = "Normal",
    ExceedUpLimit = "ExceedUpLimit",
    ExceedDownLimit = "ExceedDownLimit",
    Error = "Error",
}

export enum AddOrUpdateReportTemplateInputCounterTagRules {
    Union = "Union",
    Intersection = "Intersection",
}

export enum AddOrUpdateReportTemplateInputDeviceTagRules {
    Union = "Union",
    Intersection = "Intersection",
}

export enum AddOrUpdateReportTemplateInputReportType {
    Line = "Line",
    Pie = "Pie",
    Bar = "Bar",
    Circle = "Circle",
    Radar = "Radar",
    Polar = "Polar",
    Digit = "Digit",
}

export enum AddOrUpdateReportTemplateInputReportCompareType {
    Day = "Day",
    Week = "Week",
    Month = "Month",
}

export enum GetReportTemplateDtoCounterTagRules {
    Union = "Union",
    Intersection = "Intersection",
}

export enum GetReportTemplateDtoDeviceTagRules {
    Union = "Union",
    Intersection = "Intersection",
}

export enum GetReportTemplateDtoReportType {
    Line = "Line",
    Pie = "Pie",
    Bar = "Bar",
    Circle = "Circle",
    Radar = "Radar",
    Polar = "Polar",
    Digit = "Digit",
}

export enum GetReportTemplateDtoReportCompareType {
    Day = "Day",
    Week = "Week",
    Month = "Month",
}

export enum AddOrUpdateReportInputReportDataType {
    Counter = "Counter",
}

export enum ReportDataInputCalculateType {
    Plus = "Plus",
    Reduce = "Reduce",
}

export enum GetReportDtoReportDataType {
    Counter = "Counter",
}

export enum GetReportDetailDtoReportDataType {
    Counter = "Counter",
}

export enum GetReportDataDtoCalculateType {
    Plus = "Plus",
    Reduce = "Reduce",
}

export enum TagType {
    Resource = "Resource",
    Device = "Device",
    Product = "Product",
    Ads = "Ads",
    Other = "Other",
    Brand = "Brand",
    Question = "Question",
    Counter = "Counter",
}

export enum ControlGatewayInputSwitchStatus {
    Off = "Off",
    On = "On",
}

export enum SimpleProductDtoType {
    Product = "Product",
    Sku = "Sku",
    Award = "Award",
}

export enum ShelfCargoRoadDtoCargoType {
    Sequence = "Sequence",
    Random = "Random",
}

export enum DeviceDtoOsType {
    Windows = "Windows",
    Android = "Android",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}