/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.3.0 (NJsonSchema v10.3.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_SMARTDEVICE_URL = new InjectionToken<string>('API_SMARTDEVICE_URL');

@Injectable()
export class AppPodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 获取AppPod列表信息，安卓、Windows
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAppPods(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AppPodDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPods?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPods(<any>response_);
                } catch (e) {
                    return <Observable<AppPodDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPods(response: HttpResponseBase): Observable<AppPodDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取所有AppPod版本信息
     * @param appPodId (optional) AppPodID
     * @param osType (optional) 设备系统类型
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAppPodVersions(appPodId: number | undefined, osType: OsTypeEnum | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<AppPodVersionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodVersions?";
        if (appPodId === null)
            throw new Error("The parameter 'appPodId' cannot be null.");
        else if (appPodId !== undefined)
            url_ += "AppPodId=" + encodeURIComponent("" + appPodId) + "&";
        if (osType === null)
            throw new Error("The parameter 'osType' cannot be null.");
        else if (osType !== undefined)
            url_ += "OsType=" + encodeURIComponent("" + osType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodVersions(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersionDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersionDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodVersions(response: HttpResponseBase): Observable<AppPodVersionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersionDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取AppPod版本详细信息
     * @param id (optional) AppPodVersionId
     * @return Success
     */
    getAppPodVersionDetail(id: number | undefined): Observable<AppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodVersionDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodVersionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodVersionDetail(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodVersionDetail(response: HttpResponseBase): Observable<AppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersionDto>(<any>null);
    }

    /**
     * 获取某个产品的最新版本信息
     * @param appPodId (optional) 
     * @return Success
     */
    getAppPodLatestVersionDetail(appPodId: number | undefined): Observable<AppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetAppPodLatestVersionDetail?";
        if (appPodId === null)
            throw new Error("The parameter 'appPodId' cannot be null.");
        else if (appPodId !== undefined)
            url_ += "appPodId=" + encodeURIComponent("" + appPodId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppPodLatestVersionDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppPodLatestVersionDetail(<any>response_);
                } catch (e) {
                    return <Observable<AppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppPodLatestVersionDetail(response: HttpResponseBase): Observable<AppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppPodVersionDto>(<any>null);
    }

    /**
     * 创建Apppod version
     * @param body (optional) 
     * @return Success
     */
    createAppPodVersion(body: CreateAppPodVersionInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/CreateAppPodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppPodVersion(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 更新appPod
     * @param body (optional) 
     * @return Success
     */
    updateAppPodVersion(body: UpdateAppPodVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/UpdateAppPodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppPodVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新建设备后，调用接口绑定最新版本
     * @param body (optional) 
     * @return Success
     */
    setDefaultAppPodVersion4Device(body: SetDefaultAppPodVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/SetDefaultAppPodVersion4Device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultAppPodVersion4Device(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultAppPodVersion4Device(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultAppPodVersion4Device(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取指定设备下的当前appPod版本信息
     * @param deviceId (optional) 设备ID
     * @param osType 设备系统类型
     * @return Success
     */
    getDeviceAppPodVersion(deviceId: number | undefined, osType: OsTypeEnum): Observable<DeviceAppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetDeviceAppPodVersion?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (osType === undefined || osType === null)
            throw new Error("The parameter 'osType' must be defined and cannot be null.");
        else
            url_ += "OsType=" + encodeURIComponent("" + osType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceAppPodVersion(response: HttpResponseBase): Observable<DeviceAppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceAppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAppPodVersionDto>(<any>null);
    }

    /**
     * 修改设备AppPod版本
     * @param body (optional) 
     * @return Success
     */
    changeDeviceApppodVersion(body: ChangeDeviceAppPodVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/ChangeDeviceApppodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDeviceApppodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDeviceApppodVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeDeviceApppodVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备截屏图片url
     * @param deviceId 目标设备ID
     * @return Success
     */
    getDeviceScreenshot(deviceId: number): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AppPod/GetDeviceScreenshot?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceScreenshot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceScreenshot(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceScreenshot(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CounterDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 创建子设备和主设备之间的关联关系，如网关与客流分析设备绑定关系
     * @param body (optional) 
     * @return Success
     */
    bindChildDevicesToGateway(body: BindChildDevicesToGatewayInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/BindChildDevicesToGateway";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindChildDevicesToGateway(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindChildDevicesToGateway(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindChildDevicesToGateway(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过传感器或客流摄像头设备号获取绑定的网关设备
     * @param childDeviceId (optional) 传感器或客流摄像头设备编号
     * @return Success
     */
    getGatewayByChildDeviceId(childDeviceId: number | undefined): Observable<GetGatewayInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetGatewayByChildDeviceId?";
        if (childDeviceId === null)
            throw new Error("The parameter 'childDeviceId' cannot be null.");
        else if (childDeviceId !== undefined)
            url_ += "childDeviceId=" + encodeURIComponent("" + childDeviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatewayByChildDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatewayByChildDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<GetGatewayInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGatewayInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatewayByChildDeviceId(response: HttpResponseBase): Observable<GetGatewayInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGatewayInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGatewayInfoDto>(<any>null);
    }

    /**
     * 批量删除设备后解除全部绑定关系
     * @param body (optional) 被删除的主设备或子设备ID数组
     * @return Success
     */
    cancelBindAfterDeletingDevices(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/CancelBindAfterDeletingDevices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelBindAfterDeletingDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelBindAfterDeletingDevices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelBindAfterDeletingDevices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据网关查询客流设备信息
     * @param gatewayId (optional) 网关ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getChildDevicesByGatewayId(gatewayId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetChildDevicesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetChildDevicesByGatewayId?";
        if (gatewayId === null)
            throw new Error("The parameter 'gatewayId' cannot be null.");
        else if (gatewayId !== undefined)
            url_ += "GatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChildDevicesByGatewayId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChildDevicesByGatewayId(<any>response_);
                } catch (e) {
                    return <Observable<GetChildDevicesDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetChildDevicesDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChildDevicesByGatewayId(response: HttpResponseBase): Observable<GetChildDevicesDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetChildDevicesDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetChildDevicesDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建设备计数器
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateDeviceCounters(body: CreateCounterInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/AddOrUpdateDeviceCounters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateDeviceCounters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateDeviceCounters(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateDeviceCounters(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备计数器详情
     * @param deviceCounterId (optional) 设备计数器ID
     * @return Success
     */
    getDeviceCounterDetails(deviceCounterId: number | undefined): Observable<GetCounerInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetDeviceCounterDetails?";
        if (deviceCounterId === null)
            throw new Error("The parameter 'deviceCounterId' cannot be null.");
        else if (deviceCounterId !== undefined)
            url_ += "deviceCounterId=" + encodeURIComponent("" + deviceCounterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetCounerInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCounerInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterDetails(response: HttpResponseBase): Observable<GetCounerInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCounerInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCounerInfoDto>(<any>null);
    }

    /**
     * 删除设备计数器
     * @param deviceCounterId (optional) 设备计数器ID
     * @return Success
     */
    deleteDeviceCounter(deviceCounterId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/DeleteDeviceCounter?";
        if (deviceCounterId === null)
            throw new Error("The parameter 'deviceCounterId' cannot be null.");
        else if (deviceCounterId !== undefined)
            url_ += "deviceCounterId=" + encodeURIComponent("" + deviceCounterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceCounter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceCounter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceCounter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询设备计数器
     * @param id (optional) 传感器或客流摄像头设备ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceCountersByDeviceId(id: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetDeviceCounterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetDeviceCountersByDeviceId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCountersByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCountersByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCountersByDeviceId(response: HttpResponseBase): Observable<GetDeviceCounterDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDeviceCounterDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterDtoPagedResultDto>(<any>null);
    }

    /**
     * 写入计数流水
     * @param body (optional) 
     * @return Success
     */
    createDeviceCounterRecords(body: CreateDeviceCounterRecordInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/CreateDeviceCounterRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceCounterRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceCounterRecords(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceCounterRecords(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 写入计数器标签
     * @param body (optional) 
     * @return Success
     */
    bindTagsToDeviceCounter(body: BindTagsToDeviceCounterInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/BindTagsToDeviceCounter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBindTagsToDeviceCounter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBindTagsToDeviceCounter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBindTagsToDeviceCounter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询计数器标签
     * @param counterId (optional) 计数器编号
     * @return Success
     */
    getDeviceCounterTags(counterId: number | undefined): Observable<GetDeviceCounterTagInfoDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetDeviceCounterTags?";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "counterId=" + encodeURIComponent("" + counterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterTags(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterTagInfoDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterTagInfoDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterTags(response: HttpResponseBase): Observable<GetDeviceCounterTagInfoDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterTagInfoDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterTagInfoDto[]>(<any>null);
    }

    /**
     * 绑定计数器标签
     * @param body (optional) 
     * @return Success
     */
    updateDeviceCounterTags(body: UpdateDeviceCounterTagInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/UpdateDeviceCounterTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceCounterTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceCounterTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDeviceCounterTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新增或者更新网关的轮询信息
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateGatewayInfo(body: AddOrUpdateGatewayInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/AddOrUpdateGatewayInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateGatewayInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateGatewayInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateGatewayInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新增或者更新传感器的轮询信息
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateSensorInfo(body: AddOrUpdateSensorInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/AddOrUpdateSensorInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateSensorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateSensorInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateSensorInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取网关或传感器设备额外信息
     * @param deviceId (optional) 传感器或网关设备ID
     * @return Success
     */
    getGatewayOrSensorInfo(deviceId: number | undefined): Observable<GetGatewayOrSensorDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetGatewayOrSensorInfo?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGatewayOrSensorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGatewayOrSensorInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetGatewayOrSensorDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGatewayOrSensorDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGatewayOrSensorInfo(response: HttpResponseBase): Observable<GetGatewayOrSensorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGatewayOrSensorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGatewayOrSensorDto>(<any>null);
    }

    /**
     * 获取网关下面下一个传感器485地址ID
     * @param gatewayId (optional) 
     * @return Success
     */
    getNextSensorAddress(gatewayId: number | undefined): Observable<GetSensorAddressDto> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetNextSensorAddress?";
        if (gatewayId === null)
            throw new Error("The parameter 'gatewayId' cannot be null.");
        else if (gatewayId !== undefined)
            url_ += "gatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextSensorAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextSensorAddress(<any>response_);
                } catch (e) {
                    return <Observable<GetSensorAddressDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSensorAddressDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextSensorAddress(response: HttpResponseBase): Observable<GetSensorAddressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSensorAddressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSensorAddressDto>(<any>null);
    }

    /**
     * 验证传感器485地址是否冲突
     * @param gatewayId (optional) 
     * @param address (optional) 
     * @return Success
     */
    verifySensorAddress(gatewayId: number | undefined, address: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/VerifySensorAddress?";
        if (gatewayId === null)
            throw new Error("The parameter 'gatewayId' cannot be null.");
        else if (gatewayId !== undefined)
            url_ += "GatewayId=" + encodeURIComponent("" + gatewayId) + "&";
        if (address === null)
            throw new Error("The parameter 'address' cannot be null.");
        else if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySensorAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySensorAddress(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySensorAddress(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * 创建计数器分组
     * @param body (optional) 
     * @return Success
     */
    createDeviceCounterGroup(body: CreateDeviceCounterGroupInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/CreateDeviceCounterGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeviceCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeviceCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDeviceCounterGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 查询计数器分组
     * @param storeId (optional) 门店编号
     * @param creationStart (optional) 时间区间开始
     * @param creationEnd (optional) 时间区间结束
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDeviceCounterGroup(storeId: number | undefined, creationStart: moment.Moment | undefined, creationEnd: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetDeviceCounterGroupDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/GetDeviceCounterGroup?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (creationStart === null)
            throw new Error("The parameter 'creationStart' cannot be null.");
        else if (creationStart !== undefined)
            url_ += "CreationStart=" + encodeURIComponent(creationStart ? "" + creationStart.toJSON() : "") + "&";
        if (creationEnd === null)
            throw new Error("The parameter 'creationEnd' cannot be null.");
        else if (creationEnd !== undefined)
            url_ += "CreationEnd=" + encodeURIComponent(creationEnd ? "" + creationEnd.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterGroupDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterGroupDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterGroup(response: HttpResponseBase): Observable<GetDeviceCounterGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterGroupDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterGroupDto[]>(<any>null);
    }

    /**
     * 删除计数器分组
     * @param id (optional) 分组编号
     * @param storeId (optional) 门店编号
     * @return Success
     */
    deleteDeviceCounterGroup(id: number | undefined, storeId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CounterDevice/DeleteDeviceCounterGroup?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeviceCounterGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeviceCounterGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDeviceCounterGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CounterReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 统计计数
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 计数器ID
     * @param deviceId (optional) 传感器或客流摄像头设备ID
     * @return Success
     */
    getDeviceCounterChartByDeviceIds(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, counterId: number | undefined, deviceId: number[] | undefined): Observable<GetDeviceCounterChartDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterReport/GetDeviceCounterChartByDeviceIds?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterChartByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterChartByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterChartByDeviceIds(response: HttpResponseBase): Observable<GetDeviceCounterChartDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterChartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterChartDto[]>(<any>null);
    }

    /**
     * 数字报表
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 计数器ID
     * @param deviceId (optional) 传感器或客流摄像头设备ID
     * @return Success
     */
    getDigitDeviceCounterChartByDeviceIds(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, counterId: number | undefined, deviceId: number[] | undefined): Observable<GetDeviceCounterChartDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CounterReport/GetDigitDeviceCounterChartByDeviceIds?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDigitDeviceCounterChartByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDigitDeviceCounterChartByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDigitDeviceCounterChartByDeviceIds(response: HttpResponseBase): Observable<GetDeviceCounterChartDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterChartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterChartDto[]>(<any>null);
    }

    /**
     * 导出计数器数字报表到Excel
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 计数器ID
     * @param deviceId (optional) 传感器或客流摄像头设备ID
     * @return Success
     */
    getDigitDeviceCounterChartDataToExcel(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, counterId: number | undefined, deviceId: number[] | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CounterReport/GetDigitDeviceCounterChartDataToExcel?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDigitDeviceCounterChartDataToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDigitDeviceCounterChartDataToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDigitDeviceCounterChartDataToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 导出计数器报表数据信息到Excel
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param type (optional) 年，月，日 周
     * @param counterId (optional) 计数器ID
     * @param deviceId (optional) 传感器或客流摄像头设备ID
     * @return Success
     */
    getDeviceCounterChartDataToExcel(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, counterId: number | undefined, deviceId: number[] | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CounterReport/GetDeviceCounterChartDataToExcel?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "CounterId=" + encodeURIComponent("" + counterId) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            deviceId && deviceId.forEach(item => { url_ += "DeviceId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceCounterChartDataToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceCounterChartDataToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceCounterChartDataToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CustomizeReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 添加或者修改客流摄像头数据报表模板
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateReportTemplate(body: AddOrUpdateReportTemplateInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/AddOrUpdateReportTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateReportTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateReportTemplate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateReportTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 获取客流摄像头数据报表模板列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getReportTemplates(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetReportTemplateDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetReportTemplates?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportTemplates(<any>response_);
                } catch (e) {
                    return <Observable<GetReportTemplateDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportTemplateDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportTemplates(response: HttpResponseBase): Observable<GetReportTemplateDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportTemplateDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportTemplateDtoPagedResultDto>(<any>null);
    }

    /**
     * 通过ID数组删除客流摄像头数据报表模板
     * @param ids (optional) 报表模板Id
     * @return Success
     */
    deleteReportTemplateByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/DeleteReportTemplateByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReportTemplateByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportTemplateByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReportTemplateByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 基于数据报表模板，添加或修改客流摄像头数据报表
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateReport(body: AddOrUpdateReportInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/AddOrUpdateReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取已创建的客流摄像头报表列表
     * @param tenantId (optional) 租户ID
     * @param reportTemplateId (optional) 报表模板ID
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getReports(tenantId: number | undefined, reportTemplateId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetReportDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetReports?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (reportTemplateId === null)
            throw new Error("The parameter 'reportTemplateId' cannot be null.");
        else if (reportTemplateId !== undefined)
            url_ += "ReportTemplateId=" + encodeURIComponent("" + reportTemplateId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReports(<any>response_);
                } catch (e) {
                    return <Observable<GetReportDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReports(response: HttpResponseBase): Observable<GetReportDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportDtoPagedResultDto>(<any>null);
    }

    /**
     * 通过报表ID数组删除报表
     * @param ids (optional) 通过报表ID删除报表
     * @return Success
     */
    deleteReportByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/DeleteReportByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReportByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReportByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过报表ID获取报表详细设置内容，内容不含数据统计值
     * @param id (optional) 
     * @return Success
     */
    getReportDetailById(id: number | undefined): Observable<GetReportDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetReportDetailById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportDetailById(<any>response_);
                } catch (e) {
                    return <Observable<GetReportDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportDetailById(response: HttpResponseBase): Observable<GetReportDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetReportDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportDetailDto>(<any>null);
    }

    /**
     * 通过客流摄像头设备ID获取计数器标签列表
     * @param deviceIds (optional) 
     * @return Success
     */
    getCounterTagsByDeviceIds(deviceIds: number[] | undefined): Observable<Tag[]> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetCounterTagsByDeviceIds?";
        if (deviceIds === null)
            throw new Error("The parameter 'deviceIds' cannot be null.");
        else if (deviceIds !== undefined)
            deviceIds && deviceIds.forEach(item => { url_ += "deviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCounterTagsByDeviceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCounterTagsByDeviceIds(<any>response_);
                } catch (e) {
                    return <Observable<Tag[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Tag[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCounterTagsByDeviceIds(response: HttpResponseBase): Observable<Tag[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Tag.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Tag[]>(<any>null);
    }

    /**
     * 通过指定的报表ID、时间段和报表显示方式（年报/月报/日报），向报表中填充具体数据
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 报表ID
     * @return Success
     */
    getReport(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, reportId: number | undefined): Observable<GetDeviceCounterChartDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetReport?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReport(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetReport(response: HttpResponseBase): Observable<GetDeviceCounterChartDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterChartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterChartDto[]>(<any>null);
    }

    /**
     * 将带具体数据的报表内容导出到excel
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 报表ID
     * @return Success
     */
    getReportToExcel(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, reportId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetReportToExcel?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取报表中客户数量数据内容
     * @param type (optional) 年，月，日 周
     * @param reportId (optional) 报表ID
     * @return Success
     */
    getGuestCount(startTime: moment.Moment, endTime: moment.Moment, type: string | undefined, reportId: number | undefined): Observable<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/services/app/CustomizeReport/GetGuestCount?";
        if (startTime === undefined || startTime === null)
            throw new Error("The parameter 'startTime' must be defined and cannot be null.");
        else
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === undefined || endTime === null)
            throw new Error("The parameter 'endTime' must be defined and cannot be null.");
        else
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (reportId === null)
            throw new Error("The parameter 'reportId' cannot be null.");
        else if (reportId !== undefined)
            url_ += "ReportId=" + encodeURIComponent("" + reportId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuestCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuestCount(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string]: number; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string]: number; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetGuestCount(response: HttpResponseBase): Observable<{ [key: string]: number; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string]: number; }>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAbpClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetAbpClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAbpClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAbpClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAbpClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getCacheString(key: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetCacheString?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCacheString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCacheString(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCacheString(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @param value (optional) 
     * @return Success
     */
    setCacheString(key: string | undefined, value: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/Identity/SetCacheString?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCacheString(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCacheString(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetCacheString(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ImportCargoRoadsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 通过Excel导入方式创建货架的货道，包括货道中的商品信息
     * @param deviceId (optional) 
     * @param inputFile (optional) 
     * @return Success
     */
    postCargoRoadsImportFile(deviceId: number | undefined, inputFile: FileParameter | undefined): Observable<string> {
        let url_ = this.baseUrl + "/ImportCargoRoads/PostCargoRoadsImportFile?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputFile === null || inputFile === undefined)
            throw new Error("The parameter 'inputFile' cannot be null.");
        else
            content_.append("InputFile", inputFile.data, inputFile.fileName ? inputFile.fileName : "InputFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostCargoRoadsImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCargoRoadsImportFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPostCargoRoadsImportFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 根据subkey获取所有货道
     * @param subkey 设备识别号
     * @param isEnabled (optional) 货道启用状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoRoads(subkey: string, isEnabled: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CargoRoadDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoRoads?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (isEnabled === null)
            throw new Error("The parameter 'isEnabled' cannot be null.");
        else if (isEnabled !== undefined)
            url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoads(<any>response_);
                } catch (e) {
                    return <Observable<CargoRoadDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoRoadDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoads(response: HttpResponseBase): Observable<CargoRoadDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoRoadDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoRoadDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取货道奖品信息
     * @param subkey (optional) 
     * @return Success
     */
    getCargoRoadsAwards(subkey: string | undefined): Observable<IdOuterIdValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoRoadsAwards?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadsAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadsAwards(<any>response_);
                } catch (e) {
                    return <Observable<IdOuterIdValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdOuterIdValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadsAwards(response: HttpResponseBase): Observable<IdOuterIdValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdOuterIdValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdOuterIdValueDto[]>(<any>null);
    }

    /**
     * 获取客户列表
     * @param tenantId (optional) 租户编号
     * @param startTime (optional) 开始时间
     * @param endTime (optional) 结束时间
     * @param type (optional) 报表类型mm,dd,hh
     * @return Success
     */
    getGuestChart(tenantId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, type: string | undefined): Observable<GetGuestChartDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetGuestChart?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGuestChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGuestChart(<any>response_);
                } catch (e) {
                    return <Observable<GetGuestChartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGuestChartDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGuestChart(response: HttpResponseBase): Observable<GetGuestChartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGuestChartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGuestChartDto>(<any>null);
    }

    /**
     * 根据subkey获取所有货道历史纪录
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoHisotory(subkey: string, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CargoHistoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoHisotory?";
        if (subkey === undefined || subkey === null)
            throw new Error("The parameter 'subkey' must be defined and cannot be null.");
        else
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoHisotory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoHisotory(<any>response_);
                } catch (e) {
                    return <Observable<CargoHistoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoHistoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoHisotory(response: HttpResponseBase): Observable<CargoHistoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoHistoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoHistoryDtoPagedResultDto>(<any>null);
    }

    /**
     * 派样机掉货接口，删除一个库存
     * @param body (optional) 
     * @return Success
     */
    dropCargo(body: DropCargoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DropCargo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCargo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCargo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCargo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 补货
     * @param body (optional) 
     * @return Success
     */
    updateCargoStock(body: UpdateCargoStockInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UpdateCargoStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 派样机掉多件货，删除多个库存
     * @param body (optional) 
     * @return Success
     */
    dropCargos(body: MutipleDropCargoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/DropCargos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDropCargos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDropCargos(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDropCargos(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 线下升级完成后，需要更新当前机器版本信息
     * @param body (optional) 
     * @return Success
     */
    changeDeviceApppodVersion(body: ChangeDeviceAppPodVersionInputWidtSubkey | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/ChangeDeviceApppodVersion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDeviceApppodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDeviceApppodVersion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeDeviceApppodVersion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取设备下的appPod版本信息
     * @param subkey (optional) 
     * @return Success
     */
    getDeviceAppPodVersion(subkey: string | undefined): Observable<DeviceAppPodVersionDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDeviceAppPodVersion?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceAppPodVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceAppPodVersion(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAppPodVersionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceAppPodVersion(response: HttpResponseBase): Observable<DeviceAppPodVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceAppPodVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAppPodVersionDto>(<any>null);
    }

    /**
     * 更新截屏信息
     * @param body (optional) 
     * @return Success
     */
    uploadScreenShot(subKey: string, body: AppPodScreenInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/UploadScreenShot?";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadScreenShot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadScreenShot(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadScreenShot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建计数器
     * @param body (optional) 
     * @return Success
     */
    createChildDeviceAndCountersByDevice(body: CreateChildDeviceAndCountersDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/CreateChildDeviceAndCountersByDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateChildDeviceAndCountersByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateChildDeviceAndCountersByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateChildDeviceAndCountersByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 写入计数流水，客流摄像头专用
     * @param body (optional) 
     * @return Success
     */
    postCounterRecordsByDevice(body: DeviceCounterRecords | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/PostCounterRecordsByDevice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostCounterRecordsByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCounterRecordsByDevice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostCounterRecordsByDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取智能货架下的商品信息
     * @param subKey (optional) 
     * @return Success
     */
    getShelfProducts(subKey: string | undefined): Observable<SimpleProductDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetShelfProducts?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShelfProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShelfProducts(<any>response_);
                } catch (e) {
                    return <Observable<SimpleProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShelfProducts(response: HttpResponseBase): Observable<SimpleProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleProductDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleProductDto[]>(<any>null);
    }

    /**
     * 线下获取智能云货架信息API
    若Subkey为智能云货架设备，返回仅有该智能货架的集合;
     * @param subKey (optional) 设备唯一标识Key
     * @return Success
     */
    getShelfInfo(subKey: string | undefined): Observable<ShelfDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetShelfInfo?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShelfInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShelfInfo(<any>response_);
                } catch (e) {
                    return <Observable<ShelfDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShelfDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetShelfInfo(response: HttpResponseBase): Observable<ShelfDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelfDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShelfDto>(<any>null);
    }

    /**
     * 线下获取智能云货架信息API
    若Subkey为其他设备类型，返回所有智能货架集合
     * @param subKey (optional) 设备唯一标识Key
     * @return Success
     */
    getShelfInfosInStore(subKey: string | undefined): Observable<ShelfDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetShelfInfosInStore?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShelfInfosInStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShelfInfosInStore(<any>response_);
                } catch (e) {
                    return <Observable<ShelfDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShelfDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShelfInfosInStore(response: HttpResponseBase): Observable<ShelfDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShelfDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShelfDto[]>(<any>null);
    }

    /**
     * 获取实时数据报表，办公室工业数据展示屏定制接口，无通用性
     * @param subkey (optional) 报表展示屏设备识别号
     * @return Success
     */
    getCurentDataReport(subkey: string | undefined): Observable<IndustryCurentDataReportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCurentDataReport?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurentDataReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurentDataReport(<any>response_);
                } catch (e) {
                    return <Observable<IndustryCurentDataReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustryCurentDataReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurentDataReport(response: HttpResponseBase): Observable<IndustryCurentDataReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndustryCurentDataReportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustryCurentDataReportDto[]>(<any>null);
    }

    /**
     * 获取历史数据报表
     * @param subkey (optional) 显示屏设备识别号
     * @param counterId (optional) 传感器数据ID
     * @return Success
     */
    getHistoryDataReport(subkey: string | undefined, counterId: number | undefined): Observable<GetDeviceCounterChartDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetHistoryDataReport?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        if (counterId === null)
            throw new Error("The parameter 'counterId' cannot be null.");
        else if (counterId !== undefined)
            url_ += "counterId=" + encodeURIComponent("" + counterId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryDataReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryDataReport(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceCounterChartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHistoryDataReport(response: HttpResponseBase): Observable<GetDeviceCounterChartDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetDeviceCounterChartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceCounterChartDto[]>(<any>null);
    }

    /**
     * 获取所有控制开关状态
     * @param subkey (optional) 显示屏设备识别号
     * @return Success
     */
    getSwitchStatus(subkey: string | undefined): Observable<GetSwitchStatusDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetSwitchStatus?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSwitchStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSwitchStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetSwitchStatusDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSwitchStatusDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSwitchStatus(response: HttpResponseBase): Observable<GetSwitchStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSwitchStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSwitchStatusDto>(<any>null);
    }

    /**
     * 获取报警信息列表
     * @param subkey (optional) 显示屏设备识别号
     * @return Success
     */
    getWarnningRecords(subkey: string | undefined): Observable<GetWarnningRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetWarnningRecords?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarnningRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarnningRecords(<any>response_);
                } catch (e) {
                    return <Observable<GetWarnningRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarnningRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarnningRecords(response: HttpResponseBase): Observable<GetWarnningRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWarnningRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarnningRecordDto>(<any>null);
    }

    /**
     * 获取数据采集记录
     * @param subkey (optional) 显示屏设备识别号
     * @return Success
     */
    getDataRecord(subkey: string | undefined): Observable<GetDatasDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDataRecord?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataRecord(<any>response_);
                } catch (e) {
                    return <Observable<GetDatasDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDatasDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataRecord(response: HttpResponseBase): Observable<GetDatasDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDatasDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDatasDto>(<any>null);
    }

    /**
     * 按顺序调货接口
     * @param subkey (optional) 
     * @param awardId (optional) 
     * @return Success
     */
    getCargoRoadByAwardIdInDevice(subkey: string | undefined, awardId: number | undefined): Observable<IdOuterIdValueDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoRoadByAwardIdInDevice?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "subkey=" + encodeURIComponent("" + subkey) + "&";
        if (awardId === null)
            throw new Error("The parameter 'awardId' cannot be null.");
        else if (awardId !== undefined)
            url_ += "awardId=" + encodeURIComponent("" + awardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadByAwardIdInDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadByAwardIdInDevice(<any>response_);
                } catch (e) {
                    return <Observable<IdOuterIdValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdOuterIdValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadByAwardIdInDevice(response: HttpResponseBase): Observable<IdOuterIdValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdOuterIdValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdOuterIdValueDto>(<any>null);
    }
}

@Injectable()
export class SensorAgreementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 上传传感器协议文件
     * @param body (optional) 
     * @return Success
     */
    postSensorAgreementFile(postFile: FileParameter, body: PostAgreementFileInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SensorAgreement/PostSensorAgreementFile?";
        if (postFile === undefined || postFile === null)
            throw new Error("The parameter 'postFile' must be defined and cannot be null.");
        else
            url_ += "PostFile=" + encodeURIComponent("" + postFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostSensorAgreementFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostSensorAgreementFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostSensorAgreementFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过传感器协议ID获取协议内容
     * @param id (optional) 
     * @return Success
     */
    getAgreementById(id: number | undefined): Observable<GetAgreementFileDto> {
        let url_ = this.baseUrl + "/api/SensorAgreement/GetAgreementById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreementById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreementById(<any>response_);
                } catch (e) {
                    return <Observable<GetAgreementFileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgreementFileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreementById(response: HttpResponseBase): Observable<GetAgreementFileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgreementFileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgreementFileDto>(<any>null);
    }

    /**
     * 获取传感器协议简易列表，用于下拉框展示
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAgreements(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetAgreementsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/SensorAgreement/GetAgreements?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreements(<any>response_);
                } catch (e) {
                    return <Observable<GetAgreementsDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgreementsDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreements(response: HttpResponseBase): Observable<GetAgreementsDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgreementsDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgreementsDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取传感器协议详细列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAgreementList(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceAgreementPagedResultDto> {
        let url_ = this.baseUrl + "/api/SensorAgreement/GetAgreementList?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgreementList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgreementList(<any>response_);
                } catch (e) {
                    return <Observable<DeviceAgreementPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceAgreementPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgreementList(response: HttpResponseBase): Observable<DeviceAgreementPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceAgreementPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceAgreementPagedResultDto>(<any>null);
    }

    /**
     * 通过ID数组删除传感器协议
     * @param ids (optional) 
     * @return Success
     */
    deleteAgreementByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/SensorAgreement/DeleteAgreementByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAgreementByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAgreementByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAgreementByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ShelfDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * 添加或修改智能货架信息，可指定货架的外观相关信息以及货架的层、货道等管理，指定货架共包含多少层，每层多少个货道
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateShelfInfo(body: AddOrUpdateShelfInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/AddOrUpdateShelfInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateShelfInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateShelfInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateShelfInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取单个货架信息
     * @param deviceId (optional) 货架设备ID
     * @return Success
     */
    getSingleShelf(deviceId: number | undefined): Observable<ShelfDto> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/GetSingleShelf?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleShelf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleShelf(<any>response_);
                } catch (e) {
                    return <Observable<ShelfDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShelfDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleShelf(response: HttpResponseBase): Observable<ShelfDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShelfDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShelfDto>(<any>null);
    }

    /**
     * 添加或删除某层货道
     * @param body (optional) 
     * @return Success
     */
    addOrDeleteCargoRoadByLayerId(body: AddOrDeleteCargoRoadByLayerIdInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/AddOrDeleteCargoRoadByLayerId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrDeleteCargoRoadByLayerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrDeleteCargoRoadByLayerId(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrDeleteCargoRoadByLayerId(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 交换货道商品
     * @param body (optional) 
     * @return Success
     */
    exchangeCargoRoadSku(body: ExchangeCargoRoadSkuInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/ExchangeCargoRoadSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExchangeCargoRoadSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExchangeCargoRoadSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExchangeCargoRoadSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过货架设备ID分页获取所有货道信息
     * @param deviceId 设备ID
     * @param isEnabled (optional) 启用状态
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCargoRoadsByDevice(deviceId: number, isEnabled: boolean | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CargoRoadDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/GetCargoRoadsByDevice?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (isEnabled === null)
            throw new Error("The parameter 'isEnabled' cannot be null.");
        else if (isEnabled !== undefined)
            url_ += "IsEnabled=" + encodeURIComponent("" + isEnabled) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadsByDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadsByDevice(<any>response_);
                } catch (e) {
                    return <Observable<CargoRoadDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoRoadDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadsByDevice(response: HttpResponseBase): Observable<CargoRoadDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoRoadDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoRoadDtoPagedResultDto>(<any>null);
    }

    /**
     * 通过货道ID获取货道详细信息
     * @param id (optional) 货道ID
     * @return Success
     */
    getCargoRoadById(id: number | undefined): Observable<CargoRoadDto> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/GetCargoRoadById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoRoadById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoRoadById(<any>response_);
                } catch (e) {
                    return <Observable<CargoRoadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoRoadDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoRoadById(response: HttpResponseBase): Observable<CargoRoadDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoRoadDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoRoadDto>(<any>null);
    }

    /**
     * 创建货道
     * @param body (optional) 创建货道所需的输入信息实体
     * @return Success
     */
    createCargoRoad(body: CreateCargoRoadsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/CreateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新货道状态
     * @param body (optional) 
     * @return Success
     */
    updateCargoRoadStatus(body: UpdateCargoStatusInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/UpdateCargoRoadStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoRoadStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoRoadStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoRoadStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或更新货道
     * @param body (optional) 添加更新货道
     * @return Success
     */
    addOrUpdateCargoRoad(body: AddOrUpdateCargoRoadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/AddOrUpdateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新货道
     * @param body (optional) 
     * @return Success
     */
    updateCargoRoad(body: UpdateCargoRoadsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/UpdateCargoRoad";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新货到的Post方法
     * @param body (optional) 
     * @return Success
     */
    updateCargoRoadPost(body: UpdateCargoRoadsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/UpdateCargoRoadPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCargoRoadPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCargoRoadPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCargoRoadPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除货道
     * @param id (optional) 货道ID
     * @return Success
     */
    deleteCargoRoad(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/DeleteCargoRoad?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCargoRoad(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCargoRoad(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCargoRoad(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除货道
     * @param ids (optional) 货道ID数组
     * @return Success
     */
    deleteManyCargoRoads(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/DeleteManyCargoRoads?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteManyCargoRoads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteManyCargoRoads(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteManyCargoRoads(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据code 批量删除
     * @param codes (optional) 货道outerId数组
     * @return Success
     */
    deleteCargoRoadByCodes(codes: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/DeleteCargoRoadByCodes?";
        if (codes === null)
            throw new Error("The parameter 'codes' cannot be null.");
        else if (codes !== undefined)
            codes && codes.forEach(item => { url_ += "codes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCargoRoadByCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCargoRoadByCodes(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCargoRoadByCodes(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据设备ID获取所有货道掉货历史纪录
     * @param deviceId 货架设备ID
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDroppingCargoHistory(deviceId: number, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CargoHistoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ShelfDevice/GetDroppingCargoHistory?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDroppingCargoHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDroppingCargoHistory(<any>response_);
                } catch (e) {
                    return <Observable<CargoHistoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoHistoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDroppingCargoHistory(response: HttpResponseBase): Observable<CargoHistoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoHistoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoHistoryDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_SMARTDEVICE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://smartdevice5.sensingstore.com";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTagsToExcel(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: TagType | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }
}

/** 通过货架层信息新增或删除当前层的货道时的入参 */
export class AddOrDeleteCargoRoadByLayerIdInput implements IAddOrDeleteCargoRoadByLayerIdInput {
    /** 层ID */
    layerId!: number;
    /** 货道ID */
    cargoRoadId!: number | undefined;

    constructor(data?: IAddOrDeleteCargoRoadByLayerIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layerId = _data["layerId"];
            this.cargoRoadId = _data["cargoRoadId"];
        }
    }

    static fromJS(data: any): AddOrDeleteCargoRoadByLayerIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrDeleteCargoRoadByLayerIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        data["cargoRoadId"] = this.cargoRoadId;
        return data; 
    }
}

/** 通过货架层信息新增或删除当前层的货道时的入参 */
export interface IAddOrDeleteCargoRoadByLayerIdInput {
    /** 层ID */
    layerId: number;
    /** 货道ID */
    cargoRoadId: number | undefined;
}

/** 新增或修改货道信息时传入的入参对象 */
export class AddOrUpdateCargoRoadInput implements IAddOrUpdateCargoRoadInput {
    /** 货架设备快速识别编号outerId */
    deviceCode!: string;
    /** 货道快速识别号outerId */
    code!: string;
    /** 货道名称 */
    name!: string;
    /** Cargo Road max Capacity.最大存储量 */
    stockCapacity!: number;
    /** 0：顺序掉货，1：随机掉货 */
    type!: number;
    /** 描述 */
    description!: string | undefined;
    /** 货道内物品集合 */
    things!: CargoThingInput[] | undefined;

    constructor(data?: IAddOrUpdateCargoRoadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceCode = _data["deviceCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.stockCapacity = _data["stockCapacity"];
            this.type = _data["type"];
            this.description = _data["description"];
            if (Array.isArray(_data["things"])) {
                this.things = [] as any;
                for (let item of _data["things"])
                    this.things!.push(CargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateCargoRoadInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateCargoRoadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceCode"] = this.deviceCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["stockCapacity"] = this.stockCapacity;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.things)) {
            data["things"] = [];
            for (let item of this.things)
                data["things"].push(item.toJSON());
        }
        return data; 
    }
}

/** 新增或修改货道信息时传入的入参对象 */
export interface IAddOrUpdateCargoRoadInput {
    /** 货架设备快速识别编号outerId */
    deviceCode: string;
    /** 货道快速识别号outerId */
    code: string;
    /** 货道名称 */
    name: string;
    /** Cargo Road max Capacity.最大存储量 */
    stockCapacity: number;
    /** 0：顺序掉货，1：随机掉货 */
    type: number;
    /** 描述 */
    description: string | undefined;
    /** 货道内物品集合 */
    things: CargoThingInput[] | undefined;
}

/** 新增或更新网关时的入参 */
export class AddOrUpdateGatewayInput implements IAddOrUpdateGatewayInput {
    /** 网关设备ID */
    deviceId!: number;
    /** 协议ID */
    agreementId!: number | undefined;
    gatewayType!: GatewayType;
    /** 网关轮询间隔时间 */
    pollingTime!: number | undefined;

    constructor(data?: IAddOrUpdateGatewayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.agreementId = _data["agreementId"];
            this.gatewayType = _data["gatewayType"];
            this.pollingTime = _data["pollingTime"];
        }
    }

    static fromJS(data: any): AddOrUpdateGatewayInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateGatewayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["agreementId"] = this.agreementId;
        data["gatewayType"] = this.gatewayType;
        data["pollingTime"] = this.pollingTime;
        return data; 
    }
}

/** 新增或更新网关时的入参 */
export interface IAddOrUpdateGatewayInput {
    /** 网关设备ID */
    deviceId: number;
    /** 协议ID */
    agreementId: number | undefined;
    gatewayType: GatewayType;
    /** 网关轮询间隔时间 */
    pollingTime: number | undefined;
}

/** 新增或修改自定义客流报表时的入参 */
export class AddOrUpdateReportInput implements IAddOrUpdateReportInput {
    /** 报表数据库记录ID，修改时必传 */
    id!: number | undefined;
    /** 租户ID，报表由host给租户创建，创建和修改时需要指定是哪个租户 */
    tenantId!: number;
    /** 租户下指定的店铺编号 */
    storeId!: number | undefined;
    reportDataType!: ReportDataType;
    /** 报表名称 */
    name!: string | undefined;
    /** 报表对应的模板ID */
    reportTemplateID!: number;
    /** 报表扩展数据信息，对应ReportData表ID？ */
    externalDataId!: number | undefined;
    /** 描述 */
    description!: string | undefined;
    /** 计算方式 */
    calcFormat!: string | undefined;
    /** 排序方式 */
    orderSequece!: number;
    /** 多个计数器数据合并到一个名称 */
    multiToOneName!: string | undefined;
    /** 分子名称 */
    moleculeTitle!: string | undefined;
    /** 分母名称 */
    denominatorTitle!: string | undefined;
    /** 报表扩展数据信息 */
    reportDataInput!: ReportDataInput[] | undefined;

    constructor(data?: IAddOrUpdateReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            if (Array.isArray(_data["reportDataInput"])) {
                this.reportDataInput = [] as any;
                for (let item of _data["reportDataInput"])
                    this.reportDataInput!.push(ReportDataInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        if (Array.isArray(this.reportDataInput)) {
            data["reportDataInput"] = [];
            for (let item of this.reportDataInput)
                data["reportDataInput"].push(item.toJSON());
        }
        return data; 
    }
}

/** 新增或修改自定义客流报表时的入参 */
export interface IAddOrUpdateReportInput {
    /** 报表数据库记录ID，修改时必传 */
    id: number | undefined;
    /** 租户ID，报表由host给租户创建，创建和修改时需要指定是哪个租户 */
    tenantId: number;
    /** 租户下指定的店铺编号 */
    storeId: number | undefined;
    reportDataType: ReportDataType;
    /** 报表名称 */
    name: string | undefined;
    /** 报表对应的模板ID */
    reportTemplateID: number;
    /** 报表扩展数据信息，对应ReportData表ID？ */
    externalDataId: number | undefined;
    /** 描述 */
    description: string | undefined;
    /** 计算方式 */
    calcFormat: string | undefined;
    /** 排序方式 */
    orderSequece: number;
    /** 多个计数器数据合并到一个名称 */
    multiToOneName: string | undefined;
    /** 分子名称 */
    moleculeTitle: string | undefined;
    /** 分母名称 */
    denominatorTitle: string | undefined;
    /** 报表扩展数据信息 */
    reportDataInput: ReportDataInput[] | undefined;
}

/** 创建自定义客流报表模板时传入的入参 */
export class AddOrUpdateReportTemplateInput implements IAddOrUpdateReportTemplateInput {
    /** 报表模板的ID，修改时必传 */
    id!: number | undefined;
    /** 模板名称 */
    name!: string | undefined;
    counterTagRules!: CounterTagRules;
    deviceTagRules!: CounterTagRules;
    reportType!: ReportType;
    /** 是否需要扩展数据 */
    isNeedExternalData!: boolean;
    description!: string | undefined;
    /** 最大数据数量 */
    maxReportDataCount!: number;
    /** 最小数据数量 */
    minReportDataCount!: number;
    /** 是否可以更改报表数据名称 */
    canChangeReportDataName!: boolean;
    /** 是否支持多个数据合并 */
    canMultiToOne!: boolean;
    /** 报表数据名称数组（如折线图中每条线代表的名称） */
    reportDataNames!: string | undefined;
    /** 计算方式 */
    calcFormat!: string | undefined;
    /** 多个数据合并后的合并名称 */
    multiToOneName!: string | undefined;
    reportCompareType!: ReportCompareType;
    /** 分子名称 */
    moleculeTitle!: string | undefined;
    /** 分母名称 */
    denominatorTitle!: string | undefined;
    /** 是否显示分子 */
    isShowMolecule!: boolean;
    /** 是否显示分母 */
    isShowDenominator!: boolean;
    /** 是否可以更改表标标题 */
    canChangeDigitTitle!: boolean;
    privilege!: string | undefined;
    moleculeBackGroudClassName!: string | undefined;
    moleculeIconClassName!: string | undefined;
    denominatorBackGroudClassName!: string | undefined;
    denominatorIconClassName!: string | undefined;

    constructor(data?: IAddOrUpdateReportTemplateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.counterTagRules = _data["counterTagRules"];
            this.deviceTagRules = _data["deviceTagRules"];
            this.reportType = _data["reportType"];
            this.isNeedExternalData = _data["isNeedExternalData"];
            this.description = _data["description"];
            this.maxReportDataCount = _data["maxReportDataCount"];
            this.minReportDataCount = _data["minReportDataCount"];
            this.canChangeReportDataName = _data["canChangeReportDataName"];
            this.canMultiToOne = _data["canMultiToOne"];
            this.reportDataNames = _data["reportDataNames"];
            this.calcFormat = _data["calcFormat"];
            this.multiToOneName = _data["multiToOneName"];
            this.reportCompareType = _data["reportCompareType"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            this.isShowMolecule = _data["isShowMolecule"];
            this.isShowDenominator = _data["isShowDenominator"];
            this.canChangeDigitTitle = _data["canChangeDigitTitle"];
            this.privilege = _data["privilege"];
            this.moleculeBackGroudClassName = _data["moleculeBackGroudClassName"];
            this.moleculeIconClassName = _data["moleculeIconClassName"];
            this.denominatorBackGroudClassName = _data["denominatorBackGroudClassName"];
            this.denominatorIconClassName = _data["denominatorIconClassName"];
        }
    }

    static fromJS(data: any): AddOrUpdateReportTemplateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateReportTemplateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["counterTagRules"] = this.counterTagRules;
        data["deviceTagRules"] = this.deviceTagRules;
        data["reportType"] = this.reportType;
        data["isNeedExternalData"] = this.isNeedExternalData;
        data["description"] = this.description;
        data["maxReportDataCount"] = this.maxReportDataCount;
        data["minReportDataCount"] = this.minReportDataCount;
        data["canChangeReportDataName"] = this.canChangeReportDataName;
        data["canMultiToOne"] = this.canMultiToOne;
        data["reportDataNames"] = this.reportDataNames;
        data["calcFormat"] = this.calcFormat;
        data["multiToOneName"] = this.multiToOneName;
        data["reportCompareType"] = this.reportCompareType;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        data["isShowMolecule"] = this.isShowMolecule;
        data["isShowDenominator"] = this.isShowDenominator;
        data["canChangeDigitTitle"] = this.canChangeDigitTitle;
        data["privilege"] = this.privilege;
        data["moleculeBackGroudClassName"] = this.moleculeBackGroudClassName;
        data["moleculeIconClassName"] = this.moleculeIconClassName;
        data["denominatorBackGroudClassName"] = this.denominatorBackGroudClassName;
        data["denominatorIconClassName"] = this.denominatorIconClassName;
        return data; 
    }
}

/** 创建自定义客流报表模板时传入的入参 */
export interface IAddOrUpdateReportTemplateInput {
    /** 报表模板的ID，修改时必传 */
    id: number | undefined;
    /** 模板名称 */
    name: string | undefined;
    counterTagRules: CounterTagRules;
    deviceTagRules: CounterTagRules;
    reportType: ReportType;
    /** 是否需要扩展数据 */
    isNeedExternalData: boolean;
    description: string | undefined;
    /** 最大数据数量 */
    maxReportDataCount: number;
    /** 最小数据数量 */
    minReportDataCount: number;
    /** 是否可以更改报表数据名称 */
    canChangeReportDataName: boolean;
    /** 是否支持多个数据合并 */
    canMultiToOne: boolean;
    /** 报表数据名称数组（如折线图中每条线代表的名称） */
    reportDataNames: string | undefined;
    /** 计算方式 */
    calcFormat: string | undefined;
    /** 多个数据合并后的合并名称 */
    multiToOneName: string | undefined;
    reportCompareType: ReportCompareType;
    /** 分子名称 */
    moleculeTitle: string | undefined;
    /** 分母名称 */
    denominatorTitle: string | undefined;
    /** 是否显示分子 */
    isShowMolecule: boolean;
    /** 是否显示分母 */
    isShowDenominator: boolean;
    /** 是否可以更改表标标题 */
    canChangeDigitTitle: boolean;
    privilege: string | undefined;
    moleculeBackGroudClassName: string | undefined;
    moleculeIconClassName: string | undefined;
    denominatorBackGroudClassName: string | undefined;
    denominatorIconClassName: string | undefined;
}

/** 新增或者修改传感器时的入参 */
export class AddOrUpdateSensorInput implements IAddOrUpdateSensorInput {
    /** 传感器绑定的网关设备ID */
    gatewayId!: number;
    /** 传感器设备ID */
    deviceId!: number;
    address!: number;
    /** 数据查询命令 */
    command!: string | undefined;
    /** 协议解析ID */
    agreementId!: number | undefined;

    constructor(data?: IAddOrUpdateSensorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.deviceId = _data["deviceId"];
            this.address = _data["address"];
            this.command = _data["command"];
            this.agreementId = _data["agreementId"];
        }
    }

    static fromJS(data: any): AddOrUpdateSensorInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateSensorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["deviceId"] = this.deviceId;
        data["address"] = this.address;
        data["command"] = this.command;
        data["agreementId"] = this.agreementId;
        return data; 
    }
}

/** 新增或者修改传感器时的入参 */
export interface IAddOrUpdateSensorInput {
    /** 传感器绑定的网关设备ID */
    gatewayId: number;
    /** 传感器设备ID */
    deviceId: number;
    address: number;
    /** 数据查询命令 */
    command: string | undefined;
    /** 协议解析ID */
    agreementId: number | undefined;
}

/** 新增或修改货架信息时传入的入参对象 */
export class AddOrUpdateShelfInfoInput implements IAddOrUpdateShelfInfoInput {
    /** 货架设备ID */
    deviceId!: number | undefined;
    /** 长度 */
    resolution_Length!: number;
    /** 宽度 */
    resolution_Width!: number;
    /** 高度 */
    resolution_Height!: number;
    /** 底部空间高度 */
    footerHeight!: number;
    /** 隔板厚度 */
    outerPartitionHeight!: number;
    /** 层板厚度 */
    layerPartitionHeight!: number;
    /** 角度 */
    shelfDirectionAngle!: number;
    /** X轴起点坐标 */
    startPoint_X!: number;
    /** Y轴起点坐标 */
    startPoint_Y!: number;
    /** 层信息列表 */
    layers!: LayerInput[] | undefined;

    constructor(data?: IAddOrUpdateShelfInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.resolution_Length = _data["resolution_Length"];
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.footerHeight = _data["footerHeight"];
            this.outerPartitionHeight = _data["outerPartitionHeight"];
            this.layerPartitionHeight = _data["layerPartitionHeight"];
            this.shelfDirectionAngle = _data["shelfDirectionAngle"];
            this.startPoint_X = _data["startPoint_X"];
            this.startPoint_Y = _data["startPoint_Y"];
            if (Array.isArray(_data["layers"])) {
                this.layers = [] as any;
                for (let item of _data["layers"])
                    this.layers!.push(LayerInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateShelfInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateShelfInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["resolution_Length"] = this.resolution_Length;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["footerHeight"] = this.footerHeight;
        data["outerPartitionHeight"] = this.outerPartitionHeight;
        data["layerPartitionHeight"] = this.layerPartitionHeight;
        data["shelfDirectionAngle"] = this.shelfDirectionAngle;
        data["startPoint_X"] = this.startPoint_X;
        data["startPoint_Y"] = this.startPoint_Y;
        if (Array.isArray(this.layers)) {
            data["layers"] = [];
            for (let item of this.layers)
                data["layers"].push(item.toJSON());
        }
        return data; 
    }
}

/** 新增或修改货架信息时传入的入参对象 */
export interface IAddOrUpdateShelfInfoInput {
    /** 货架设备ID */
    deviceId: number | undefined;
    /** 长度 */
    resolution_Length: number;
    /** 宽度 */
    resolution_Width: number;
    /** 高度 */
    resolution_Height: number;
    /** 底部空间高度 */
    footerHeight: number;
    /** 隔板厚度 */
    outerPartitionHeight: number;
    /** 层板厚度 */
    layerPartitionHeight: number;
    /** 角度 */
    shelfDirectionAngle: number;
    /** X轴起点坐标 */
    startPoint_X: number;
    /** Y轴起点坐标 */
    startPoint_Y: number;
    /** 层信息列表 */
    layers: LayerInput[] | undefined;
}

/** AppPod基本信息 */
export class AppPodDto implements IAppPodDto {
    /** 数据库记录ID */
    id!: number;
    /** AppPod名称 */
    name!: string | undefined;
    /** 图标 */
    icon!: string | undefined;
    /** 支持的系统版本，目前有Windows和Android */
    os!: string | undefined;
    /** 是否默认 */
    isDefault!: boolean;
    /** 最新版本 */
    latestVersion!: string | undefined;
    /** 下载地址 */
    downloadUrl!: string | undefined;
    /** 最新版本 最后更新时间 */
    latestDatetime!: moment.Moment;

    constructor(data?: IAppPodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.os = _data["os"];
            this.isDefault = _data["isDefault"];
            this.latestVersion = _data["latestVersion"];
            this.downloadUrl = _data["downloadUrl"];
            this.latestDatetime = _data["latestDatetime"] ? moment(_data["latestDatetime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppPodDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["os"] = this.os;
        data["isDefault"] = this.isDefault;
        data["latestVersion"] = this.latestVersion;
        data["downloadUrl"] = this.downloadUrl;
        data["latestDatetime"] = this.latestDatetime ? this.latestDatetime.toISOString() : <any>undefined;
        return data; 
    }
}

/** AppPod基本信息 */
export interface IAppPodDto {
    /** 数据库记录ID */
    id: number;
    /** AppPod名称 */
    name: string | undefined;
    /** 图标 */
    icon: string | undefined;
    /** 支持的系统版本，目前有Windows和Android */
    os: string | undefined;
    /** 是否默认 */
    isDefault: boolean;
    /** 最新版本 */
    latestVersion: string | undefined;
    /** 下载地址 */
    downloadUrl: string | undefined;
    /** 最新版本 最后更新时间 */
    latestDatetime: moment.Moment;
}

export class AppPodDtoPagedResultDto implements IAppPodDtoPagedResultDto {
    totalCount!: number;
    items!: AppPodDto[] | undefined;

    constructor(data?: IAppPodDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppPodDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppPodDtoPagedResultDto {
    totalCount: number;
    items: AppPodDto[] | undefined;
}

/** 上传AppPod截图时的二进制图片入参对象 */
export class AppPodScreenInput implements IAppPodScreenInput {
    /** 截屏照片的二进制图片. */
    screenShot!: string | undefined;

    constructor(data?: IAppPodScreenInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.screenShot = _data["screenShot"];
        }
    }

    static fromJS(data: any): AppPodScreenInput {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodScreenInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["screenShot"] = this.screenShot;
        return data; 
    }
}

/** 上传AppPod截图时的二进制图片入参对象 */
export interface IAppPodScreenInput {
    /** 截屏照片的二进制图片. */
    screenShot: string | undefined;
}

/** AppPod版本基本信息 */
export class AppPodVersionDto implements IAppPodVersionDto {
    /** 版本号 */
    version!: string | undefined;
    /** 下载地址 */
    downloadUrl!: string | undefined;
    /** 配置信息 */
    appSetting!: string | undefined;
    /** 版本描述 */
    description!: string | undefined;
    /** 对应AppPod名称 */
    appPodName!: string | undefined;
    /** 适用的系统 */
    os!: string | undefined;
    /** 文件MD5 */
    md5!: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IAppPodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.description = _data["description"];
            this.appPodName = _data["appPodName"];
            this.os = _data["os"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AppPodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["description"] = this.description;
        data["appPodName"] = this.appPodName;
        data["os"] = this.os;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** AppPod版本基本信息 */
export interface IAppPodVersionDto {
    /** 版本号 */
    version: string | undefined;
    /** 下载地址 */
    downloadUrl: string | undefined;
    /** 配置信息 */
    appSetting: string | undefined;
    /** 版本描述 */
    description: string | undefined;
    /** 对应AppPod名称 */
    appPodName: string | undefined;
    /** 适用的系统 */
    os: string | undefined;
    /** 文件MD5 */
    md5: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AppPodVersionDtoPagedResultDto implements IAppPodVersionDtoPagedResultDto {
    totalCount!: number;
    items!: AppPodVersionDto[] | undefined;

    constructor(data?: IAppPodVersionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppPodVersionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppPodVersionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppPodVersionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppPodVersionDtoPagedResultDto {
    totalCount: number;
    items: AppPodVersionDto[] | undefined;
}

/** 将子设备绑定到网关（主设备） */
export class BindChildDevicesToGatewayInput implements IBindChildDevicesToGatewayInput {
    /** 被绑定的主设备ID */
    gatewayId!: number | undefined;
    /** 被绑定的子设备ID数组 */
    deviceIds!: number[] | undefined;
    /** 绑定类型，目前只有智能货架绑定有效 */
    type!: string | undefined;
    /** 绑定的物品ID信息 */
    thingId!: string | undefined;
    /** 绑定的物品排序编号 */
    orderNumber!: number | undefined;

    constructor(data?: IBindChildDevicesToGatewayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.type = _data["type"];
            this.thingId = _data["thingId"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): BindChildDevicesToGatewayInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindChildDevicesToGatewayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["type"] = this.type;
        data["thingId"] = this.thingId;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

/** 将子设备绑定到网关（主设备） */
export interface IBindChildDevicesToGatewayInput {
    /** 被绑定的主设备ID */
    gatewayId: number | undefined;
    /** 被绑定的子设备ID数组 */
    deviceIds: number[] | undefined;
    /** 绑定类型，目前只有智能货架绑定有效 */
    type: string | undefined;
    /** 绑定的物品ID信息 */
    thingId: string | undefined;
    /** 绑定的物品排序编号 */
    orderNumber: number | undefined;
}

/** 把标签绑定到计数器时的入参 */
export class BindTagsToDeviceCounterInput implements IBindTagsToDeviceCounterInput {
    /** 计数器ID */
    counterId!: number;
    /** 标签ID数组 */
    tagId!: number[] | undefined;

    constructor(data?: IBindTagsToDeviceCounterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterId = _data["counterId"];
            if (Array.isArray(_data["tagId"])) {
                this.tagId = [] as any;
                for (let item of _data["tagId"])
                    this.tagId!.push(item);
            }
        }
    }

    static fromJS(data: any): BindTagsToDeviceCounterInput {
        data = typeof data === 'object' ? data : {};
        let result = new BindTagsToDeviceCounterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterId"] = this.counterId;
        if (Array.isArray(this.tagId)) {
            data["tagId"] = [];
            for (let item of this.tagId)
                data["tagId"].push(item);
        }
        return data; 
    }
}

/** 把标签绑定到计数器时的入参 */
export interface IBindTagsToDeviceCounterInput {
    /** 计数器ID */
    counterId: number;
    /** 标签ID数组 */
    tagId: number[] | undefined;
}

export enum CalculateType {
    Plus = 0,
    Reduce = 1,
}

/** 获取货道历史掉货记录的返回对象 */
export class CargoHistoryDto implements ICargoHistoryDto {
    /** 货道Icon. */
    iconUrl!: string | undefined;
    /** 货道名称 */
    name!: string | undefined;
    cargoRoadId!: number;
    cargoThingId!: number;
    thingName!: string | undefined;
    quantity!: number;
    cargoAction!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICargoHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconUrl = _data["iconUrl"];
            this.name = _data["name"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.thingName = _data["thingName"];
            this.quantity = _data["quantity"];
            this.cargoAction = _data["cargoAction"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CargoHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconUrl"] = this.iconUrl;
        data["name"] = this.name;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["thingName"] = this.thingName;
        data["quantity"] = this.quantity;
        data["cargoAction"] = this.cargoAction;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取货道历史掉货记录的返回对象 */
export interface ICargoHistoryDto {
    /** 货道Icon. */
    iconUrl: string | undefined;
    /** 货道名称 */
    name: string | undefined;
    cargoRoadId: number;
    cargoThingId: number;
    thingName: string | undefined;
    quantity: number;
    cargoAction: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CargoHistoryDtoPagedResultDto implements ICargoHistoryDtoPagedResultDto {
    totalCount!: number;
    items!: CargoHistoryDto[] | undefined;

    constructor(data?: ICargoHistoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CargoHistoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoHistoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoHistoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoHistoryDtoPagedResultDto {
    totalCount: number;
    items: CargoHistoryDto[] | undefined;
}

/** 获取货道列表时返回的列表对象 */
export class CargoRoadDto implements ICargoRoadDto {
    /** 货架ID */
    deviceId!: number;
    /** 租户ID */
    tenantId!: number;
    /** 货道名称 */
    name!: string | undefined;
    /** 货道编号. */
    outerId!: string | undefined;
    isEnabled!: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity!: number;
    description!: string | undefined;
    cargoType!: CargoTypeEnum;
    extensionData!: string | undefined;
    spanRows!: number;
    spanColumns!: number;
    /** 货道中的商品信息列表 */
    cargoThings!: CargoThingDto[] | undefined;
    layerId!: number | undefined;
    /** 货道宽度 */
    resolution_Length!: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X!: number;
    /** 货道高度 */
    resolution_Height!: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z!: number;
    /** 货道标定的毛重 */
    grossWeight!: number;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICargoRoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.cargoType = _data["cargoType"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CargoThingDto.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CargoRoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoRoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["cargoType"] = this.cargoType;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取货道列表时返回的列表对象 */
export interface ICargoRoadDto {
    /** 货架ID */
    deviceId: number;
    /** 租户ID */
    tenantId: number;
    /** 货道名称 */
    name: string | undefined;
    /** 货道编号. */
    outerId: string | undefined;
    isEnabled: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity: number;
    description: string | undefined;
    cargoType: CargoTypeEnum;
    extensionData: string | undefined;
    spanRows: number;
    spanColumns: number;
    /** 货道中的商品信息列表 */
    cargoThings: CargoThingDto[] | undefined;
    layerId: number | undefined;
    /** 货道宽度 */
    resolution_Length: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X: number;
    /** 货道高度 */
    resolution_Height: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z: number;
    /** 货道标定的毛重 */
    grossWeight: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CargoRoadDtoPagedResultDto implements ICargoRoadDtoPagedResultDto {
    totalCount!: number;
    items!: CargoRoadDto[] | undefined;

    constructor(data?: ICargoRoadDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CargoRoadDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoRoadDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoRoadDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoRoadDtoPagedResultDto {
    totalCount: number;
    items: CargoRoadDto[] | undefined;
}

/** 货道状态对象 */
export class CargoStatus implements ICargoStatus {
    /** 货道ID */
    id!: number;
    /** 货道启用状态，true为启用，false为不启用 */
    isEnable!: boolean;

    constructor(data?: ICargoStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isEnable = _data["isEnable"];
        }
    }

    static fromJS(data: any): CargoStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isEnable"] = this.isEnable;
        return data; 
    }
}

/** 货道状态对象 */
export interface ICargoStatus {
    /** 货道ID */
    id: number;
    /** 货道启用状态，true为启用，false为不启用 */
    isEnable: boolean;
}

export class CargoStock implements ICargoStock {
    /** 货道ID */
    cargoRoadId!: number;
    /** 补货物品列表信息 */
    replenishCargoThing!: ReplenishCargoThingInput[] | undefined;

    constructor(data?: ICargoStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cargoRoadId = _data["cargoRoadId"];
            if (Array.isArray(_data["replenishCargoThing"])) {
                this.replenishCargoThing = [] as any;
                for (let item of _data["replenishCargoThing"])
                    this.replenishCargoThing!.push(ReplenishCargoThingInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CargoStock {
        data = typeof data === 'object' ? data : {};
        let result = new CargoStock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cargoRoadId"] = this.cargoRoadId;
        if (Array.isArray(this.replenishCargoThing)) {
            data["replenishCargoThing"] = [];
            for (let item of this.replenishCargoThing)
                data["replenishCargoThing"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICargoStock {
    /** 货道ID */
    cargoRoadId: number;
    /** 补货物品列表信息 */
    replenishCargoThing: ReplenishCargoThingInput[] | undefined;
}

/** 货道中获取信息对象 */
export class CargoThingDto implements ICargoThingDto {
    /** 记录ID */
    id!: number;
    /** 商品和货道绑定记录ID */
    cargoThingId!: number | undefined;
    /** 货道ID */
    cargoRoadId!: number;
    /** 商品ID */
    thingId!: number;
    type!: CargoType;
    /** 商品名称 */
    thingName!: string | undefined;
    /** 商品库存 */
    stock!: number;
    description!: string | undefined;
    extensionData!: string | undefined;
    /** 货道Icon. */
    iconUrl!: string | undefined;
    orderNumber!: number;
    /** 商品编号 */
    thingOuterId!: string | undefined;

    constructor(data?: ICargoThingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cargoThingId = _data["cargoThingId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.thingName = _data["thingName"];
            this.stock = _data["stock"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.iconUrl = _data["iconUrl"];
            this.orderNumber = _data["orderNumber"];
            this.thingOuterId = _data["thingOuterId"];
        }
    }

    static fromJS(data: any): CargoThingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoThingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cargoThingId"] = this.cargoThingId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["thingName"] = this.thingName;
        data["stock"] = this.stock;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["iconUrl"] = this.iconUrl;
        data["orderNumber"] = this.orderNumber;
        data["thingOuterId"] = this.thingOuterId;
        return data; 
    }
}

/** 货道中获取信息对象 */
export interface ICargoThingDto {
    /** 记录ID */
    id: number;
    /** 商品和货道绑定记录ID */
    cargoThingId: number | undefined;
    /** 货道ID */
    cargoRoadId: number;
    /** 商品ID */
    thingId: number;
    type: CargoType;
    /** 商品名称 */
    thingName: string | undefined;
    /** 商品库存 */
    stock: number;
    description: string | undefined;
    extensionData: string | undefined;
    /** 货道Icon. */
    iconUrl: string | undefined;
    orderNumber: number;
    /** 商品编号 */
    thingOuterId: string | undefined;
}

export class CargoThingInput implements ICargoThingInput {
    /** 货物的类型，0：Product，1：Sku，2：Award */
    type!: number;
    /** 物品outerId */
    thingOuterId!: string;
    /** 库存数量 */
    stock!: number;
    /** 图标 */
    iconUrl!: string | undefined;
    /** 排序编号 */
    orderNumber!: number;
    /** 描述 */
    description!: string | undefined;
    layerId!: number | undefined;
    /** 货道宽度 */
    resolution_Length!: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X!: number;
    /** 货道高度 */
    resolution_Height!: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z!: number;
    /** 货道标定的毛重 */
    grossWeight!: number;

    constructor(data?: ICargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.thingOuterId = _data["thingOuterId"];
            this.stock = _data["stock"];
            this.iconUrl = _data["iconUrl"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): CargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["thingOuterId"] = this.thingOuterId;
        data["stock"] = this.stock;
        data["iconUrl"] = this.iconUrl;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

export interface ICargoThingInput {
    /** 货物的类型，0：Product，1：Sku，2：Award */
    type: number;
    /** 物品outerId */
    thingOuterId: string;
    /** 库存数量 */
    stock: number;
    /** 图标 */
    iconUrl: string | undefined;
    /** 排序编号 */
    orderNumber: number;
    /** 描述 */
    description: string | undefined;
    layerId: number | undefined;
    /** 货道宽度 */
    resolution_Length: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X: number;
    /** 货道高度 */
    resolution_Height: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z: number;
    /** 货道标定的毛重 */
    grossWeight: number;
}

export enum CargoType {
    Product = 0,
    Sku = 1,
    Award = 2,
}

export enum CargoTypeEnum {
    Sequence = 0,
    Random = 1,
}

/** 修改设备的AppPod版本 */
export class ChangeDeviceAppPodVersionInput implements IChangeDeviceAppPodVersionInput {
    /** 设备ID */
    deviceId!: number;
    /** 目标AppPod版本 */
    targetAppPodVersionId!: number;
    /** 扩展信息 */
    extensionData!: string | undefined;
    /** 是否锁定 */
    isLock!: boolean;

    constructor(data?: IChangeDeviceAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.targetAppPodVersionId = _data["targetAppPodVersionId"];
            this.extensionData = _data["extensionData"];
            this.isLock = _data["isLock"];
        }
    }

    static fromJS(data: any): ChangeDeviceAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDeviceAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["targetAppPodVersionId"] = this.targetAppPodVersionId;
        data["extensionData"] = this.extensionData;
        data["isLock"] = this.isLock;
        return data; 
    }
}

/** 修改设备的AppPod版本 */
export interface IChangeDeviceAppPodVersionInput {
    /** 设备ID */
    deviceId: number;
    /** 目标AppPod版本 */
    targetAppPodVersionId: number;
    /** 扩展信息 */
    extensionData: string | undefined;
    /** 是否锁定 */
    isLock: boolean;
}

/** 修改设备AppPod版本信息时入参对象 */
export class ChangeDeviceAppPodVersionInputWidtSubkey implements IChangeDeviceAppPodVersionInputWidtSubkey {
    subkey!: string;
    /** 当前最新AppPod版本ID */
    currentAppPodVersionId!: number | undefined;

    constructor(data?: IChangeDeviceAppPodVersionInputWidtSubkey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.currentAppPodVersionId = _data["currentAppPodVersionId"];
        }
    }

    static fromJS(data: any): ChangeDeviceAppPodVersionInputWidtSubkey {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDeviceAppPodVersionInputWidtSubkey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["currentAppPodVersionId"] = this.currentAppPodVersionId;
        return data; 
    }
}

/** 修改设备AppPod版本信息时入参对象 */
export interface IChangeDeviceAppPodVersionInputWidtSubkey {
    subkey: string;
    /** 当前最新AppPod版本ID */
    currentAppPodVersionId: number | undefined;
}

export class ChartItem implements IChartItem {
    /** 文本格式日期信息 */
    date!: string | undefined;
    /** 数据值 */
    value!: number;
    /** 数据ID */
    thingId!: number;

    constructor(data?: IChartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.value = _data["value"];
            this.thingId = _data["thingId"];
        }
    }

    static fromJS(data: any): ChartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["value"] = this.value;
        data["thingId"] = this.thingId;
        return data; 
    }
}

export interface IChartItem {
    /** 文本格式日期信息 */
    date: string | undefined;
    /** 数据值 */
    value: number;
    /** 数据ID */
    thingId: number;
}

export class ChildDeviceDto implements IChildDeviceDto {
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    thingId!: string | undefined;
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    type!: string | undefined;
    /** 如果一层安装多个条形屏，用ordernumber来确定安装顺序，从左到右依次递增 */
    orderNumber!: number | undefined;
    device!: DeviceDto;

    constructor(data?: IChildDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.orderNumber = _data["orderNumber"];
            this.device = _data["device"] ? DeviceDto.fromJS(_data["device"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChildDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChildDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["orderNumber"] = this.orderNumber;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IChildDeviceDto {
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    thingId: string | undefined;
    /** 绑定类型，如果绑定的是称重、价签或光敏传感器，Type为CargoRoad，ThingId是货道Id
如果绑定的是条形屏，则Type为Layer，ThingId为层Id */
    type: string | undefined;
    /** 如果一层安装多个条形屏，用ordernumber来确定安装顺序，从左到右依次递增 */
    orderNumber: number | undefined;
    device: DeviceDto;
}

export enum ControlType {
    Limit = 0,
    Timing = 1,
    Manual = 2,
    Reverse = 3,
}

export class CounterDto implements ICounterDto {
    name!: string | undefined;

    constructor(data?: ICounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICounterDto {
    name: string | undefined;
}

export class CounterInfo implements ICounterInfo {
    /** 计数器ID */
    id!: number | undefined;
    /** 计数器名称 */
    counterName!: string | undefined;
    /** 计数器显示名称 */
    displayName!: string | undefined;
    /** 计数器描述 */
    describution!: string | undefined;
    /** 该计数器总计的计数数量 */
    totalCount!: number;
    /** 标签ID数组 */
    tagId!: number[] | undefined;

    constructor(data?: ICounterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterName = _data["counterName"];
            this.displayName = _data["displayName"];
            this.describution = _data["describution"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["tagId"])) {
                this.tagId = [] as any;
                for (let item of _data["tagId"])
                    this.tagId!.push(item);
            }
        }
    }

    static fromJS(data: any): CounterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CounterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterName"] = this.counterName;
        data["displayName"] = this.displayName;
        data["describution"] = this.describution;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.tagId)) {
            data["tagId"] = [];
            for (let item of this.tagId)
                data["tagId"].push(item);
        }
        return data; 
    }
}

export interface ICounterInfo {
    /** 计数器ID */
    id: number | undefined;
    /** 计数器名称 */
    counterName: string | undefined;
    /** 计数器显示名称 */
    displayName: string | undefined;
    /** 计数器描述 */
    describution: string | undefined;
    /** 该计数器总计的计数数量 */
    totalCount: number;
    /** 标签ID数组 */
    tagId: number[] | undefined;
}

export class CounterRecordDto implements ICounterRecordDto {
    collectionTime!: moment.Moment;
    collectEndTime!: moment.Moment;
    total!: number;
    increment!: number;

    constructor(data?: ICounterRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
            this.total = _data["total"];
            this.increment = _data["increment"];
        }
    }

    static fromJS(data: any): CounterRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        data["total"] = this.total;
        data["increment"] = this.increment;
        return data; 
    }
}

export interface ICounterRecordDto {
    collectionTime: moment.Moment;
    collectEndTime: moment.Moment;
    total: number;
    increment: number;
}

export class CounterRecordsDto implements ICounterRecordsDto {
    name!: string | undefined;
    records!: CounterRecordDto[] | undefined;

    constructor(data?: ICounterRecordsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(CounterRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CounterRecordsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CounterRecordsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICounterRecordsDto {
    name: string | undefined;
    records: CounterRecordDto[] | undefined;
}

export enum CounterTagRules {
    Union = 0,
    Intersection = 1,
}

/** 创建一个新的AppPod版本信息 */
export class CreateAppPodVersionInput implements ICreateAppPodVersionInput {
    /** 对应所属AppPod的数据库记录Id */
    appPodId!: number;
    /** 版本号 */
    version!: string;
    /** 描述 */
    description!: string | undefined;
    /** 下载地址 */
    downloadUrl!: string;
    /** 配置信息 */
    appSetting!: string | undefined;
    /** 文件MD5 */
    md5!: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart!: boolean;

    constructor(data?: ICreateAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appPodId = _data["appPodId"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): CreateAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appPodId"] = this.appPodId;
        data["version"] = this.version;
        data["description"] = this.description;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

/** 创建一个新的AppPod版本信息 */
export interface ICreateAppPodVersionInput {
    /** 对应所属AppPod的数据库记录Id */
    appPodId: number;
    /** 版本号 */
    version: string;
    /** 描述 */
    description: string | undefined;
    /** 下载地址 */
    downloadUrl: string;
    /** 配置信息 */
    appSetting: string | undefined;
    /** 文件MD5 */
    md5: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart: boolean;
}

/** 创建货道时的传入入参 */
export class CreateCargoRoadsInput implements ICreateCargoRoadsInput {
    /** 所属货架设备ID */
    deviceId!: number;
    /** 货道名称 */
    name!: string;
    /** 货道快速识别号. */
    outerId!: string | undefined;
    /** 是否启用 */
    isEnabled!: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity!: number;
    /** 货道描述信息 */
    description!: string | undefined;
    /** 扩展信息，用于存储一些特殊属性信息 */
    extensionData!: string | undefined;
    /** 行数 */
    spanRows!: number;
    /** 列数 */
    spanColumns!: number;
    cargoType!: CargoTypeEnum;
    /** 存放物品信息 */
    cargoThings!: CreateCargoThingInput[] | undefined;
    /** 货架层ID */
    layerId!: number | undefined;
    /** 货道宽度 */
    resolution_Length!: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X!: number;
    /** 货道高度 */
    resolution_Height!: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z!: number;
    /** 货道标定的毛重 */
    grossWeight!: number;

    constructor(data?: ICreateCargoRoadsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            this.cargoType = _data["cargoType"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CreateCargoThingInput.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): CreateCargoRoadsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCargoRoadsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        data["cargoType"] = this.cargoType;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

/** 创建货道时的传入入参 */
export interface ICreateCargoRoadsInput {
    /** 所属货架设备ID */
    deviceId: number;
    /** 货道名称 */
    name: string;
    /** 货道快速识别号. */
    outerId: string | undefined;
    /** 是否启用 */
    isEnabled: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity: number;
    /** 货道描述信息 */
    description: string | undefined;
    /** 扩展信息，用于存储一些特殊属性信息 */
    extensionData: string | undefined;
    /** 行数 */
    spanRows: number;
    /** 列数 */
    spanColumns: number;
    cargoType: CargoTypeEnum;
    /** 存放物品信息 */
    cargoThings: CreateCargoThingInput[] | undefined;
    /** 货架层ID */
    layerId: number | undefined;
    /** 货道宽度 */
    resolution_Length: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X: number;
    /** 货道高度 */
    resolution_Height: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z: number;
    /** 货道标定的毛重 */
    grossWeight: number;
}

/** 创建货道里面商品时传入入参 */
export class CreateCargoThingInput implements ICreateCargoThingInput {
    /** 物品ID */
    thingId!: number;
    type!: CargoType;
    /** 物品名称 */
    thingName!: string | undefined;
    /** 库存 */
    stock!: number;
    /** 描述 */
    description!: string | undefined;
    /** 扩展信息 */
    extensionData!: string | undefined;
    /** 排序序号 */
    orderNumber!: number;
    /** 货道Icon. */
    iconUrl!: string | undefined;
    /** 物品outerId */
    thingOuterId!: string | undefined;

    constructor(data?: ICreateCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.thingName = _data["thingName"];
            this.stock = _data["stock"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.orderNumber = _data["orderNumber"];
            this.iconUrl = _data["iconUrl"];
            this.thingOuterId = _data["thingOuterId"];
        }
    }

    static fromJS(data: any): CreateCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["thingName"] = this.thingName;
        data["stock"] = this.stock;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["orderNumber"] = this.orderNumber;
        data["iconUrl"] = this.iconUrl;
        data["thingOuterId"] = this.thingOuterId;
        return data; 
    }
}

/** 创建货道里面商品时传入入参 */
export interface ICreateCargoThingInput {
    /** 物品ID */
    thingId: number;
    type: CargoType;
    /** 物品名称 */
    thingName: string | undefined;
    /** 库存 */
    stock: number;
    /** 描述 */
    description: string | undefined;
    /** 扩展信息 */
    extensionData: string | undefined;
    /** 排序序号 */
    orderNumber: number;
    /** 货道Icon. */
    iconUrl: string | undefined;
    /** 物品outerId */
    thingOuterId: string | undefined;
}

export class CreateChildDeviceAndCountersDto implements ICreateChildDeviceAndCountersDto {
    /** 设备subkey */
    subKey!: string | undefined;
    /** 子Mac地址 */
    mac!: string | undefined;
    /** 子设备名称 */
    name!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    status!: string | undefined;
    licenseInfo!: string | undefined;
    type!: string | undefined;
    hardwareCode!: string | undefined;
    counters!: CounterDto[] | undefined;

    constructor(data?: ICreateChildDeviceAndCountersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.mac = _data["mac"];
            this.name = _data["name"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.status = _data["status"];
            this.licenseInfo = _data["licenseInfo"];
            this.type = _data["type"];
            this.hardwareCode = _data["hardwareCode"];
            if (Array.isArray(_data["counters"])) {
                this.counters = [] as any;
                for (let item of _data["counters"])
                    this.counters!.push(CounterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateChildDeviceAndCountersDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChildDeviceAndCountersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["mac"] = this.mac;
        data["name"] = this.name;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["status"] = this.status;
        data["licenseInfo"] = this.licenseInfo;
        data["type"] = this.type;
        data["hardwareCode"] = this.hardwareCode;
        if (Array.isArray(this.counters)) {
            data["counters"] = [];
            for (let item of this.counters)
                data["counters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateChildDeviceAndCountersDto {
    /** 设备subkey */
    subKey: string | undefined;
    /** 子Mac地址 */
    mac: string | undefined;
    /** 子设备名称 */
    name: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    status: string | undefined;
    licenseInfo: string | undefined;
    type: string | undefined;
    hardwareCode: string | undefined;
    counters: CounterDto[] | undefined;
}

/** 创建计数器时的入参 */
export class CreateCounterInput implements ICreateCounterInput {
    /** 客流分析设备编号 */
    deviceId!: number;
    /** 创建时是否自动删除其他计数器 */
    deleteOtherCounters!: boolean;
    /** 计数器列表信息 */
    counterInfos!: CounterInfo[] | undefined;

    constructor(data?: ICreateCounterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deleteOtherCounters = _data["deleteOtherCounters"];
            if (Array.isArray(_data["counterInfos"])) {
                this.counterInfos = [] as any;
                for (let item of _data["counterInfos"])
                    this.counterInfos!.push(CounterInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCounterInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCounterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deleteOtherCounters"] = this.deleteOtherCounters;
        if (Array.isArray(this.counterInfos)) {
            data["counterInfos"] = [];
            for (let item of this.counterInfos)
                data["counterInfos"].push(item.toJSON());
        }
        return data; 
    }
}

/** 创建计数器时的入参 */
export interface ICreateCounterInput {
    /** 客流分析设备编号 */
    deviceId: number;
    /** 创建时是否自动删除其他计数器 */
    deleteOtherCounters: boolean;
    /** 计数器列表信息 */
    counterInfos: CounterInfo[] | undefined;
}

/** 创建计数器分组时的入参 */
export class CreateDeviceCounterGroupInput implements ICreateDeviceCounterGroupInput {
    /** 门店编号 */
    storeId!: number;
    /** 分组名称 */
    groupName!: string | undefined;

    constructor(data?: ICreateDeviceCounterGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): CreateDeviceCounterGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceCounterGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["groupName"] = this.groupName;
        return data; 
    }
}

/** 创建计数器分组时的入参 */
export interface ICreateDeviceCounterGroupInput {
    /** 门店编号 */
    storeId: number;
    /** 分组名称 */
    groupName: string | undefined;
}

/** 创建计数器数据记录时的入参 */
export class CreateDeviceCounterRecordInput implements ICreateDeviceCounterRecordInput {
    /** 传感器或客流摄像头设备ID */
    deviceId!: number;
    /** 计数器编号 */
    counterId!: number;
    /** 本次计数数量 */
    increment!: number;
    /** 收集开始时间 */
    collectionTime!: moment.Moment;
    /** 收集结束时间 */
    collectEndTime!: moment.Moment;

    constructor(data?: ICreateDeviceCounterRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.counterId = _data["counterId"];
            this.increment = _data["increment"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.collectEndTime = _data["collectEndTime"] ? moment(_data["collectEndTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateDeviceCounterRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceCounterRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["counterId"] = this.counterId;
        data["increment"] = this.increment;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["collectEndTime"] = this.collectEndTime ? this.collectEndTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** 创建计数器数据记录时的入参 */
export interface ICreateDeviceCounterRecordInput {
    /** 传感器或客流摄像头设备ID */
    deviceId: number;
    /** 计数器编号 */
    counterId: number;
    /** 本次计数数量 */
    increment: number;
    /** 收集开始时间 */
    collectionTime: moment.Moment;
    /** 收集结束时间 */
    collectEndTime: moment.Moment;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

/** 数据记录明细对象 */
export class DataRecordDto implements IDataRecordDto {
    /** 数据记录ID */
    id!: number;
    /** 采集时间 */
    collectionTime!: moment.Moment;
    /** 数据名称 */
    dataName!: string | undefined;
    /** 数据结果 */
    data!: number;
    dataStatus!: DataStatus;

    constructor(data?: IDataRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.dataName = _data["dataName"];
            this.data = _data["data"];
            this.dataStatus = _data["dataStatus"];
        }
    }

    static fromJS(data: any): DataRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["dataName"] = this.dataName;
        data["data"] = this.data;
        data["dataStatus"] = this.dataStatus;
        return data; 
    }
}

/** 数据记录明细对象 */
export interface IDataRecordDto {
    /** 数据记录ID */
    id: number;
    /** 采集时间 */
    collectionTime: moment.Moment;
    /** 数据名称 */
    dataName: string | undefined;
    /** 数据结果 */
    data: number;
    dataStatus: DataStatus;
}

export enum DataStatus {
    Normal = 0,
    ExceedUpLimit = 1,
    ExceedDownLimit = 2,
    Error = 3,
}

export class DeviceAgreement implements IDeviceAgreement {
    name!: string | undefined;
    agreement!: string | undefined;
    description!: string | undefined;
    datas!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IDeviceAgreement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.agreement = _data["agreement"];
            this.description = _data["description"];
            this.datas = _data["datas"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeviceAgreement {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAgreement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["agreement"] = this.agreement;
        data["description"] = this.description;
        data["datas"] = this.datas;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDeviceAgreement {
    name: string | undefined;
    agreement: string | undefined;
    description: string | undefined;
    datas: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class DeviceAgreementPagedResultDto implements IDeviceAgreementPagedResultDto {
    totalCount!: number;
    items!: DeviceAgreement[] | undefined;

    constructor(data?: IDeviceAgreementPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceAgreement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceAgreementPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAgreementPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceAgreementPagedResultDto {
    totalCount: number;
    items: DeviceAgreement[] | undefined;
}

/** 设备当前的AppPod版本信息，将AppPod版本发布给设备之后就会有此信息 */
export class DeviceAppPodVersionDto implements IDeviceAppPodVersionDto {
    /** 当前版本Id号 */
    currentAppPodVersionId!: number | undefined;
    /** 当前版本号 */
    currentVersion!: string | undefined;
    /** 当前版本下载地址 */
    currentDownloadUrl!: string | undefined;
    /** 设备的目标版本ID */
    targetAppPodVersionId!: number | undefined;
    /** 目标版本号 */
    targetVersion!: string | undefined;
    /** 目标版本号的下载地址 */
    targetDownloadUrl!: string | undefined;
    /** 当前设备对应的AppPod的名称 */
    currentAppPodName!: string | undefined;
    /** 当前设备的目标AppPod的名称 */
    targetAppPodName!: string | undefined;
    /** 版本适用系统类型 */
    os!: string | undefined;
    /** 目标版本的配置信息 */
    targetVersionAppSetting!: string | undefined;
    /** 版本描述信息 */
    description!: string | undefined;
    /** 是否锁定版本 */
    isLocked!: boolean;
    /** 扩展信息 */
    extensionData!: string | undefined;
    /** 版本号对应程序文件的MD5 */
    md5!: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart!: boolean;

    constructor(data?: IDeviceAppPodVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentAppPodVersionId = _data["currentAppPodVersionId"];
            this.currentVersion = _data["currentVersion"];
            this.currentDownloadUrl = _data["currentDownloadUrl"];
            this.targetAppPodVersionId = _data["targetAppPodVersionId"];
            this.targetVersion = _data["targetVersion"];
            this.targetDownloadUrl = _data["targetDownloadUrl"];
            this.currentAppPodName = _data["currentAppPodName"];
            this.targetAppPodName = _data["targetAppPodName"];
            this.os = _data["os"];
            this.targetVersionAppSetting = _data["targetVersionAppSetting"];
            this.description = _data["description"];
            this.isLocked = _data["isLocked"];
            this.extensionData = _data["extensionData"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): DeviceAppPodVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceAppPodVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentAppPodVersionId"] = this.currentAppPodVersionId;
        data["currentVersion"] = this.currentVersion;
        data["currentDownloadUrl"] = this.currentDownloadUrl;
        data["targetAppPodVersionId"] = this.targetAppPodVersionId;
        data["targetVersion"] = this.targetVersion;
        data["targetDownloadUrl"] = this.targetDownloadUrl;
        data["currentAppPodName"] = this.currentAppPodName;
        data["targetAppPodName"] = this.targetAppPodName;
        data["os"] = this.os;
        data["targetVersionAppSetting"] = this.targetVersionAppSetting;
        data["description"] = this.description;
        data["isLocked"] = this.isLocked;
        data["extensionData"] = this.extensionData;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

/** 设备当前的AppPod版本信息，将AppPod版本发布给设备之后就会有此信息 */
export interface IDeviceAppPodVersionDto {
    /** 当前版本Id号 */
    currentAppPodVersionId: number | undefined;
    /** 当前版本号 */
    currentVersion: string | undefined;
    /** 当前版本下载地址 */
    currentDownloadUrl: string | undefined;
    /** 设备的目标版本ID */
    targetAppPodVersionId: number | undefined;
    /** 目标版本号 */
    targetVersion: string | undefined;
    /** 目标版本号的下载地址 */
    targetDownloadUrl: string | undefined;
    /** 当前设备对应的AppPod的名称 */
    currentAppPodName: string | undefined;
    /** 当前设备的目标AppPod的名称 */
    targetAppPodName: string | undefined;
    /** 版本适用系统类型 */
    os: string | undefined;
    /** 目标版本的配置信息 */
    targetVersionAppSetting: string | undefined;
    /** 版本描述信息 */
    description: string | undefined;
    /** 是否锁定版本 */
    isLocked: boolean;
    /** 扩展信息 */
    extensionData: string | undefined;
    /** 版本号对应程序文件的MD5 */
    md5: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart: boolean;
}

export class DeviceCounterRecords implements IDeviceCounterRecords {
    subKey!: string | undefined;
    mac!: string | undefined;
    counters!: CounterRecordsDto[] | undefined;

    constructor(data?: IDeviceCounterRecords) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subKey = _data["subKey"];
            this.mac = _data["mac"];
            if (Array.isArray(_data["counters"])) {
                this.counters = [] as any;
                for (let item of _data["counters"])
                    this.counters!.push(CounterRecordsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceCounterRecords {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceCounterRecords();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subKey"] = this.subKey;
        data["mac"] = this.mac;
        if (Array.isArray(this.counters)) {
            data["counters"] = [];
            for (let item of this.counters)
                data["counters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceCounterRecords {
    subKey: string | undefined;
    mac: string | undefined;
    counters: CounterRecordsDto[] | undefined;
}

export class DeviceDto implements IDeviceDto {
    id!: number;
    name!: string | undefined;
    mac!: string | undefined;
    isLocked!: boolean;
    deviceTypeName!: string | undefined;
    address!: string | undefined;
    intranetIP!: string | undefined;
    internetIP!: string | undefined;
    description!: string | undefined;
    /** 设备是否已被注册，如果已注册，另外的机器不能再注册. 同时管理员可以清空，允许其它设备进行注册. */
    isRegistered!: boolean;
    licenseInfo!: string | undefined;
    hardwareCode!: string | undefined;
    shutdownTime!: moment.Moment | undefined;
    resolution_Width!: number;
    resolution_Height!: number;
    /** 访问此设备的唯一凭证，通过Subkey可调用平台api，拿到设备相关的信息，如,ads,apps,products等.同时可用户注册. */
    subKey!: string | undefined;
    os!: string | undefined;
    onlineTrafficTarget!: string | undefined;
    tenantName!: string | undefined;
    tenantId!: number;
    organizationUnitName!: string | undefined;
    organizationUnitId!: number;
    outType!: string | undefined;
    taobaoDeviceId!: string | undefined;
    osType!: OsTypeEnum;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.isLocked = _data["isLocked"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.intranetIP = _data["intranetIP"];
            this.internetIP = _data["internetIP"];
            this.description = _data["description"];
            this.isRegistered = _data["isRegistered"];
            this.licenseInfo = _data["licenseInfo"];
            this.hardwareCode = _data["hardwareCode"];
            this.shutdownTime = _data["shutdownTime"] ? moment(_data["shutdownTime"].toString()) : <any>undefined;
            this.resolution_Width = _data["resolution_Width"];
            this.resolution_Height = _data["resolution_Height"];
            this.subKey = _data["subKey"];
            this.os = _data["os"];
            this.onlineTrafficTarget = _data["onlineTrafficTarget"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outType = _data["outType"];
            this.taobaoDeviceId = _data["taobaoDeviceId"];
            this.osType = _data["osType"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["isLocked"] = this.isLocked;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["intranetIP"] = this.intranetIP;
        data["internetIP"] = this.internetIP;
        data["description"] = this.description;
        data["isRegistered"] = this.isRegistered;
        data["licenseInfo"] = this.licenseInfo;
        data["hardwareCode"] = this.hardwareCode;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toISOString() : <any>undefined;
        data["resolution_Width"] = this.resolution_Width;
        data["resolution_Height"] = this.resolution_Height;
        data["subKey"] = this.subKey;
        data["os"] = this.os;
        data["onlineTrafficTarget"] = this.onlineTrafficTarget;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outType"] = this.outType;
        data["taobaoDeviceId"] = this.taobaoDeviceId;
        data["osType"] = this.osType;
        return data; 
    }
}

export interface IDeviceDto {
    id: number;
    name: string | undefined;
    mac: string | undefined;
    isLocked: boolean;
    deviceTypeName: string | undefined;
    address: string | undefined;
    intranetIP: string | undefined;
    internetIP: string | undefined;
    description: string | undefined;
    /** 设备是否已被注册，如果已注册，另外的机器不能再注册. 同时管理员可以清空，允许其它设备进行注册. */
    isRegistered: boolean;
    licenseInfo: string | undefined;
    hardwareCode: string | undefined;
    shutdownTime: moment.Moment | undefined;
    resolution_Width: number;
    resolution_Height: number;
    /** 访问此设备的唯一凭证，通过Subkey可调用平台api，拿到设备相关的信息，如,ads,apps,products等.同时可用户注册. */
    subKey: string | undefined;
    os: string | undefined;
    onlineTrafficTarget: string | undefined;
    tenantName: string | undefined;
    tenantId: number;
    organizationUnitName: string | undefined;
    organizationUnitId: number;
    outType: string | undefined;
    taobaoDeviceId: string | undefined;
    osType: OsTypeEnum;
}

export enum DeviceType {
    Gateway = 0,
    Sensor = 1,
}

/** 派样机掉货时传入的入参对象 */
export class DropCargoInput implements IDropCargoInput {
    subkey!: string;
    /** 货道ID */
    cargoRoadId!: number;
    /** 货道物品ID */
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    /** 对应用户的动作记录ID */
    actionId!: number | undefined;

    constructor(data?: IDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.extensionData = _data["extensionData"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): DropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new DropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

/** 派样机掉货时传入的入参对象 */
export interface IDropCargoInput {
    subkey: string;
    /** 货道ID */
    cargoRoadId: number;
    /** 货道物品ID */
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    /** 对应用户的动作记录ID */
    actionId: number | undefined;
}

/** 交换货道商品时传入的入参对象 */
export class ExchangeCargoRoadSkuInput implements IExchangeCargoRoadSkuInput {
    /** 原始货道ID */
    sourceCargoRoadId!: number;
    /** 目标货道ID */
    targetCargoRoadId!: number;

    constructor(data?: IExchangeCargoRoadSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceCargoRoadId = _data["sourceCargoRoadId"];
            this.targetCargoRoadId = _data["targetCargoRoadId"];
        }
    }

    static fromJS(data: any): ExchangeCargoRoadSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeCargoRoadSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCargoRoadId"] = this.sourceCargoRoadId;
        data["targetCargoRoadId"] = this.targetCargoRoadId;
        return data; 
    }
}

/** 交换货道商品时传入的入参对象 */
export interface IExchangeCargoRoadSkuInput {
    /** 原始货道ID */
    sourceCargoRoadId: number;
    /** 目标货道ID */
    targetCargoRoadId: number;
}

export enum GatewayType {
    Passive = 0,
    Active = 1,
}

export class GetAgreementFileDto implements IGetAgreementFileDto {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;
    datas!: string[] | undefined;
    creationTime!: moment.Moment;
    fileName!: string | undefined;

    constructor(data?: IGetAgreementFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datas"])) {
                this.datas = [] as any;
                for (let item of _data["datas"])
                    this.datas!.push(item);
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): GetAgreementFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgreementFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datas)) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IGetAgreementFileDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
    datas: string[] | undefined;
    creationTime: moment.Moment;
    fileName: string | undefined;
}

export class GetAgreementsDto implements IGetAgreementsDto {
    id!: number;
    name!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAgreementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAgreementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgreementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IGetAgreementsDto {
    id: number;
    name: string | undefined;
    description: string | undefined;
}

export class GetAgreementsDtoPagedResultDto implements IGetAgreementsDtoPagedResultDto {
    totalCount!: number;
    items!: GetAgreementsDto[] | undefined;

    constructor(data?: IGetAgreementsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAgreementsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAgreementsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgreementsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAgreementsDtoPagedResultDto {
    totalCount: number;
    items: GetAgreementsDto[] | undefined;
}

/** 通过网关获取子设备时返回的子设备对象 */
export class GetChildDevicesDto implements IGetChildDevicesDto {
    /** 设备ID */
    id!: number;
    /** 设备名称 */
    name!: string | undefined;
    /** Mac地址 */
    mac!: string | undefined;
    /** 设备类型ID. */
    deviceTypeId!: number | undefined;
    /** 租户ID */
    tenantId!: number | undefined;
    /** 店铺ID */
    storeId!: number | undefined;
    /** 硬件编号 */
    hardwareCode!: string | undefined;
    /** Customize image to understand well. e.g Snapshot for Image. */
    outerId!: string | undefined;

    constructor(data?: IGetChildDevicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.deviceTypeId = _data["deviceTypeId"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.hardwareCode = _data["hardwareCode"];
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): GetChildDevicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetChildDevicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["deviceTypeId"] = this.deviceTypeId;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["hardwareCode"] = this.hardwareCode;
        data["outerId"] = this.outerId;
        return data; 
    }
}

/** 通过网关获取子设备时返回的子设备对象 */
export interface IGetChildDevicesDto {
    /** 设备ID */
    id: number;
    /** 设备名称 */
    name: string | undefined;
    /** Mac地址 */
    mac: string | undefined;
    /** 设备类型ID. */
    deviceTypeId: number | undefined;
    /** 租户ID */
    tenantId: number | undefined;
    /** 店铺ID */
    storeId: number | undefined;
    /** 硬件编号 */
    hardwareCode: string | undefined;
    /** Customize image to understand well. e.g Snapshot for Image. */
    outerId: string | undefined;
}

export class GetChildDevicesDtoPagedResultDto implements IGetChildDevicesDtoPagedResultDto {
    totalCount!: number;
    items!: GetChildDevicesDto[] | undefined;

    constructor(data?: IGetChildDevicesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetChildDevicesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetChildDevicesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetChildDevicesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetChildDevicesDtoPagedResultDto {
    totalCount: number;
    items: GetChildDevicesDto[] | undefined;
}

/** 获取客流摄像头或传感器计数器时返回的对象 */
export class GetCounerInfoDto implements IGetCounerInfoDto {
    childDeviceId!: number;
    tenantId!: number;
    counterName!: string | undefined;
    description!: string | undefined;
    totalCount!: number;
    counterTagInfoDto!: GetDeviceCounterTagInfoDto[] | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGetCounerInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.childDeviceId = _data["childDeviceId"];
            this.tenantId = _data["tenantId"];
            this.counterName = _data["counterName"];
            this.description = _data["description"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["counterTagInfoDto"])) {
                this.counterTagInfoDto = [] as any;
                for (let item of _data["counterTagInfoDto"])
                    this.counterTagInfoDto!.push(GetDeviceCounterTagInfoDto.fromJS(item));
            }
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetCounerInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCounerInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childDeviceId"] = this.childDeviceId;
        data["tenantId"] = this.tenantId;
        data["counterName"] = this.counterName;
        data["description"] = this.description;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.counterTagInfoDto)) {
            data["counterTagInfoDto"] = [];
            for (let item of this.counterTagInfoDto)
                data["counterTagInfoDto"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

/** 获取客流摄像头或传感器计数器时返回的对象 */
export interface IGetCounerInfoDto {
    childDeviceId: number;
    tenantId: number;
    counterName: string | undefined;
    description: string | undefined;
    totalCount: number;
    counterTagInfoDto: GetDeviceCounterTagInfoDto[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 工业报表获取传感器采集数据记录的返回对象 */
export class GetDatasDto implements IGetDatasDto {
    /** 总数量 */
    totalCount!: number;
    /** 正常数据数量 */
    normalCount!: number;
    /** 异常数据数量 */
    abnormalCount!: number;
    /** 数据记录明细 */
    dataRecords!: DataRecordDto[] | undefined;
    /** 正常数据记录明细 */
    dataRecordsNormal!: DataRecordDto[] | undefined;
    /** 异常数据记录明细 */
    dataRecordsAbnormal!: DataRecordDto[] | undefined;

    constructor(data?: IGetDatasDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.normalCount = _data["normalCount"];
            this.abnormalCount = _data["abnormalCount"];
            if (Array.isArray(_data["dataRecords"])) {
                this.dataRecords = [] as any;
                for (let item of _data["dataRecords"])
                    this.dataRecords!.push(DataRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["dataRecordsNormal"])) {
                this.dataRecordsNormal = [] as any;
                for (let item of _data["dataRecordsNormal"])
                    this.dataRecordsNormal!.push(DataRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["dataRecordsAbnormal"])) {
                this.dataRecordsAbnormal = [] as any;
                for (let item of _data["dataRecordsAbnormal"])
                    this.dataRecordsAbnormal!.push(DataRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDatasDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDatasDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["normalCount"] = this.normalCount;
        data["abnormalCount"] = this.abnormalCount;
        if (Array.isArray(this.dataRecords)) {
            data["dataRecords"] = [];
            for (let item of this.dataRecords)
                data["dataRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.dataRecordsNormal)) {
            data["dataRecordsNormal"] = [];
            for (let item of this.dataRecordsNormal)
                data["dataRecordsNormal"].push(item.toJSON());
        }
        if (Array.isArray(this.dataRecordsAbnormal)) {
            data["dataRecordsAbnormal"] = [];
            for (let item of this.dataRecordsAbnormal)
                data["dataRecordsAbnormal"].push(item.toJSON());
        }
        return data; 
    }
}

/** 工业报表获取传感器采集数据记录的返回对象 */
export interface IGetDatasDto {
    /** 总数量 */
    totalCount: number;
    /** 正常数据数量 */
    normalCount: number;
    /** 异常数据数量 */
    abnormalCount: number;
    /** 数据记录明细 */
    dataRecords: DataRecordDto[] | undefined;
    /** 正常数据记录明细 */
    dataRecordsNormal: DataRecordDto[] | undefined;
    /** 异常数据记录明细 */
    dataRecordsAbnormal: DataRecordDto[] | undefined;
}

/** 获取客流摄像头计数器数据报表时返回的对象 */
export class GetDeviceCounterChartDto implements IGetDeviceCounterChartDto {
    /** 图表标题 */
    title!: string | undefined;
    /** 图标中所有数据集合 */
    chartItems!: ChartItem[] | undefined;

    constructor(data?: IGetDeviceCounterChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["chartItems"])) {
                this.chartItems = [] as any;
                for (let item of _data["chartItems"])
                    this.chartItems!.push(ChartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceCounterChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.chartItems)) {
            data["chartItems"] = [];
            for (let item of this.chartItems)
                data["chartItems"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取客流摄像头计数器数据报表时返回的对象 */
export interface IGetDeviceCounterChartDto {
    /** 图表标题 */
    title: string | undefined;
    /** 图标中所有数据集合 */
    chartItems: ChartItem[] | undefined;
}

/** 获取设备计数器信息时返回的对象 */
export class GetDeviceCounterDto implements IGetDeviceCounterDto {
    id!: number;
    counterName!: string | undefined;
    displayName!: string | undefined;
    creationTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    totalCount!: number;
    tags!: GetDeviceCounterTagInfoDto[] | undefined;

    constructor(data?: IGetDeviceCounterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.counterName = _data["counterName"];
            this.displayName = _data["displayName"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(GetDeviceCounterTagInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceCounterDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["counterName"] = this.counterName;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取设备计数器信息时返回的对象 */
export interface IGetDeviceCounterDto {
    id: number;
    counterName: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    totalCount: number;
    tags: GetDeviceCounterTagInfoDto[] | undefined;
}

export class GetDeviceCounterDtoPagedResultDto implements IGetDeviceCounterDtoPagedResultDto {
    totalCount!: number;
    items!: GetDeviceCounterDto[] | undefined;

    constructor(data?: IGetDeviceCounterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDeviceCounterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDeviceCounterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetDeviceCounterDtoPagedResultDto {
    totalCount: number;
    items: GetDeviceCounterDto[] | undefined;
}

/** 获取计数器分组时返回的对象 */
export class GetDeviceCounterGroupDto implements IGetDeviceCounterGroupDto {
    id!: number;
    tenantId!: number;
    storeId!: number;
    groupName!: string | undefined;
    memberCount!: number;
    creationTime!: moment.Moment;

    constructor(data?: IGetDeviceCounterGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.groupName = _data["groupName"];
            this.memberCount = _data["memberCount"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDeviceCounterGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["groupName"] = this.groupName;
        data["memberCount"] = this.memberCount;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

/** 获取计数器分组时返回的对象 */
export interface IGetDeviceCounterGroupDto {
    id: number;
    tenantId: number;
    storeId: number;
    groupName: string | undefined;
    memberCount: number;
    creationTime: moment.Moment;
}

/** 获取设备计数器标签信息时返回的对象 */
export class GetDeviceCounterTagInfoDto implements IGetDeviceCounterTagInfoDto {
    tagId!: number;
    value!: string | undefined;

    constructor(data?: IGetDeviceCounterTagInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetDeviceCounterTagInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceCounterTagInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["value"] = this.value;
        return data; 
    }
}

/** 获取设备计数器标签信息时返回的对象 */
export interface IGetDeviceCounterTagInfoDto {
    tagId: number;
    value: string | undefined;
}

export class GetDeviceInfoDto implements IGetDeviceInfoDto {
    /** 客流摄像头设备ID */
    id!: number;
    /** 客流摄像头设备名称 */
    deviceName!: string | undefined;

    constructor(data?: IGetDeviceInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceName = _data["deviceName"];
        }
    }

    static fromJS(data: any): GetDeviceInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceName"] = this.deviceName;
        return data; 
    }
}

export interface IGetDeviceInfoDto {
    /** 客流摄像头设备ID */
    id: number;
    /** 客流摄像头设备名称 */
    deviceName: string | undefined;
}

/** 获取网关设备详细信息时的返回对象 */
export class GetGatewayInfoDto implements IGetGatewayInfoDto {
    /** 网关ID */
    gatewayId!: number;
    /** 网关名称 */
    gatewayName!: string | undefined;
    /** 网关类型，主动式和被动式 */
    type!: string | undefined;
    thingId!: string | undefined;
    orderNumber!: number | undefined;

    constructor(data?: IGetGatewayInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.gatewayName = _data["gatewayName"];
            this.type = _data["type"];
            this.thingId = _data["thingId"];
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): GetGatewayInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGatewayInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["gatewayName"] = this.gatewayName;
        data["type"] = this.type;
        data["thingId"] = this.thingId;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

/** 获取网关设备详细信息时的返回对象 */
export interface IGetGatewayInfoDto {
    /** 网关ID */
    gatewayId: number;
    /** 网关名称 */
    gatewayName: string | undefined;
    /** 网关类型，主动式和被动式 */
    type: string | undefined;
    thingId: string | undefined;
    orderNumber: number | undefined;
}

/** 获取网关或传感器扩展信息时返回的对象 */
export class GetGatewayOrSensorDto implements IGetGatewayOrSensorDto {
    gatewayId!: number | undefined;
    id!: number;
    deviceId!: number;
    address!: number | undefined;
    command!: string | undefined;
    agreementId!: number | undefined;
    deviceType!: DeviceType;
    gatewayType!: GatewayType;
    pollingTime!: number | undefined;

    constructor(data?: IGetGatewayOrSensorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayId = _data["gatewayId"];
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.address = _data["address"];
            this.command = _data["command"];
            this.agreementId = _data["agreementId"];
            this.deviceType = _data["deviceType"];
            this.gatewayType = _data["gatewayType"];
            this.pollingTime = _data["pollingTime"];
        }
    }

    static fromJS(data: any): GetGatewayOrSensorDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGatewayOrSensorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayId"] = this.gatewayId;
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["address"] = this.address;
        data["command"] = this.command;
        data["agreementId"] = this.agreementId;
        data["deviceType"] = this.deviceType;
        data["gatewayType"] = this.gatewayType;
        data["pollingTime"] = this.pollingTime;
        return data; 
    }
}

/** 获取网关或传感器扩展信息时返回的对象 */
export interface IGetGatewayOrSensorDto {
    gatewayId: number | undefined;
    id: number;
    deviceId: number;
    address: number | undefined;
    command: string | undefined;
    agreementId: number | undefined;
    deviceType: DeviceType;
    gatewayType: GatewayType;
    pollingTime: number | undefined;
}

/** 获取店铺客流昨天和今天数据时返回的对象 */
export class GetGuestChartDto implements IGetGuestChartDto {
    key!: string[] | undefined;
    value!: number[] | undefined;
    today!: number;
    yesterday!: number;

    constructor(data?: IGetGuestChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            this.today = _data["today"];
            this.yesterday = _data["yesterday"];
        }
    }

    static fromJS(data: any): GetGuestChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGuestChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        data["today"] = this.today;
        data["yesterday"] = this.yesterday;
        return data; 
    }
}

/** 获取店铺客流昨天和今天数据时返回的对象 */
export interface IGetGuestChartDto {
    key: string[] | undefined;
    value: number[] | undefined;
    today: number;
    yesterday: number;
}

export class GetReportDataDto implements IGetReportDataDto {
    /** 数据名称 */
    name!: string | undefined;
    calculateType!: CalculateType;
    /** 合并计算的计数器标签数组 */
    counterTags!: GetDeviceCounterTagInfoDto[] | undefined;
    /** 合并计算的客流摄像头信息 */
    deviceInfos!: GetDeviceInfoDto[] | undefined;

    constructor(data?: IGetReportDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.calculateType = _data["calculateType"];
            if (Array.isArray(_data["counterTags"])) {
                this.counterTags = [] as any;
                for (let item of _data["counterTags"])
                    this.counterTags!.push(GetDeviceCounterTagInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["deviceInfos"])) {
                this.deviceInfos = [] as any;
                for (let item of _data["deviceInfos"])
                    this.deviceInfos!.push(GetDeviceInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReportDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["calculateType"] = this.calculateType;
        if (Array.isArray(this.counterTags)) {
            data["counterTags"] = [];
            for (let item of this.counterTags)
                data["counterTags"].push(item.toJSON());
        }
        if (Array.isArray(this.deviceInfos)) {
            data["deviceInfos"] = [];
            for (let item of this.deviceInfos)
                data["deviceInfos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReportDataDto {
    /** 数据名称 */
    name: string | undefined;
    calculateType: CalculateType;
    /** 合并计算的计数器标签数组 */
    counterTags: GetDeviceCounterTagInfoDto[] | undefined;
    /** 合并计算的客流摄像头信息 */
    deviceInfos: GetDeviceInfoDto[] | undefined;
}

/** 获取自定义报表详细信息时的返回对象 */
export class GetReportDetailDto implements IGetReportDetailDto {
    /** 报表图中的数据 */
    reportDatas!: GetReportDataDto[] | undefined;
    /** 报表ID */
    id!: number;
    /** 租户ID */
    tenantId!: number;
    /** 店铺ID */
    storeId!: number | undefined;
    reportDataType!: ReportDataType;
    /** 报表名称 */
    name!: string | undefined;
    /** 报表模板ID */
    reportTemplateID!: number;
    /** 报表模板名称 */
    reportTemplateName!: string | undefined;
    reportTemplate!: GetReportTemplateDto;
    externalDataId!: number | undefined;
    description!: string | undefined;
    calcFormat!: string | undefined;
    orderSequece!: number;
    multiToOneName!: string | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;

    constructor(data?: IGetReportDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportDatas"])) {
                this.reportDatas = [] as any;
                for (let item of _data["reportDatas"])
                    this.reportDatas!.push(GetReportDataDto.fromJS(item));
            }
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.reportTemplateName = _data["reportTemplateName"];
            this.reportTemplate = _data["reportTemplate"] ? GetReportTemplateDto.fromJS(_data["reportTemplate"]) : <any>undefined;
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
        }
    }

    static fromJS(data: any): GetReportDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportDatas)) {
            data["reportDatas"] = [];
            for (let item of this.reportDatas)
                data["reportDatas"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["reportTemplateName"] = this.reportTemplateName;
        data["reportTemplate"] = this.reportTemplate ? this.reportTemplate.toJSON() : <any>undefined;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        return data; 
    }
}

/** 获取自定义报表详细信息时的返回对象 */
export interface IGetReportDetailDto {
    /** 报表图中的数据 */
    reportDatas: GetReportDataDto[] | undefined;
    /** 报表ID */
    id: number;
    /** 租户ID */
    tenantId: number;
    /** 店铺ID */
    storeId: number | undefined;
    reportDataType: ReportDataType;
    /** 报表名称 */
    name: string | undefined;
    /** 报表模板ID */
    reportTemplateID: number;
    /** 报表模板名称 */
    reportTemplateName: string | undefined;
    reportTemplate: GetReportTemplateDto;
    externalDataId: number | undefined;
    description: string | undefined;
    calcFormat: string | undefined;
    orderSequece: number;
    multiToOneName: string | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
}

/** 获取自定义报表列表时返回的对象，是Host操作的接口 */
export class GetReportDto implements IGetReportDto {
    /** 报表ID */
    id!: number;
    /** 租户ID */
    tenantId!: number;
    /** 店铺ID */
    storeId!: number | undefined;
    reportDataType!: ReportDataType;
    /** 报表名称 */
    name!: string | undefined;
    /** 报表模板ID */
    reportTemplateID!: number;
    /** 报表模板名称 */
    reportTemplateName!: string | undefined;
    reportTemplate!: GetReportTemplateDto;
    externalDataId!: number | undefined;
    description!: string | undefined;
    calcFormat!: string | undefined;
    orderSequece!: number;
    multiToOneName!: string | undefined;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;

    constructor(data?: IGetReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.storeId = _data["storeId"];
            this.reportDataType = _data["reportDataType"];
            this.name = _data["name"];
            this.reportTemplateID = _data["reportTemplateID"];
            this.reportTemplateName = _data["reportTemplateName"];
            this.reportTemplate = _data["reportTemplate"] ? GetReportTemplateDto.fromJS(_data["reportTemplate"]) : <any>undefined;
            this.externalDataId = _data["externalDataId"];
            this.description = _data["description"];
            this.calcFormat = _data["calcFormat"];
            this.orderSequece = _data["orderSequece"];
            this.multiToOneName = _data["multiToOneName"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
        }
    }

    static fromJS(data: any): GetReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["reportDataType"] = this.reportDataType;
        data["name"] = this.name;
        data["reportTemplateID"] = this.reportTemplateID;
        data["reportTemplateName"] = this.reportTemplateName;
        data["reportTemplate"] = this.reportTemplate ? this.reportTemplate.toJSON() : <any>undefined;
        data["externalDataId"] = this.externalDataId;
        data["description"] = this.description;
        data["calcFormat"] = this.calcFormat;
        data["orderSequece"] = this.orderSequece;
        data["multiToOneName"] = this.multiToOneName;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        return data; 
    }
}

/** 获取自定义报表列表时返回的对象，是Host操作的接口 */
export interface IGetReportDto {
    /** 报表ID */
    id: number;
    /** 租户ID */
    tenantId: number;
    /** 店铺ID */
    storeId: number | undefined;
    reportDataType: ReportDataType;
    /** 报表名称 */
    name: string | undefined;
    /** 报表模板ID */
    reportTemplateID: number;
    /** 报表模板名称 */
    reportTemplateName: string | undefined;
    reportTemplate: GetReportTemplateDto;
    externalDataId: number | undefined;
    description: string | undefined;
    calcFormat: string | undefined;
    orderSequece: number;
    multiToOneName: string | undefined;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
}

export class GetReportDtoPagedResultDto implements IGetReportDtoPagedResultDto {
    totalCount!: number;
    items!: GetReportDto[] | undefined;

    constructor(data?: IGetReportDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReportDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReportDtoPagedResultDto {
    totalCount: number;
    items: GetReportDto[] | undefined;
}

/** 获取报表模板列表时的返回对象 */
export class GetReportTemplateDto implements IGetReportTemplateDto {
    /** 报表模板ID */
    id!: number;
    /** 模板名称 */
    name!: string | undefined;
    counterTagRules!: CounterTagRules;
    deviceTagRules!: CounterTagRules;
    reportType!: ReportType;
    /** 是否有扩展数据 */
    isNeedExternalData!: boolean;
    description!: string | undefined;
    maxReportDataCount!: number;
    minReportDataCount!: number;
    canChangeReportDataName!: boolean;
    canMultiToOne!: boolean;
    reportDataNames!: string | undefined;
    calcFormat!: string | undefined;
    multiToOneName!: string | undefined;
    reportCompareType!: ReportCompareType;
    moleculeTitle!: string | undefined;
    denominatorTitle!: string | undefined;
    isShowMolecule!: boolean;
    isShowDenominator!: boolean;
    canChangeDigitTitle!: boolean;
    privilege!: string | undefined;
    moleculeBackGroudClassName!: string | undefined;
    moleculeIconClassName!: string | undefined;
    denominatorBackGroudClassName!: string | undefined;
    denominatorIconClassName!: string | undefined;

    constructor(data?: IGetReportTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.counterTagRules = _data["counterTagRules"];
            this.deviceTagRules = _data["deviceTagRules"];
            this.reportType = _data["reportType"];
            this.isNeedExternalData = _data["isNeedExternalData"];
            this.description = _data["description"];
            this.maxReportDataCount = _data["maxReportDataCount"];
            this.minReportDataCount = _data["minReportDataCount"];
            this.canChangeReportDataName = _data["canChangeReportDataName"];
            this.canMultiToOne = _data["canMultiToOne"];
            this.reportDataNames = _data["reportDataNames"];
            this.calcFormat = _data["calcFormat"];
            this.multiToOneName = _data["multiToOneName"];
            this.reportCompareType = _data["reportCompareType"];
            this.moleculeTitle = _data["moleculeTitle"];
            this.denominatorTitle = _data["denominatorTitle"];
            this.isShowMolecule = _data["isShowMolecule"];
            this.isShowDenominator = _data["isShowDenominator"];
            this.canChangeDigitTitle = _data["canChangeDigitTitle"];
            this.privilege = _data["privilege"];
            this.moleculeBackGroudClassName = _data["moleculeBackGroudClassName"];
            this.moleculeIconClassName = _data["moleculeIconClassName"];
            this.denominatorBackGroudClassName = _data["denominatorBackGroudClassName"];
            this.denominatorIconClassName = _data["denominatorIconClassName"];
        }
    }

    static fromJS(data: any): GetReportTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["counterTagRules"] = this.counterTagRules;
        data["deviceTagRules"] = this.deviceTagRules;
        data["reportType"] = this.reportType;
        data["isNeedExternalData"] = this.isNeedExternalData;
        data["description"] = this.description;
        data["maxReportDataCount"] = this.maxReportDataCount;
        data["minReportDataCount"] = this.minReportDataCount;
        data["canChangeReportDataName"] = this.canChangeReportDataName;
        data["canMultiToOne"] = this.canMultiToOne;
        data["reportDataNames"] = this.reportDataNames;
        data["calcFormat"] = this.calcFormat;
        data["multiToOneName"] = this.multiToOneName;
        data["reportCompareType"] = this.reportCompareType;
        data["moleculeTitle"] = this.moleculeTitle;
        data["denominatorTitle"] = this.denominatorTitle;
        data["isShowMolecule"] = this.isShowMolecule;
        data["isShowDenominator"] = this.isShowDenominator;
        data["canChangeDigitTitle"] = this.canChangeDigitTitle;
        data["privilege"] = this.privilege;
        data["moleculeBackGroudClassName"] = this.moleculeBackGroudClassName;
        data["moleculeIconClassName"] = this.moleculeIconClassName;
        data["denominatorBackGroudClassName"] = this.denominatorBackGroudClassName;
        data["denominatorIconClassName"] = this.denominatorIconClassName;
        return data; 
    }
}

/** 获取报表模板列表时的返回对象 */
export interface IGetReportTemplateDto {
    /** 报表模板ID */
    id: number;
    /** 模板名称 */
    name: string | undefined;
    counterTagRules: CounterTagRules;
    deviceTagRules: CounterTagRules;
    reportType: ReportType;
    /** 是否有扩展数据 */
    isNeedExternalData: boolean;
    description: string | undefined;
    maxReportDataCount: number;
    minReportDataCount: number;
    canChangeReportDataName: boolean;
    canMultiToOne: boolean;
    reportDataNames: string | undefined;
    calcFormat: string | undefined;
    multiToOneName: string | undefined;
    reportCompareType: ReportCompareType;
    moleculeTitle: string | undefined;
    denominatorTitle: string | undefined;
    isShowMolecule: boolean;
    isShowDenominator: boolean;
    canChangeDigitTitle: boolean;
    privilege: string | undefined;
    moleculeBackGroudClassName: string | undefined;
    moleculeIconClassName: string | undefined;
    denominatorBackGroudClassName: string | undefined;
    denominatorIconClassName: string | undefined;
}

export class GetReportTemplateDtoPagedResultDto implements IGetReportTemplateDtoPagedResultDto {
    totalCount!: number;
    items!: GetReportTemplateDto[] | undefined;

    constructor(data?: IGetReportTemplateDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetReportTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetReportTemplateDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetReportTemplateDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetReportTemplateDtoPagedResultDto {
    totalCount: number;
    items: GetReportTemplateDto[] | undefined;
}

/** 获取网关下下一个添加的传感器的地址，默认取网关下设备总数+1 */
export class GetSensorAddressDto implements IGetSensorAddressDto {
    /** 传感器地址，一般是1-255之间的整数 */
    address!: number;
    gatewayType!: GatewayType;

    constructor(data?: IGetSensorAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.gatewayType = _data["gatewayType"];
        }
    }

    static fromJS(data: any): GetSensorAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSensorAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["gatewayType"] = this.gatewayType;
        return data; 
    }
}

/** 获取网关下下一个添加的传感器的地址，默认取网关下设备总数+1 */
export interface IGetSensorAddressDto {
    /** 传感器地址，一般是1-255之间的整数 */
    address: number;
    gatewayType: GatewayType;
}

/** 获取所有开关状态时返回的对象，适用于工业报表 */
export class GetSwitchStatusDto implements IGetSwitchStatusDto {
    /** 开关信息列表 */
    switches!: SwitchInfo[] | undefined;
    /** 操作日志记录 */
    operateRecords!: OperateRecord[] | undefined;

    constructor(data?: IGetSwitchStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["switches"])) {
                this.switches = [] as any;
                for (let item of _data["switches"])
                    this.switches!.push(SwitchInfo.fromJS(item));
            }
            if (Array.isArray(_data["operateRecords"])) {
                this.operateRecords = [] as any;
                for (let item of _data["operateRecords"])
                    this.operateRecords!.push(OperateRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSwitchStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSwitchStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.switches)) {
            data["switches"] = [];
            for (let item of this.switches)
                data["switches"].push(item.toJSON());
        }
        if (Array.isArray(this.operateRecords)) {
            data["operateRecords"] = [];
            for (let item of this.operateRecords)
                data["operateRecords"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取所有开关状态时返回的对象，适用于工业报表 */
export interface IGetSwitchStatusDto {
    /** 开关信息列表 */
    switches: SwitchInfo[] | undefined;
    /** 操作日志记录 */
    operateRecords: OperateRecord[] | undefined;
}

/** 获取物联网设备报警信息时的报警信息列表返回对象 */
export class GetWarnningRecordDto implements IGetWarnningRecordDto {
    /** 总报警数量 */
    totalCount!: number;
    /** 未处理报警数量 */
    unHandledCount!: number;
    /** 已处理报警数量 */
    handledCount!: number;
    /** 报警信息列表 */
    warnningRecords!: WarnningRecordDto[] | undefined;
    /** 已处理报警信息列表 */
    warnningRecordsHandled!: WarnningRecordDto[] | undefined;
    /** 未处理报警信息列表 */
    warnningRecordsUnHandled!: WarnningRecordDto[] | undefined;

    constructor(data?: IGetWarnningRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.unHandledCount = _data["unHandledCount"];
            this.handledCount = _data["handledCount"];
            if (Array.isArray(_data["warnningRecords"])) {
                this.warnningRecords = [] as any;
                for (let item of _data["warnningRecords"])
                    this.warnningRecords!.push(WarnningRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["warnningRecordsHandled"])) {
                this.warnningRecordsHandled = [] as any;
                for (let item of _data["warnningRecordsHandled"])
                    this.warnningRecordsHandled!.push(WarnningRecordDto.fromJS(item));
            }
            if (Array.isArray(_data["warnningRecordsUnHandled"])) {
                this.warnningRecordsUnHandled = [] as any;
                for (let item of _data["warnningRecordsUnHandled"])
                    this.warnningRecordsUnHandled!.push(WarnningRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWarnningRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarnningRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["unHandledCount"] = this.unHandledCount;
        data["handledCount"] = this.handledCount;
        if (Array.isArray(this.warnningRecords)) {
            data["warnningRecords"] = [];
            for (let item of this.warnningRecords)
                data["warnningRecords"].push(item.toJSON());
        }
        if (Array.isArray(this.warnningRecordsHandled)) {
            data["warnningRecordsHandled"] = [];
            for (let item of this.warnningRecordsHandled)
                data["warnningRecordsHandled"].push(item.toJSON());
        }
        if (Array.isArray(this.warnningRecordsUnHandled)) {
            data["warnningRecordsUnHandled"] = [];
            for (let item of this.warnningRecordsUnHandled)
                data["warnningRecordsUnHandled"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取物联网设备报警信息时的报警信息列表返回对象 */
export interface IGetWarnningRecordDto {
    /** 总报警数量 */
    totalCount: number;
    /** 未处理报警数量 */
    unHandledCount: number;
    /** 已处理报警数量 */
    handledCount: number;
    /** 报警信息列表 */
    warnningRecords: WarnningRecordDto[] | undefined;
    /** 已处理报警信息列表 */
    warnningRecordsHandled: WarnningRecordDto[] | undefined;
    /** 未处理报警信息列表 */
    warnningRecordsUnHandled: WarnningRecordDto[] | undefined;
}

export enum HandlerStatus {
    UnHandled = 0,
    Handled = 1,
    Ignored = 2,
    AutoRecover = 3,
}

export class IdOuterIdValueDto implements IIdOuterIdValueDto {
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: IIdOuterIdValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdOuterIdValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdOuterIdValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIdOuterIdValueDto {
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    name: string | undefined;
    value: string | undefined;
}

/** 获取工业数据报表时的返回对象 */
export class IndustryCurentDataReportDto implements IIndustryCurentDataReportDto {
    /** 数据ID */
    counterId!: number;
    /** 数据名称 */
    counterName!: string | undefined;
    /** 数据值 */
    data!: number;
    /** 一级报警上限值 */
    upLimit1!: number | undefined;
    /** 二级报警上限值 */
    upLimit2!: number | undefined;
    /** 三级报警上限值 */
    upLimit3!: number | undefined;
    /** 一级报警下限值 */
    downLimit1!: number | undefined;
    /** 二级报警下限值 */
    downLimit2!: number | undefined;
    /** 三级报警下限值 */
    downLimit3!: number | undefined;

    constructor(data?: IIndustryCurentDataReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counterId = _data["counterId"];
            this.counterName = _data["counterName"];
            this.data = _data["data"];
            this.upLimit1 = _data["upLimit1"];
            this.upLimit2 = _data["upLimit2"];
            this.upLimit3 = _data["upLimit3"];
            this.downLimit1 = _data["downLimit1"];
            this.downLimit2 = _data["downLimit2"];
            this.downLimit3 = _data["downLimit3"];
        }
    }

    static fromJS(data: any): IndustryCurentDataReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryCurentDataReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counterId"] = this.counterId;
        data["counterName"] = this.counterName;
        data["data"] = this.data;
        data["upLimit1"] = this.upLimit1;
        data["upLimit2"] = this.upLimit2;
        data["upLimit3"] = this.upLimit3;
        data["downLimit1"] = this.downLimit1;
        data["downLimit2"] = this.downLimit2;
        data["downLimit3"] = this.downLimit3;
        return data; 
    }
}

/** 获取工业数据报表时的返回对象 */
export interface IIndustryCurentDataReportDto {
    /** 数据ID */
    counterId: number;
    /** 数据名称 */
    counterName: string | undefined;
    /** 数据值 */
    data: number;
    /** 一级报警上限值 */
    upLimit1: number | undefined;
    /** 二级报警上限值 */
    upLimit2: number | undefined;
    /** 三级报警上限值 */
    upLimit3: number | undefined;
    /** 一级报警下限值 */
    downLimit1: number | undefined;
    /** 二级报警下限值 */
    downLimit2: number | undefined;
    /** 三级报警下限值 */
    downLimit3: number | undefined;
}

export class Int64IdNameDto implements IInt64IdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IInt64IdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Int64IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt64IdNameDto {
    id: number;
    name: string | undefined;
}

export class LayerDto implements ILayerDto {
    /** 层Id */
    layerId!: number;
    /** 当前层的货道，一个层可以有多个货道 */
    cargoRoads!: ShelfCargoRoadDto[] | undefined;
    /** 当前层的层高，该设备的每个层的层高可以不一样 */
    layerHeight!: number;
    /** 当前层的起始高度 */
    startPoint_Z!: number;
    /** Layer编号，自下而上，从1累加 */
    index!: number;
    /** 当前层的货道数量 */
    cargoRoadCount!: number;

    constructor(data?: ILayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layerId = _data["layerId"];
            if (Array.isArray(_data["cargoRoads"])) {
                this.cargoRoads = [] as any;
                for (let item of _data["cargoRoads"])
                    this.cargoRoads!.push(ShelfCargoRoadDto.fromJS(item));
            }
            this.layerHeight = _data["layerHeight"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.index = _data["index"];
            this.cargoRoadCount = _data["cargoRoadCount"];
        }
    }

    static fromJS(data: any): LayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layerId"] = this.layerId;
        if (Array.isArray(this.cargoRoads)) {
            data["cargoRoads"] = [];
            for (let item of this.cargoRoads)
                data["cargoRoads"].push(item.toJSON());
        }
        data["layerHeight"] = this.layerHeight;
        data["startPoint_Z"] = this.startPoint_Z;
        data["index"] = this.index;
        data["cargoRoadCount"] = this.cargoRoadCount;
        return data; 
    }
}

export interface ILayerDto {
    /** 层Id */
    layerId: number;
    /** 当前层的货道，一个层可以有多个货道 */
    cargoRoads: ShelfCargoRoadDto[] | undefined;
    /** 当前层的层高，该设备的每个层的层高可以不一样 */
    layerHeight: number;
    /** 当前层的起始高度 */
    startPoint_Z: number;
    /** Layer编号，自下而上，从1累加 */
    index: number;
    /** 当前层的货道数量 */
    cargoRoadCount: number;
}

export class LayerInput implements ILayerInput {
    /** 层ID */
    id!: number | undefined;
    /** 货道数量 */
    cargoRoadCount!: number;
    /** 层高 */
    layerHeight!: number;

    constructor(data?: ILayerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.cargoRoadCount = _data["cargoRoadCount"];
            this.layerHeight = _data["layerHeight"];
        }
    }

    static fromJS(data: any): LayerInput {
        data = typeof data === 'object' ? data : {};
        let result = new LayerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cargoRoadCount"] = this.cargoRoadCount;
        data["layerHeight"] = this.layerHeight;
        return data; 
    }
}

export interface ILayerInput {
    /** 层ID */
    id: number | undefined;
    /** 货道数量 */
    cargoRoadCount: number;
    /** 层高 */
    layerHeight: number;
}

export class MutipleDropCargoInput implements IMutipleDropCargoInput {
    /** 删除数量 */
    quantity!: number;
    subkey!: string;
    /** 货道ID */
    cargoRoadId!: number;
    /** 货道物品ID */
    cargoThingId!: number | undefined;
    extensionData!: string | undefined;
    /** 对应用户的动作记录ID */
    actionId!: number | undefined;

    constructor(data?: IMutipleDropCargoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
            this.subkey = _data["subkey"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.cargoThingId = _data["cargoThingId"];
            this.extensionData = _data["extensionData"];
            this.actionId = _data["actionId"];
        }
    }

    static fromJS(data: any): MutipleDropCargoInput {
        data = typeof data === 'object' ? data : {};
        let result = new MutipleDropCargoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["subkey"] = this.subkey;
        data["cargoRoadId"] = this.cargoRoadId;
        data["cargoThingId"] = this.cargoThingId;
        data["extensionData"] = this.extensionData;
        data["actionId"] = this.actionId;
        return data; 
    }
}

export interface IMutipleDropCargoInput {
    /** 删除数量 */
    quantity: number;
    subkey: string;
    /** 货道ID */
    cargoRoadId: number;
    /** 货道物品ID */
    cargoThingId: number | undefined;
    extensionData: string | undefined;
    /** 对应用户的动作记录ID */
    actionId: number | undefined;
}

export class OperateRecord implements IOperateRecord {
    /** 开关ID */
    switchId!: number;
    /** 开关名称 */
    switchName!: string | undefined;
    switchStatus!: SwitchStatus;
    /** 操作开始时间 */
    startTime!: moment.Moment;
    /** 触发当前动作时传感器采集的数值 */
    currentData!: number;
    /** 触发动作的限制值 */
    limitData!: number | undefined;
    /** 描述 */
    description!: string | undefined;
    controlType!: ControlType;
    /** 执行成功状态 */
    isSuccess!: boolean;

    constructor(data?: IOperateRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchId = _data["switchId"];
            this.switchName = _data["switchName"];
            this.switchStatus = _data["switchStatus"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.currentData = _data["currentData"];
            this.limitData = _data["limitData"];
            this.description = _data["description"];
            this.controlType = _data["controlType"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): OperateRecord {
        data = typeof data === 'object' ? data : {};
        let result = new OperateRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchId"] = this.switchId;
        data["switchName"] = this.switchName;
        data["switchStatus"] = this.switchStatus;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["currentData"] = this.currentData;
        data["limitData"] = this.limitData;
        data["description"] = this.description;
        data["controlType"] = this.controlType;
        data["isSuccess"] = this.isSuccess;
        return data; 
    }
}

export interface IOperateRecord {
    /** 开关ID */
    switchId: number;
    /** 开关名称 */
    switchName: string | undefined;
    switchStatus: SwitchStatus;
    /** 操作开始时间 */
    startTime: moment.Moment;
    /** 触发当前动作时传感器采集的数值 */
    currentData: number;
    /** 触发动作的限制值 */
    limitData: number | undefined;
    /** 描述 */
    description: string | undefined;
    controlType: ControlType;
    /** 执行成功状态 */
    isSuccess: boolean;
}

export enum OsTypeEnum {
    Windows = 0,
    Android = 1,
    IOS = 2,
    Linux = 3,
}

export class PostAgreementFileInput implements IPostAgreementFileInput {
    id!: number | undefined;
    name!: string | undefined;
    description!: string | undefined;
    datas!: string[] | undefined;
    postFile!: string | undefined;

    constructor(data?: IPostAgreementFileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["datas"])) {
                this.datas = [] as any;
                for (let item of _data["datas"])
                    this.datas!.push(item);
            }
            this.postFile = _data["postFile"];
        }
    }

    static fromJS(data: any): PostAgreementFileInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostAgreementFileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.datas)) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        data["postFile"] = this.postFile;
        return data; 
    }
}

export interface IPostAgreementFileInput {
    id: number | undefined;
    name: string | undefined;
    description: string | undefined;
    datas: string[] | undefined;
    postFile: string | undefined;
}

export class ReplenishCargoThingInput implements IReplenishCargoThingInput {
    /** 物品ID */
    thingId!: number;
    /** 补货数量 */
    stock!: number;

    constructor(data?: IReplenishCargoThingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): ReplenishCargoThingInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishCargoThingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["stock"] = this.stock;
        return data; 
    }
}

export interface IReplenishCargoThingInput {
    /** 物品ID */
    thingId: number;
    /** 补货数量 */
    stock: number;
}

export enum ReportCompareType {
    Day = 0,
    Week = 1,
    Month = 2,
}

export class ReportDataInput implements IReportDataInput {
    /** 扩展名称 */
    name!: string | undefined;
    calculateType!: CalculateType;
    /** 合并计算数据的计数器标签 */
    counterTags!: number[] | undefined;
    /** 合并计算数据的客流摄像头设备ID */
    deviceIds!: number[] | undefined;

    constructor(data?: IReportDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.calculateType = _data["calculateType"];
            if (Array.isArray(_data["counterTags"])) {
                this.counterTags = [] as any;
                for (let item of _data["counterTags"])
                    this.counterTags!.push(item);
            }
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ReportDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReportDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["calculateType"] = this.calculateType;
        if (Array.isArray(this.counterTags)) {
            data["counterTags"] = [];
            for (let item of this.counterTags)
                data["counterTags"].push(item);
        }
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        return data; 
    }
}

export interface IReportDataInput {
    /** 扩展名称 */
    name: string | undefined;
    calculateType: CalculateType;
    /** 合并计算数据的计数器标签 */
    counterTags: number[] | undefined;
    /** 合并计算数据的客流摄像头设备ID */
    deviceIds: number[] | undefined;
}

export enum ReportDataType {
    Counter = 0,
}

export enum ReportType {
    Line = 0,
    Pie = 1,
    Bar = 2,
    Circle = 3,
    Radar = 4,
    Polar = 5,
    Digit = 6,
}

export class SensorDto implements ISensorDto {
    /** 传感器Id */
    id!: number;
    /** 传感器名称 */
    name!: string | undefined;

    constructor(data?: ISensorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SensorDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ISensorDto {
    /** 传感器Id */
    id: number;
    /** 传感器名称 */
    name: string | undefined;
}

/** 给设备设置默认AppPod版本的入参 */
export class SetDefaultAppPodVersionInput implements ISetDefaultAppPodVersionInput {
    /** 设备ID */
    deviceId!: number;
    osType!: OsTypeEnum;

    constructor(data?: ISetDefaultAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.osType = _data["osType"];
        }
    }

    static fromJS(data: any): SetDefaultAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["osType"] = this.osType;
        return data; 
    }
}

/** 给设备设置默认AppPod版本的入参 */
export interface ISetDefaultAppPodVersionInput {
    /** 设备ID */
    deviceId: number;
    osType: OsTypeEnum;
}

export class ShelfCargoRoadDto implements IShelfCargoRoadDto {
    /** 货道Id */
    id!: number;
    /** 货道绑定的设备Id */
    deviceId!: number;
    cargoType!: CargoTypeEnum;
    /** 货道Id */
    cargoRoadId!: number;
    /** 货道的起始长度（货架左右有隔板） */
    startLength!: number;
    /** 绑定的传感器之类设备 */
    sensors!: SensorDto[] | undefined;
    /** 毛重 */
    grossWeight!: number;
    /** 货道名称，目前统一，系统生成 */
    name!: string | undefined;
    /** 货道编号，目前统一，系统生成 */
    outerId!: string | undefined;
    /** 货道是否启用 */
    isEnabled!: boolean;
    /** 库存容量 */
    stockCapacity!: number;
    /** 描述 */
    description!: string | undefined;
    /** 扩展字段 */
    extensionData!: string | undefined;
    /** 货道里的货物，若为顺序货道，仅有一条记录，若为随机货道，可能会有多条记录 */
    cargoThings!: CargoThingDto[] | undefined;
    /** 货道所处的层Id */
    layerId!: number | undefined;
    /** 货道长度 */
    resolution_Length!: number;
    /** 货道宽度 */
    resolution_Width!: number;
    /** 以货道当前层左下角为起始位置，货道位置离起点在X方向的距离 */
    startPoint_X!: number;
    /** 货道高度 */
    resolution_Height!: number;
    /** 以货道当前层左下角为起始位置，货道位置离起点在Z方向的距离 */
    startPoint_Z!: number;
    /** 跨行 */
    spanRows!: number;
    /** 跨列 */
    spanColumns!: number;

    constructor(data?: IShelfCargoRoadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.cargoType = _data["cargoType"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.startLength = _data["startLength"];
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(SensorDto.fromJS(item));
            }
            this.grossWeight = _data["grossWeight"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CargoThingDto.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.resolution_Width = _data["resolution_Width"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
        }
    }

    static fromJS(data: any): ShelfCargoRoadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfCargoRoadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["cargoType"] = this.cargoType;
        data["cargoRoadId"] = this.cargoRoadId;
        data["startLength"] = this.startLength;
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item.toJSON());
        }
        data["grossWeight"] = this.grossWeight;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["resolution_Width"] = this.resolution_Width;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        return data; 
    }
}

export interface IShelfCargoRoadDto {
    /** 货道Id */
    id: number;
    /** 货道绑定的设备Id */
    deviceId: number;
    cargoType: CargoTypeEnum;
    /** 货道Id */
    cargoRoadId: number;
    /** 货道的起始长度（货架左右有隔板） */
    startLength: number;
    /** 绑定的传感器之类设备 */
    sensors: SensorDto[] | undefined;
    /** 毛重 */
    grossWeight: number;
    /** 货道名称，目前统一，系统生成 */
    name: string | undefined;
    /** 货道编号，目前统一，系统生成 */
    outerId: string | undefined;
    /** 货道是否启用 */
    isEnabled: boolean;
    /** 库存容量 */
    stockCapacity: number;
    /** 描述 */
    description: string | undefined;
    /** 扩展字段 */
    extensionData: string | undefined;
    /** 货道里的货物，若为顺序货道，仅有一条记录，若为随机货道，可能会有多条记录 */
    cargoThings: CargoThingDto[] | undefined;
    /** 货道所处的层Id */
    layerId: number | undefined;
    /** 货道长度 */
    resolution_Length: number;
    /** 货道宽度 */
    resolution_Width: number;
    /** 以货道当前层左下角为起始位置，货道位置离起点在X方向的距离 */
    startPoint_X: number;
    /** 货道高度 */
    resolution_Height: number;
    /** 以货道当前层左下角为起始位置，货道位置离起点在Z方向的距离 */
    startPoint_Z: number;
    /** 跨行 */
    spanRows: number;
    /** 跨列 */
    spanColumns: number;
}

/** 获取货架详细信息时的返回对象 */
export class ShelfDto implements IShelfDto {
    /** 设备Id */
    id!: number;
    /** 设备名称 */
    name!: string | undefined;
    /** 设备MAC地址 */
    mac!: string | undefined;
    /** 设备是否锁定 */
    isLocked!: boolean;
    /** 设备类型名称 */
    deviceTypeName!: string | undefined;
    /** 设备地址 */
    address!: string | undefined;
    /** 描述字段 */
    description!: string | undefined;
    /** 硬件编码 */
    hardwareCode!: string | undefined;
    /** 关机时间 */
    shutdownTime!: moment.Moment | undefined;
    /** 以某一标准正方向设定的摆放角度 */
    shelfDirectionAngle!: number;
    /** X方向长度 */
    resolution_Length!: number;
    /** 以房间某个角落为起点，货架摆放位置离起点在X方向的距离 */
    startPoint_X!: number;
    /** Y方向长度 */
    resolution_Width!: number;
    /** 以房间某个角落为起点，货架摆放位置离起点在Y方向的距离 */
    startPoint_Y!: number;
    /** Z方向长度 */
    resolution_Height!: number;
    /** 设备Subkey */
    subKey!: string | undefined;
    /** 设备系统 */
    os!: string | undefined;
    /** 租户名称 */
    tenantName!: string | undefined;
    /** 租户Id */
    tenantId!: number;
    /** 组织机构名称 */
    organizationUnitName!: string | undefined;
    /** 组织机构Id */
    organizationUnitId!: number;
    outType!: string | undefined;
    /** 设备垫高 */
    footerHeight!: number;
    /** 隔板厚度 */
    outerPartitionHeight!: number;
    /** 层板厚度 */
    layerPartitionHeight!: number;
    /** 设备层,一个智能货架有多个层 */
    layers!: LayerDto[] | undefined;
    /** 智能货架里绑定的其他一些设备，包括条形屏等 */
    childDevices!: ChildDeviceDto[] | undefined;

    constructor(data?: IShelfDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.mac = _data["mac"];
            this.isLocked = _data["isLocked"];
            this.deviceTypeName = _data["deviceTypeName"];
            this.address = _data["address"];
            this.description = _data["description"];
            this.hardwareCode = _data["hardwareCode"];
            this.shutdownTime = _data["shutdownTime"] ? moment(_data["shutdownTime"].toString()) : <any>undefined;
            this.shelfDirectionAngle = _data["shelfDirectionAngle"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Width = _data["resolution_Width"];
            this.startPoint_Y = _data["startPoint_Y"];
            this.resolution_Height = _data["resolution_Height"];
            this.subKey = _data["subKey"];
            this.os = _data["os"];
            this.tenantName = _data["tenantName"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitName = _data["organizationUnitName"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.outType = _data["outType"];
            this.footerHeight = _data["footerHeight"];
            this.outerPartitionHeight = _data["outerPartitionHeight"];
            this.layerPartitionHeight = _data["layerPartitionHeight"];
            if (Array.isArray(_data["layers"])) {
                this.layers = [] as any;
                for (let item of _data["layers"])
                    this.layers!.push(LayerDto.fromJS(item));
            }
            if (Array.isArray(_data["childDevices"])) {
                this.childDevices = [] as any;
                for (let item of _data["childDevices"])
                    this.childDevices!.push(ChildDeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShelfDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["mac"] = this.mac;
        data["isLocked"] = this.isLocked;
        data["deviceTypeName"] = this.deviceTypeName;
        data["address"] = this.address;
        data["description"] = this.description;
        data["hardwareCode"] = this.hardwareCode;
        data["shutdownTime"] = this.shutdownTime ? this.shutdownTime.toISOString() : <any>undefined;
        data["shelfDirectionAngle"] = this.shelfDirectionAngle;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Width"] = this.resolution_Width;
        data["startPoint_Y"] = this.startPoint_Y;
        data["resolution_Height"] = this.resolution_Height;
        data["subKey"] = this.subKey;
        data["os"] = this.os;
        data["tenantName"] = this.tenantName;
        data["tenantId"] = this.tenantId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["organizationUnitId"] = this.organizationUnitId;
        data["outType"] = this.outType;
        data["footerHeight"] = this.footerHeight;
        data["outerPartitionHeight"] = this.outerPartitionHeight;
        data["layerPartitionHeight"] = this.layerPartitionHeight;
        if (Array.isArray(this.layers)) {
            data["layers"] = [];
            for (let item of this.layers)
                data["layers"].push(item.toJSON());
        }
        if (Array.isArray(this.childDevices)) {
            data["childDevices"] = [];
            for (let item of this.childDevices)
                data["childDevices"].push(item.toJSON());
        }
        return data; 
    }
}

/** 获取货架详细信息时的返回对象 */
export interface IShelfDto {
    /** 设备Id */
    id: number;
    /** 设备名称 */
    name: string | undefined;
    /** 设备MAC地址 */
    mac: string | undefined;
    /** 设备是否锁定 */
    isLocked: boolean;
    /** 设备类型名称 */
    deviceTypeName: string | undefined;
    /** 设备地址 */
    address: string | undefined;
    /** 描述字段 */
    description: string | undefined;
    /** 硬件编码 */
    hardwareCode: string | undefined;
    /** 关机时间 */
    shutdownTime: moment.Moment | undefined;
    /** 以某一标准正方向设定的摆放角度 */
    shelfDirectionAngle: number;
    /** X方向长度 */
    resolution_Length: number;
    /** 以房间某个角落为起点，货架摆放位置离起点在X方向的距离 */
    startPoint_X: number;
    /** Y方向长度 */
    resolution_Width: number;
    /** 以房间某个角落为起点，货架摆放位置离起点在Y方向的距离 */
    startPoint_Y: number;
    /** Z方向长度 */
    resolution_Height: number;
    /** 设备Subkey */
    subKey: string | undefined;
    /** 设备系统 */
    os: string | undefined;
    /** 租户名称 */
    tenantName: string | undefined;
    /** 租户Id */
    tenantId: number;
    /** 组织机构名称 */
    organizationUnitName: string | undefined;
    /** 组织机构Id */
    organizationUnitId: number;
    outType: string | undefined;
    /** 设备垫高 */
    footerHeight: number;
    /** 隔板厚度 */
    outerPartitionHeight: number;
    /** 层板厚度 */
    layerPartitionHeight: number;
    /** 设备层,一个智能货架有多个层 */
    layers: LayerDto[] | undefined;
    /** 智能货架里绑定的其他一些设备，包括条形屏等 */
    childDevices: ChildDeviceDto[] | undefined;
}

/** 获取货架商品简易信息时返回的对象 */
export class SimpleProductDto implements ISimpleProductDto {
    /** 商品ID */
    thingId!: number;
    type!: CargoType;
    /** 商品名称 */
    title!: string | undefined;
    /** 价格 */
    price!: number;
    /** 折扣价 */
    promPrice!: number | undefined;
    /** 主图 */
    picUrl!: string | undefined;
    /** 库存 */
    quantity!: number;
    description!: string | undefined;

    constructor(data?: ISimpleProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.picUrl = _data["picUrl"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SimpleProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["picUrl"] = this.picUrl;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        return data; 
    }
}

/** 获取货架商品简易信息时返回的对象 */
export interface ISimpleProductDto {
    /** 商品ID */
    thingId: number;
    type: CargoType;
    /** 商品名称 */
    title: string | undefined;
    /** 价格 */
    price: number;
    /** 折扣价 */
    promPrice: number | undefined;
    /** 主图 */
    picUrl: string | undefined;
    /** 库存 */
    quantity: number;
    description: string | undefined;
}

export class SwitchInfo implements ISwitchInfo {
    /** 开关ID */
    id!: number;
    /** 网关ID */
    gatewayId!: number;
    /** 开关名称 */
    name!: string | undefined;
    status!: SwitchStatus;

    constructor(data?: ISwitchInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gatewayId = _data["gatewayId"];
            this.name = _data["name"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SwitchInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gatewayId"] = this.gatewayId;
        data["name"] = this.name;
        data["status"] = this.status;
        return data; 
    }
}

export interface ISwitchInfo {
    /** 开关ID */
    id: number;
    /** 网关ID */
    gatewayId: number;
    /** 开关名称 */
    name: string | undefined;
    status: SwitchStatus;
}

export enum SwitchStatus {
    Off = 0,
    On = 1,
}

export class Tag implements ITag {
    value!: string;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITag {
    value: string;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDtoPagedResultDto implements ITagDtoPagedResultDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: ITagDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export enum TagType {
    Resource = 0,
    Device = 1,
    Product = 2,
    Ads = 3,
    Other = 4,
    Brand = 5,
    Question = 6,
    Counter = 7,
    WechatPublicMessage = 8,
}

/** 更新AppPod版本信息的入参 */
export class UpdateAppPodVersionInput implements IUpdateAppPodVersionInput {
    /** AppPod版本对应数据库记录Id */
    id!: number;
    /** 对应所属AppPod的数据库记录Id */
    appPodId!: number;
    /** 版本号 */
    version!: string;
    /** 描述 */
    description!: string | undefined;
    /** 下载地址 */
    downloadUrl!: string;
    /** 配置信息 */
    appSetting!: string | undefined;
    /** 文件MD5 */
    md5!: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart!: boolean;

    constructor(data?: IUpdateAppPodVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.appPodId = _data["appPodId"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.downloadUrl = _data["downloadUrl"];
            this.appSetting = _data["appSetting"];
            this.md5 = _data["md5"];
            this.isNeedRestart = _data["isNeedRestart"];
        }
    }

    static fromJS(data: any): UpdateAppPodVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppPodVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appPodId"] = this.appPodId;
        data["version"] = this.version;
        data["description"] = this.description;
        data["downloadUrl"] = this.downloadUrl;
        data["appSetting"] = this.appSetting;
        data["md5"] = this.md5;
        data["isNeedRestart"] = this.isNeedRestart;
        return data; 
    }
}

/** 更新AppPod版本信息的入参 */
export interface IUpdateAppPodVersionInput {
    /** AppPod版本对应数据库记录Id */
    id: number;
    /** 对应所属AppPod的数据库记录Id */
    appPodId: number;
    /** 版本号 */
    version: string;
    /** 描述 */
    description: string | undefined;
    /** 下载地址 */
    downloadUrl: string;
    /** 配置信息 */
    appSetting: string | undefined;
    /** 文件MD5 */
    md5: string | undefined;
    /** 设备更新后是否需要重启 */
    isNeedRestart: boolean;
}

/** 更新货道信息时的传入入参对象 */
export class UpdateCargoRoadsInput implements IUpdateCargoRoadsInput {
    /** 货道Id */
    id!: number;
    /** 所属货架设备ID */
    deviceId!: number;
    /** 货道名称 */
    name!: string;
    /** 货道快速识别号. */
    outerId!: string | undefined;
    /** 是否启用 */
    isEnabled!: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity!: number;
    /** 货道描述信息 */
    description!: string | undefined;
    /** 扩展信息，用于存储一些特殊属性信息 */
    extensionData!: string | undefined;
    /** 行数 */
    spanRows!: number;
    /** 列数 */
    spanColumns!: number;
    cargoType!: CargoTypeEnum;
    /** 存放物品信息 */
    cargoThings!: CreateCargoThingInput[] | undefined;
    /** 货架层ID */
    layerId!: number | undefined;
    /** 货道宽度 */
    resolution_Length!: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X!: number;
    /** 货道高度 */
    resolution_Height!: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z!: number;
    /** 货道标定的毛重 */
    grossWeight!: number;

    constructor(data?: IUpdateCargoRoadsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceId = _data["deviceId"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.isEnabled = _data["isEnabled"];
            this.stockCapacity = _data["stockCapacity"];
            this.description = _data["description"];
            this.extensionData = _data["extensionData"];
            this.spanRows = _data["spanRows"];
            this.spanColumns = _data["spanColumns"];
            this.cargoType = _data["cargoType"];
            if (Array.isArray(_data["cargoThings"])) {
                this.cargoThings = [] as any;
                for (let item of _data["cargoThings"])
                    this.cargoThings!.push(CreateCargoThingInput.fromJS(item));
            }
            this.layerId = _data["layerId"];
            this.resolution_Length = _data["resolution_Length"];
            this.startPoint_X = _data["startPoint_X"];
            this.resolution_Height = _data["resolution_Height"];
            this.startPoint_Z = _data["startPoint_Z"];
            this.grossWeight = _data["grossWeight"];
        }
    }

    static fromJS(data: any): UpdateCargoRoadsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoRoadsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["isEnabled"] = this.isEnabled;
        data["stockCapacity"] = this.stockCapacity;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["spanRows"] = this.spanRows;
        data["spanColumns"] = this.spanColumns;
        data["cargoType"] = this.cargoType;
        if (Array.isArray(this.cargoThings)) {
            data["cargoThings"] = [];
            for (let item of this.cargoThings)
                data["cargoThings"].push(item.toJSON());
        }
        data["layerId"] = this.layerId;
        data["resolution_Length"] = this.resolution_Length;
        data["startPoint_X"] = this.startPoint_X;
        data["resolution_Height"] = this.resolution_Height;
        data["startPoint_Z"] = this.startPoint_Z;
        data["grossWeight"] = this.grossWeight;
        return data; 
    }
}

/** 更新货道信息时的传入入参对象 */
export interface IUpdateCargoRoadsInput {
    /** 货道Id */
    id: number;
    /** 所属货架设备ID */
    deviceId: number;
    /** 货道名称 */
    name: string;
    /** 货道快速识别号. */
    outerId: string | undefined;
    /** 是否启用 */
    isEnabled: boolean;
    /** Cargo Road max Capacity. */
    stockCapacity: number;
    /** 货道描述信息 */
    description: string | undefined;
    /** 扩展信息，用于存储一些特殊属性信息 */
    extensionData: string | undefined;
    /** 行数 */
    spanRows: number;
    /** 列数 */
    spanColumns: number;
    cargoType: CargoTypeEnum;
    /** 存放物品信息 */
    cargoThings: CreateCargoThingInput[] | undefined;
    /** 货架层ID */
    layerId: number | undefined;
    /** 货道宽度 */
    resolution_Length: number;
    /** 以左边为0点，货道左边界到货架左边X方向的距离 */
    startPoint_X: number;
    /** 货道高度 */
    resolution_Height: number;
    /** 以底面为0点，货道底边界到货架底面Z方向的距离 */
    startPoint_Z: number;
    /** 货道标定的毛重 */
    grossWeight: number;
}

/** 更新货道状态时传入的入参对象 */
export class UpdateCargoStatusInput implements IUpdateCargoStatusInput {
    /** 货道状态集合 */
    cargoStatus!: CargoStatus[] | undefined;

    constructor(data?: IUpdateCargoStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cargoStatus"])) {
                this.cargoStatus = [] as any;
                for (let item of _data["cargoStatus"])
                    this.cargoStatus!.push(CargoStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCargoStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cargoStatus)) {
            data["cargoStatus"] = [];
            for (let item of this.cargoStatus)
                data["cargoStatus"].push(item.toJSON());
        }
        return data; 
    }
}

/** 更新货道状态时传入的入参对象 */
export interface IUpdateCargoStatusInput {
    /** 货道状态集合 */
    cargoStatus: CargoStatus[] | undefined;
}

export class UpdateCargoStockInput implements IUpdateCargoStockInput {
    subkey!: string;
    /** 补货货道信息列表 */
    cargoStocks!: CargoStock[] | undefined;

    constructor(data?: IUpdateCargoStockInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subkey = _data["subkey"];
            if (Array.isArray(_data["cargoStocks"])) {
                this.cargoStocks = [] as any;
                for (let item of _data["cargoStocks"])
                    this.cargoStocks!.push(CargoStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCargoStockInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCargoStockInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subkey"] = this.subkey;
        if (Array.isArray(this.cargoStocks)) {
            data["cargoStocks"] = [];
            for (let item of this.cargoStocks)
                data["cargoStocks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateCargoStockInput {
    subkey: string;
    /** 补货货道信息列表 */
    cargoStocks: CargoStock[] | undefined;
}

/** 更新计数器标签时的入参 */
export class UpdateDeviceCounterTagInput implements IUpdateDeviceCounterTagInput {
    /** 计数器ID数组 */
    counterIds!: number[] | undefined;
    /** 标签ID数组 */
    tagIds!: number[] | undefined;

    constructor(data?: IUpdateDeviceCounterTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["counterIds"])) {
                this.counterIds = [] as any;
                for (let item of _data["counterIds"])
                    this.counterIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateDeviceCounterTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceCounterTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.counterIds)) {
            data["counterIds"] = [];
            for (let item of this.counterIds)
                data["counterIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data; 
    }
}

/** 更新计数器标签时的入参 */
export interface IUpdateDeviceCounterTagInput {
    /** 计数器ID数组 */
    counterIds: number[] | undefined;
    /** 标签ID数组 */
    tagIds: number[] | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class WarnningRecordDto implements IWarnningRecordDto {
    /** 报警记录ID */
    id!: number;
    /** 记录时间 */
    collectionTime!: moment.Moment;
    /** 描述 */
    description!: string | undefined;
    handlerStatus!: HandlerStatus;

    constructor(data?: IWarnningRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.collectionTime = _data["collectionTime"] ? moment(_data["collectionTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.handlerStatus = _data["handlerStatus"];
        }
    }

    static fromJS(data: any): WarnningRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarnningRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["handlerStatus"] = this.handlerStatus;
        return data; 
    }
}

export interface IWarnningRecordDto {
    /** 报警记录ID */
    id: number;
    /** 记录时间 */
    collectionTime: moment.Moment;
    /** 描述 */
    description: string | undefined;
    handlerStatus: HandlerStatus;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}