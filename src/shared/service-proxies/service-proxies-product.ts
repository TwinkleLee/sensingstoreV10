/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.1.0 (NJsonSchema v10.3.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { DateTime } from 'luxon';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_PRODUCT_URL = new InjectionToken<string>('API_PRODUCT_URL');

@Injectable()
export class ApplyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取审核列表
     * @param type (optional) 
     * @param applyStatus (optional) 
     * @param start (optional) 
     * @param end (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyForms(type: string | undefined, applyStatus: string | undefined, start: moment.Moment | undefined, end: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ApplyFormDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyForms?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (applyStatus === null)
            throw new Error("The parameter 'applyStatus' cannot be null.");
        else if (applyStatus !== undefined)
            url_ += "ApplyStatus=" + encodeURIComponent("" + applyStatus) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "Start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "End=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyForms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyForms(<any>response_);
                } catch (e) {
                    return <Observable<ApplyFormDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplyFormDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyForms(response: HttpResponseBase): Observable<ApplyFormDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplyFormDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplyFormDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建审核表单
     * @param body (optional) 
     * @return Success
     */
    createApplyForm(body: CreateApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/CreateApplyForm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplyForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplyForm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplyForm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 完成审核
     * @param body (optional) 审批结果信息
     * @return Success
     */
    audit(body: AuditApplyFormInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Apply/Audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAudit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取审核详情
     * @param appFormId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplyFormDetails(appFormId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IdNamePicDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Apply/GetApplyFormDetails?";
        if (appFormId === null)
            throw new Error("The parameter 'appFormId' cannot be null.");
        else if (appFormId !== undefined)
            url_ += "AppFormId=" + encodeURIComponent("" + appFormId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplyFormDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplyFormDetails(<any>response_);
                } catch (e) {
                    return <Observable<IdNamePicDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNamePicDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplyFormDetails(response: HttpResponseBase): Observable<IdNamePicDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdNamePicDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNamePicDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class BackendDownloadTaskServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 创建或者更新导出任务
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateExportTask(body: ExportMissionInput | undefined): Observable<ExportMissionInput> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/AddOrUpdateExportTask";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateExportTask(<any>response_);
                } catch (e) {
                    return <Observable<ExportMissionInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportMissionInput>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateExportTask(response: HttpResponseBase): Observable<ExportMissionInput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportMissionInput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportMissionInput>(<any>null);
    }

    /**
     * 获取任务列表
     * @param status (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getExportTask(status: ExportMissionStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ExportTaskDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/GetExportTask?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExportTask(<any>response_);
                } catch (e) {
                    return <Observable<ExportTaskDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExportTaskDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExportTask(response: HttpResponseBase): Observable<ExportTaskDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportTaskDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExportTaskDtoPagedResultDto>(<any>null);
    }

    /**
     * 批量删除任务
     * @param ids (optional) 
     * @return Success
     */
    deleteExportTask(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BackendDownloadTask/DeleteExportTask?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteExportTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteExportTask(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteExportTask(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BatchTaskLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * @param batchType (optional) 
     * @param onlineStoreId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBatchTaskLogs(batchType: string | undefined, onlineStoreId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<BatchTaskLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchTaskLog/GetBatchTaskLogs?";
        if (batchType === null)
            throw new Error("The parameter 'batchType' cannot be null.");
        else if (batchType !== undefined)
            url_ += "BatchType=" + encodeURIComponent("" + batchType) + "&";
        if (onlineStoreId === null)
            throw new Error("The parameter 'onlineStoreId' cannot be null.");
        else if (onlineStoreId !== undefined)
            url_ += "OnlineStoreId=" + encodeURIComponent("" + onlineStoreId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBatchTaskLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchTaskLogs(<any>response_);
                } catch (e) {
                    return <Observable<BatchTaskLogDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BatchTaskLogDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchTaskLogs(response: HttpResponseBase): Observable<BatchTaskLogDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BatchTaskLogDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BatchTaskLogDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class CouponServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取红包列表
     * @param auditStatus (optional) 优惠券的审核状态，分为上线或下线
     * @param organizationUnitId (optional) 组织架构Id
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCoupons(auditStatus: AuditStatus | undefined, organizationUnitId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CouponOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/GetCoupons?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoupons(<any>response_);
                } catch (e) {
                    return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoupons(response: HttpResponseBase): Observable<CouponOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponOutDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建红包
     * @param body (optional) 
     * @return Success
     */
    createCoupon(body: CreateCouponInput | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/CreateCoupon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCoupon(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCoupon(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * 删除单个红包
     * @param id (optional) 
     * @return Success
     */
    deleteCoupon(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/DeleteCoupon?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCoupon(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCoupon(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新红包
     * @param body (optional) 
     * @return Success
     */
    updateCoupon(body: UpdateCouponInput | undefined): Observable<CouponDto> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/UpdateCoupon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCoupon(<any>response_);
                } catch (e) {
                    return <Observable<CouponDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCoupon(response: HttpResponseBase): Observable<CouponDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDto>(<any>null);
    }

    /**
     * 下发红包到ou或device
     * @param body (optional) 
     * @return Success
     */
    publishCouponToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/PublishCouponToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishCouponToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishCouponToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishCouponToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 发布或者撤销全部 EntityIds 不需要传值
     * @param body (optional) 
     * @return Success
     */
    publishAllCouponToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/PublishAllCouponToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllCouponToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllCouponToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllCouponToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过Ticket来创建优惠券，如果有用到创思的微商城，有额外的逻辑
     * @param body (optional) 
     * @return Success
     */
    createCouponByTicket(body: CreateCouponByTicketInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Coupon/CreateCouponByTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCouponByTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCouponByTicket(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCouponByTicket(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取特定设备下的商品SPU信息列表
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetProductsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<ProductDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByDeviceId(response: HttpResponseBase): Observable<ProductDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取特定设备下的单品SKU信息列表
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceSkusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetSkusByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<DeviceSkusDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceSkusDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusByDeviceId(response: HttpResponseBase): Observable<DeviceSkusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceSkusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceSkusDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取设备下的红包
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCouponsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CouponOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetCouponsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponsByDeviceId(response: HttpResponseBase): Observable<CouponOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponOutDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取还没有下发到当前设备的商品
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedProductsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProuctListOutPutPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnpublishedProductsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedProductsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedProductsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedProductsByDeviceId(response: HttpResponseBase): Observable<ProuctListOutPutPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProuctListOutPutPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProuctListOutPutPagedResultDto>(<any>null);
    }

    /**
     * 获取还没有下发到当前设备的sku
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnpublishedSkusByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<DeviceSkusDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnpublishedSkusByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnpublishedSkusByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnpublishedSkusByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<DeviceSkusDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceSkusDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnpublishedSkusByDeviceId(response: HttpResponseBase): Observable<DeviceSkusDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceSkusDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceSkusDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取还没有下发到当前设备的红包
     * @param id (optional) Id for Product, Ad, Coupon, Sku, 目前只是给Product使用，Product下才有很多SKU的情况
     * @param auditStatus (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUnPublishedCouponsByDeviceId(deviceId: number, id: number | undefined, auditStatus: AuditStatus | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CouponOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetUnPublishedCouponsByDeviceId?";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined and cannot be null.");
        else
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnPublishedCouponsByDeviceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnPublishedCouponsByDeviceId(<any>response_);
                } catch (e) {
                    return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUnPublishedCouponsByDeviceId(response: HttpResponseBase): Observable<CouponOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponOutDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    onlineStoreInfoSelect(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Device/OnlineStoreInfoSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnlineStoreInfoSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnlineStoreInfoSelect(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOnlineStoreInfoSelect(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getAbpClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetAbpClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAbpClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAbpClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAbpClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getCache(key: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetCache?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCache(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCache(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @param value (optional) 
     * @return Success
     */
    setCache(key: string | undefined, value: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/Identity/SetCache?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (value === null)
            throw new Error("The parameter 'value' cannot be null.");
        else if (value !== undefined)
            url_ += "value=" + encodeURIComponent("" + value) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCache(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSetCache(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class LikeInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取猜你喜欢列表，如有sku，则返回当前sku的猜你喜欢列表
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<LikeInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Gets?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<LikeInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取猜你喜欢里的item列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLikeItems(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<LikeItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/GetLikeItems?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLikeItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLikeItems(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLikeItems(response: HttpResponseBase): Observable<LikeItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据id获取猜你喜欢
     * @param input (optional) 
     * @return Success
     */
    getSingle(input: number | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/GetSingle?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingle(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingle(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * 创建猜你喜欢
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLikeInfoInput | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * 创建猜你喜欢的某个item
     * @param body (optional) 
     * @return Success
     */
    createLikeItem(body: CreateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/CreateLikeItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateLikeItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLikeItem(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateLikeItem(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * 更新猜你喜欢
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLikeInfoInput | undefined): Observable<LikeInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LikeInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDto>(<any>null);
    }

    /**
     * 更新猜你喜欢的某个item
     * @param body (optional) 
     * @return Success
     */
    updateLikeItem(body: UpdateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/UpdateLikeItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLikeItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLikeItem(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLikeItem(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * 删除猜你喜欢
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除某个猜你喜欢里某个item
     * @param id (optional) 
     * @return Success
     */
    deleteLikeItem(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/DeleteLikeItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLikeItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLikeItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLikeItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取可以用来猜你喜欢的sku
     * @param likeInfoId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusForLikeInfo(likeInfoId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuSimpleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfo/GetSkusForLikeInfo?";
        if (likeInfoId === null)
            throw new Error("The parameter 'likeInfoId' cannot be null.");
        else if (likeInfoId !== undefined)
            url_ += "LikeInfoId=" + encodeURIComponent("" + likeInfoId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusForLikeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusForLikeInfo(<any>response_);
                } catch (e) {
                    return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusForLikeInfo(response: HttpResponseBase): Observable<SkuSimpleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuSimpleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSimpleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class LikeInfoExcelImporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    import(body: CreateLikeInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeInfoExcelImporter/Import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processImport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LikeItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 移动到likeinfo/GetLikeItems
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     * @deprecated
     */
    gets(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<LikeItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Gets?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<LikeItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDtoPagedResultDto>(<any>null);
    }

    /**
     * 暂停使用，移动到likeinfo/createLikeItem
     * @param body (optional) 
     * @return Success
     * @deprecated
     */
    create(body: CreateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * 移动到likeinfo/UpdateLikeItem
     * @param body (optional) 
     * @return Success
     * @deprecated
     */
    update(body: UpdateLikeItemInput | undefined): Observable<LikeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<LikeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LikeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeItemDto>(<any>null);
    }

    /**
     * 移动到likeinfo/DeleteLikeItem
     * @param id (optional) 
     * @return Success
     * @deprecated
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LikeItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MatchInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取搭配列表
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<MatchInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Gets?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<MatchInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取搭配里的item列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMatchItems(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<MatchItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/GetMatchItems?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchItems(<any>response_);
                } catch (e) {
                    return <Observable<MatchItemDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchItemDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchItems(response: HttpResponseBase): Observable<MatchItemDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchItemDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchItemDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据id获取搭配
     * @param input (optional) 
     * @return Success
     */
    getSingle(input: number | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/GetSingle?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingle(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingle(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * 创建搭配信息
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateMatchInfoInput | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * 创建搭配的item
     * @param body (optional) 
     * @return Success
     */
    createMatchItem(body: CreateMatchItemInput | undefined): Observable<MatchItemDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/CreateMatchItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMatchItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMatchItem(<any>response_);
                } catch (e) {
                    return <Observable<MatchItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMatchItem(response: HttpResponseBase): Observable<MatchItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchItemDto>(<any>null);
    }

    /**
     * 更新搭配信息
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMatchInfoInput | undefined): Observable<MatchInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MatchInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDto>(<any>null);
    }

    /**
     * 更新搭配item
     * @param body (optional) 
     * @return Success
     */
    updateMatchItem(body: UpdateMatchItemInput | undefined): Observable<MatchItemDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/UpdateMatchItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMatchItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMatchItem(<any>response_);
                } catch (e) {
                    return <Observable<MatchItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMatchItem(response: HttpResponseBase): Observable<MatchItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchItemDto>(<any>null);
    }

    /**
     * 删除搭配信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除搭配item
     * @param id (optional) 
     * @return Success
     */
    deleteMatchItem(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/DeleteMatchItem?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMatchItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMatchItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMatchItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取可以用来搭配的sku
     * @param matchInfoId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkusForMatchInfo(matchInfoId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuSimpleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MatchInfo/GetSkusForMatchInfo?";
        if (matchInfoId === null)
            throw new Error("The parameter 'matchInfoId' cannot be null.");
        else if (matchInfoId !== undefined)
            url_ += "MatchInfoId=" + encodeURIComponent("" + matchInfoId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkusForMatchInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkusForMatchInfo(<any>response_);
                } catch (e) {
                    return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkusForMatchInfo(response: HttpResponseBase): Observable<SkuSimpleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuSimpleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSimpleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * @param ouId (optional) 
     * @return Success
     */
    getOrganizationUnitById(ouId: number | undefined): Observable<GroupDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitById?";
        if (ouId === null)
            throw new Error("The parameter 'ouId' cannot be null.");
        else if (ouId !== undefined)
            url_ += "ouId=" + encodeURIComponent("" + ouId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitById(<any>response_);
                } catch (e) {
                    return <Observable<GroupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitById(response: HttpResponseBase): Observable<GroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupDto>(<any>null);
    }
}

@Injectable()
export class OutPutInStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 新增货更新商品的是出入库记录
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateOutPutInStorageBill(body: AddOrUpdateOutPutInStorageBillInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddOrUpdateOutPutInStorageBill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateOutPutInStorageBill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateOutPutInStorageBill(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateOutPutInStorageBill(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取出入库记录列表
     * @param body (optional) 
     * @return Success
     */
    getOutPutInStorageBills(body: GetOutPutInStorageBillInput | undefined): Observable<GetOutPutInStorageBillDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetOutPutInStorageBills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutPutInStorageBills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutPutInStorageBills(<any>response_);
                } catch (e) {
                    return <Observable<GetOutPutInStorageBillDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOutPutInStorageBillDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutPutInStorageBills(response: HttpResponseBase): Observable<GetOutPutInStorageBillDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOutPutInStorageBillDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOutPutInStorageBillDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取sku的出入库记录列表
     * @param body (optional) 
     * @return Success
     */
    getOutPutInStorageRecords(body: GetOutPutInStorageRecordInput | undefined): Observable<GetOutPutInStorageRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetOutPutInStorageRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOutPutInStorageRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOutPutInStorageRecords(<any>response_);
                } catch (e) {
                    return <Observable<GetOutPutInStorageRecordDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOutPutInStorageRecordDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOutPutInStorageRecords(response: HttpResponseBase): Observable<GetOutPutInStorageRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetOutPutInStorageRecordDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOutPutInStorageRecordDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据订单信息添加出入库信息
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @param body (optional) 
     * @return Success
     */
    addOutPutInStorageBillFromOrder(tenantId: number | undefined, storeId: number | undefined, body: AddOrUpdateOutPutInStorageBillInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddOutPutInStorageBillFromOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "StoreId": storeId !== undefined && storeId !== null ? "" + storeId : "",
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOutPutInStorageBillFromOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOutPutInStorageBillFromOrder(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOutPutInStorageBillFromOrder(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取sku
     * @param pricesScope (optional) 
     * @param categoryIds (optional) 
     * @param storeIds (optional) 
     * @param tagIds (optional) 
     * @param rfidCode (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkus(pricesScope: string | undefined, categoryIds: number[] | undefined, storeIds: number[] | undefined, tagIds: number[] | undefined, rfidCode: string | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ExternalSkuDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetSkus?";
        if (pricesScope === null)
            throw new Error("The parameter 'pricesScope' cannot be null.");
        else if (pricesScope !== undefined)
            url_ += "PricesScope=" + encodeURIComponent("" + pricesScope) + "&";
        if (categoryIds === null)
            throw new Error("The parameter 'categoryIds' cannot be null.");
        else if (categoryIds !== undefined)
            categoryIds && categoryIds.forEach(item => { url_ += "CategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (storeIds === null)
            throw new Error("The parameter 'storeIds' cannot be null.");
        else if (storeIds !== undefined)
            storeIds && storeIds.forEach(item => { url_ += "StoreIds=" + encodeURIComponent("" + item) + "&"; });
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (rfidCode === null)
            throw new Error("The parameter 'rfidCode' cannot be null.");
        else if (rfidCode !== undefined)
            url_ += "RfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkus(<any>response_);
                } catch (e) {
                    return <Observable<ExternalSkuDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalSkuDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkus(response: HttpResponseBase): Observable<ExternalSkuDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalSkuDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalSkuDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取sku的RFID
     * @param storeId (optional) 
     * @param skuId (optional) 
     * @param ignoreStore (optional) 
     * @param startTime (optional) 
     * @param endTime (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuRfids(storeId: number[] | undefined, skuId: number | undefined, ignoreStore: boolean | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetSkuRfidDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/GetSkuRfids?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            storeId && storeId.forEach(item => { url_ += "StoreId=" + encodeURIComponent("" + item) + "&"; });
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (ignoreStore === null)
            throw new Error("The parameter 'ignoreStore' cannot be null.");
        else if (ignoreStore !== undefined)
            url_ += "IgnoreStore=" + encodeURIComponent("" + ignoreStore) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuRfids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuRfids(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuRfidDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuRfidDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuRfids(response: HttpResponseBase): Observable<GetSkuRfidDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuRfidDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuRfidDtoPagedResultDto>(<any>null);
    }

    /**
     * 增加库存检查
     * @param body (optional) 
     * @return Success
     */
    addStorageCheck(body: AddStorageCheckInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/AddStorageCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStorageCheck(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStorageCheck(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddStorageCheck(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 移除RFID
     * @param rfidCode (optional) 
     * @return Success
     */
    recoverRfidCode(rfidCode: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutPutInStorage/RecoverRfidCode?";
        if (rfidCode === null)
            throw new Error("The parameter 'rfidCode' cannot be null.");
        else if (rfidCode !== undefined)
            url_ += "rfidCode=" + encodeURIComponent("" + rfidCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecoverRfidCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecoverRfidCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRecoverRfidCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PriceTagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 更新默认价签
     * @param body (optional) 
     * @return Success
     */
    updateDefaultPriceTag(body: UpdateDefaultPriceTagInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/UpdateDefaultPriceTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultPriceTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultPriceTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultPriceTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    priceTagIntegration(body: PriceTagPriceTagIntegrationInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/PriceTagIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPriceTagIntegration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPriceTagIntegration(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPriceTagIntegration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    syncProduct(body: PriceTagSyncProductInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/SyncProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncProduct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncProduct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param deviceId (optional) 
     * @return Success
     */
    getDefaultAndBindSkusByPriceTagId(deviceId: number | undefined): Observable<PriceDefaultDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/GetDefaultAndBindSkusByPriceTagId?";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultAndBindSkusByPriceTagId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultAndBindSkusByPriceTagId(<any>response_);
                } catch (e) {
                    return <Observable<PriceDefaultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PriceDefaultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultAndBindSkusByPriceTagId(response: HttpResponseBase): Observable<PriceDefaultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriceDefaultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PriceDefaultDto>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getProductPriceTags(productId: number | undefined): Observable<IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PriceTag/GetProductPriceTags?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPriceTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPriceTags(<any>response_);
                } catch (e) {
                    return <Observable<IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPriceTags(response: HttpResponseBase): Observable<IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class ProductServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取单个product
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleProduct(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, organizationId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, pointRedeemType: RedeemType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSingleProduct?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProduct(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    /**
     * 获取商品list
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProducts(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, organizationId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, pointRedeemType: RedeemType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProuctListOutPutPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProducts?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProuctListOutPutPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProuctListOutPutPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProuctListOutPutPagedResultDto>(<any>null);
    }

    /**
     * 更新商品
     * @param body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建product
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 根据id 删除product
     * @param id (optional) 
     * @return Success
     */
    deleteProductById(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据数组里的id批量删除多个商品
     * @param ids (optional) 
     * @return Success
     */
    deleteProductByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据数组里的id批量删除多个SKU
     * @param ids (optional) 
     * @return Success
     */
    deleteSkuByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取商品下面的sku
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductSkus(productId: number | undefined, skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuSimpleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductSkus?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductSkus(<any>response_);
                } catch (e) {
                    return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuSimpleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductSkus(response: HttpResponseBase): Observable<SkuSimpleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuSimpleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuSimpleDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取商品的RFID信息
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductRfids(productId: number | undefined, skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetSkuRfidDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductRfids?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductRfids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductRfids(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuRfidDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuRfidDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductRfids(response: HttpResponseBase): Observable<GetSkuRfidDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuRfidDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuRfidDtoPagedResultDto>(<any>null);
    }

    /**
     * 更新sku
     * @param body (optional) 
     * @return Success
     */
    updateSku(body: UpdateSkuInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建sku
     * @param body (optional) 
     * @return Success
     */
    createSku(body: CreateSkuInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateSku";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSku(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSku(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * 把检索的结果下发到设备或者ou
     * @param body (optional) 
     * @return Success
     */
    publishSearchedProducts(body: PublishSearchedProductInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishSearchedProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSearchedProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSearchedProducts(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSearchedProducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 下发或撤销商品到ou或device或者store
     * @param body (optional) 
     * @return Success
     */
    publishToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 下发或者撤销sku到ou或device或者store
     * @param body (optional) 
     * @return Success
     */
    publishSkuToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishSkuToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishSkuToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishSkuToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishSkuToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 发布或者撤销全部 商品，此时EntityIds 不需要传值
     * @param body (optional) 
     * @return Success
     */
    publishAllToOrganizationOrDevicesOrStore(body: PublishEntitiesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/PublishAllToOrganizationOrDevicesOrStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishAllToOrganizationOrDevicesOrStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishAllToOrganizationOrDevicesOrStore(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPublishAllToOrganizationOrDevicesOrStore(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 单个sku详细
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSingleSku(productId: number | undefined, skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSingleSku?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "skuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleSku(<any>response_);
                } catch (e) {
                    return <Observable<SkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleSku(response: HttpResponseBase): Observable<SkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuDto>(<any>null);
    }

    /**
     * 设定或者清除商品的tag,SetTags 方法名改成SetOrClearProductTags
     * @param body (optional) 
     * @return Success
     */
    setOrClearProductTags(body: SetProductTagsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/SetOrClearProductTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrClearProductTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrClearProductTags(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetOrClearProductTags(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 设定或者清除商品分类,SetCategories 方法名改成SetOrClearProductCategories
     * @param body (optional) 
     * @return Success
     */
    setOrClearProductCategories(body: SetProductCategoryDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/SetOrClearProductCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrClearProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrClearProductCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetOrClearProductCategories(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除单个sku
     * @param id (optional) 
     * @return Success
     */
    deleteSku(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSku?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSku(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSku(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据RFID或者barcode获取sku
     * @param code (optional) 
     * @param type (optional) 
     * @return Success
     */
    getSkuByCode(code: string | undefined, type: string | undefined): Observable<GetSkuByCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuByCode?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuByCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuByCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuByCode(response: HttpResponseBase): Observable<GetSkuByCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuByCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuByCodeDto>(<any>null);
    }

    /**
     * 根据 product的id 或者 sku的 id 获取图片.更改名称 GetPictures -> GetProductOrSkuPictures
     * @param body (optional) 
     * @return Success
     */
    getProductOrSkuPictures(body: GetProductPicturesInput | undefined): Observable<IdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOrSkuPictures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOrSkuPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOrSkuPictures(<any>response_);
                } catch (e) {
                    return <Observable<IdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOrSkuPictures(response: HttpResponseBase): Observable<IdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdPicUrlDto[]>(<any>null);
    }

    /**
     * 根据 product的itemid 或者sku的 sku_id 获得图片.更改名称 GetPicturesByItemId -> GetProductOrSkuPicturesByItemId
     * @param body (optional) 
     * @return Success
     */
    getProductOrSkuPicturesByItemId(body: GetProductPicturesByItemIdInput | undefined): Observable<ItemIdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOrSkuPicturesByItemId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOrSkuPicturesByItemId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOrSkuPicturesByItemId(<any>response_);
                } catch (e) {
                    return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOrSkuPicturesByItemId(response: HttpResponseBase): Observable<ItemIdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemIdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemIdPicUrlDto[]>(<any>null);
    }

    /**
     * 根据 product的outerid 或者sku的 outerid 获得图片。更改名称 GetPicturesByOuterId -> GetProductOrSkuPicturesByOuterId
     * @param body (optional) 
     * @return Success
     */
    getProductOrSkuPicturesByOuterId(body: GetProductPicturesByItemIdInput | undefined): Observable<ItemIdPicUrlDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOrSkuPicturesByOuterId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOrSkuPicturesByOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOrSkuPicturesByOuterId(<any>response_);
                } catch (e) {
                    return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemIdPicUrlDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOrSkuPicturesByOuterId(response: HttpResponseBase): Observable<ItemIdPicUrlDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemIdPicUrlDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemIdPicUrlDto[]>(<any>null);
    }

    /**
     * 根据 product的outerid 或者sku的 outerid 获得itemid 或者 sku_id。更改名称 GetIdAndNamesByOuterId -> GetProductOrSkuItemIdAndNamesByOuterId
     * @param body (optional) 
     * @return Success
     */
    getProductOrSkuItemIdAndNamesByOuterId(body: GetProductIdAndName | undefined): Observable<IdNameItemIdDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOrSkuItemIdAndNamesByOuterId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOrSkuItemIdAndNamesByOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOrSkuItemIdAndNamesByOuterId(<any>response_);
                } catch (e) {
                    return <Observable<IdNameItemIdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdNameItemIdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOrSkuItemIdAndNamesByOuterId(response: HttpResponseBase): Observable<IdNameItemIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdNameItemIdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdNameItemIdDto[]>(<any>null);
    }

    /**
     * 获取某个商品下全部评价
     * @param productId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductComments(productId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductCommentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductComments?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductComments(<any>response_);
                } catch (e) {
                    return <Observable<ProductCommentDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCommentDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductComments(response: HttpResponseBase): Observable<ProductCommentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCommentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCommentDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除商品下某一个评论。更改名称 -> DeleteProductComment
     * @param id (optional) 商品评论的id
     * @return Success
     */
    deleteProductComment(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductComment?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据数组id，批量删除商品的评论。
     * @param ids (optional) 
     * @return Success
     */
    deleteProductCommentByIds(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductCommentByIds?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductCommentByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductCommentByIds(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductCommentByIds(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 为某个商品添加评论
     * @param body (optional) 
     * @return Success
     */
    addProductComments(body: CreateProductCommentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddProductComments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductComments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddProductComments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新某个商品的评论
     * @param body (optional) 
     * @return Success
     */
    updateProductComment(body: UpdateProductCommentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProductComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductComment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取某个商品下所有的资源
     * @param entityId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductResources(entityId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<EntityFileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductResources?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductResources(<any>response_);
                } catch (e) {
                    return <Observable<EntityFileDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFileDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductResources(response: HttpResponseBase): Observable<EntityFileDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityFileDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFileDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据数组id，批量删除商品的资源
     * @param ids (optional) 
     * @return Success
     */
    deleteProductResources(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductResources?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除商品下某一个特定的资源
     * @param id (optional) 商品资源的id
     * @return Success
     */
    deleteProductResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 为某个商品添加资源
     * @param body (optional) 
     * @return Success
     */
    addProductResource(body: CreateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddProductResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新特定的商品资源
     * @param body (optional) 
     * @return Success
     */
    updateProductResource(body: UpdateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProductResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取商品的线上店信息
     * @param productId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductOnlinestoreInfos(productId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductOnlineStoreInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductOnlinestoreInfos?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOnlinestoreInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOnlinestoreInfos(<any>response_);
                } catch (e) {
                    return <Observable<ProductOnlineStoreInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductOnlineStoreInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOnlinestoreInfos(response: HttpResponseBase): Observable<ProductOnlineStoreInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductOnlineStoreInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductOnlineStoreInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除商品下某一个线上店信息
     * @param id (optional) 线上店的id
     * @return Success
     */
    deleteProductOnlinestoreInfo(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProductOnlinestoreInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 为某个商品添加线上店
     * @param body (optional) 
     * @return Success
     */
    addProductOnlinestoreInfo(body: CreateProductOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddProductOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新某个特定的商品线上店信息
     * @param body (optional) 
     * @return Success
     */
    updateProductOnlinestoreInfo(body: UpdateProductOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProductOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取某个Sku下所有的资源
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuResources(skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuFileDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuResources?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuResources(<any>response_);
                } catch (e) {
                    return <Observable<SkuFileDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuFileDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuResources(response: HttpResponseBase): Observable<SkuFileDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuFileDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuFileDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除Sku下某一个资源
     * @param id (optional) skuResouce的id
     * @return Success
     */
    deleteSkuResource(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuResource?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据数组id，批量删除sku的资源
     * @param ids (optional) 
     * @return Success
     */
    deleteSkuResources(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuResources?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuResources(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 为某个SKu添加资源
     * @param body (optional) 
     * @return Success
     */
    addSkuResource(body: CreateSkuResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddSkuResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新某个sku资源信息
     * @param body (optional) 
     * @return Success
     */
    updateSkuResource(body: UpdateEntityResourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSkuResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuResource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取sku的线上店信息
     * @param skuId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getSkuOnlinestoreInfos(skuId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SkuOnlineStoreInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSkuOnlinestoreInfos?";
        if (skuId === null)
            throw new Error("The parameter 'skuId' cannot be null.");
        else if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuOnlinestoreInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuOnlinestoreInfos(<any>response_);
                } catch (e) {
                    return <Observable<SkuOnlineStoreInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuOnlineStoreInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuOnlinestoreInfos(response: HttpResponseBase): Observable<SkuOnlineStoreInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SkuOnlineStoreInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuOnlineStoreInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * 删除Sku下某一个线上店信息
     * @param id (optional) 线上店的id
     * @return Success
     */
    deleteSkuOnlinestoreInfo(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteSkuOnlinestoreInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 为某个商品添加线上店
     * @param body (optional) 
     * @return Success
     */
    addSkuOnlinestoreInfo(body: CreateSkuOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddSkuOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新sku的某个线上店信息
     * @param body (optional) 
     * @return Success
     */
    updateSkuOnlinestoreInfo(body: UpdateSkuOnlineInfoInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateSkuOnlinestoreInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuOnlinestoreInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuOnlinestoreInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuOnlinestoreInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取某个商品的属性列表
     * @param id (optional) 
     * @return Success
     */
    getPropertiesByProductId(id: number | undefined): Observable<ProductPropertyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPropertiesByProductId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertiesByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertiesByProductId(<any>response_);
                } catch (e) {
                    return <Observable<ProductPropertyDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPropertyDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertiesByProductId(response: HttpResponseBase): Observable<ProductPropertyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductPropertyDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPropertyDto[]>(<any>null);
    }

    /**
     * 这个接口不知道是干嘛的
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedProductIds(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, organizationId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, pointRedeemType: RedeemType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<IdAndTotalCount[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPagedProductIds?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedProductIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedProductIds(<any>response_);
                } catch (e) {
                    return <Observable<IdAndTotalCount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdAndTotalCount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedProductIds(response: HttpResponseBase): Observable<IdAndTotalCount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdAndTotalCount.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdAndTotalCount[]>(<any>null);
    }

    /**
     * 导出product到excel
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductToExcel(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, organizationId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, pointRedeemType: RedeemType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductToExcel?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 以后台任务形式，导出product到excel
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param organizationId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param pointRedeemType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductToExcelTask(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, organizationId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, pointRedeemType: RedeemType | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductToExcelTask?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductToExcelTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductToExcelTask(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductToExcelTask(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取商品区域列表
     * @return Success
     */
    getProductRegions(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductRegions(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductRegions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 获取商品语言列表
     * @return Success
     */
    getProductLanguages(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductLanguages(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductLanguages(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 获取区域
     * @return Success
     */
    getRegions(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegions(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegions(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * 获取语言
     * @return Success
     */
    getLanguages(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    gets(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PropertyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/Gets?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGets(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGets(response: HttpResponseBase): Observable<PropertyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取属性值列表
     * @param propertyId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPropertyValues(propertyId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PropertyValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPropertyValues?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyValues(<any>response_);
                } catch (e) {
                    return <Observable<PropertyValueDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyValueDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPropertyValues(response: HttpResponseBase): Observable<PropertyValueDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyValueDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyValueDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取单个属性信息,
     * @param id (optional) 
     * @return Success
     */
    getSignleProperty(id: number | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetSignleProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignleProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignleProperty(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSignleProperty(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * 创建属性
     * @param body (optional) 
     * @return Success
     */
    createProperty(body: CreatePropertyInput | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreateProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProperty(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProperty(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * 创建属性的值
     * @param body (optional) 
     * @return Success
     */
    createPropertyValue(body: CreatePropertyValueInput | undefined): Observable<PropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/CreatePropertyValue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePropertyValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePropertyValue(<any>response_);
                } catch (e) {
                    return <Observable<PropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePropertyValue(response: HttpResponseBase): Observable<PropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyValueDto>(<any>null);
    }

    /**
     * 更新属性
     * @param body (optional) 
     * @return Success
     */
    updateProperty(body: UpdatePropertyInput | undefined): Observable<PropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdateProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProperty(<any>response_);
                } catch (e) {
                    return <Observable<PropertyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProperty(response: HttpResponseBase): Observable<PropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyDto>(<any>null);
    }

    /**
     * 更新属性值
     * @param body (optional) 
     * @return Success
     */
    updatePropertyValue(body: UpdatePropertyValueInput | undefined): Observable<PropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/UpdatePropertyValue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePropertyValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePropertyValue(<any>response_);
                } catch (e) {
                    return <Observable<PropertyValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PropertyValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePropertyValue(response: HttpResponseBase): Observable<PropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PropertyValueDto>(<any>null);
    }

    /**
     * 删除属性
     * @param id (optional) 
     * @return Success
     */
    deleteProperty(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeleteProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProperty(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProperty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除属性值
     * @param id (optional) 
     * @return Success
     */
    deletePropertyValue(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeletePropertyValue?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePropertyValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePropertyValue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePropertyValue(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 创建或者便跟促销
     * @param body (optional) 
     * @return Success
     */
    addOrUpdatePromotion(body: AddOrUpdatePromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddOrUpdatePromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdatePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdatePromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdatePromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取促销列表
     * @param promotionType (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPromotions(promotionType: PromotionTypeEnum | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetPromotioDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetPromotions?";
        if (promotionType === null)
            throw new Error("The parameter 'promotionType' cannot be null.");
        else if (promotionType !== undefined)
            url_ += "PromotionType=" + encodeURIComponent("" + promotionType) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPromotions(<any>response_);
                } catch (e) {
                    return <Observable<GetPromotioDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPromotioDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPromotions(response: HttpResponseBase): Observable<GetPromotioDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPromotioDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPromotioDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据id 批量删除促销
     * @param ids (optional) 
     * @return Success
     */
    deletePromotions(ids: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/DeletePromotions?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePromotions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePromotions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 新增或更新促销里的商品
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateProductsToPromotion(body: AddOrUpdateProductsToPromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Product/AddOrUpdateProductsToPromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateProductsToPromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateProductsToPromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateProductsToPromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取商品的促销信息
     * @param promotionId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductPromotions(promotionId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetProductPromotionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Product/GetProductPromotions?";
        if (promotionId === null)
            throw new Error("The parameter 'promotionId' cannot be null.");
        else if (promotionId !== undefined)
            url_ += "PromotionId=" + encodeURIComponent("" + promotionId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductPromotions(<any>response_);
                } catch (e) {
                    return <Observable<GetProductPromotionDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductPromotionDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductPromotions(response: HttpResponseBase): Observable<GetProductPromotionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductPromotionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductPromotionDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class ProductCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取商品品类列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductCategories(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductCategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetProductCategories?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategories(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategories(response: HttpResponseBase): Observable<ProductCategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * 根据获取单个商品分类
     * @param id (optional) 
     * @return Success
     */
    getSingleProductCategory(id: number | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetSingleProductCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * 创建商品品类
     * @param body (optional) 
     * @return Success
     */
    createProductCategory(body: CreateProductCategoryInput | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/CreateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * 更新商品品类, 如果没有id,也可以根据code来更新
     * @param body (optional) 
     * @return Success
     */
    updateProductCategory(body: UpdateProductCategoryInput | undefined): Observable<ProductCategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/UpdateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductCategory(response: HttpResponseBase): Observable<ProductCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryDto>(<any>null);
    }

    /**
     * 删除分类的时候 子分类也删除,商品也要清除分类
     * @param id (optional) 
     * @return Success
     */
    deleteProductCategory(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/DeleteProductCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据orderNumber 获取一定数量的分类
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }

    /**
     * 获取所有商品分类的树形结构
     * @return Success
     */
    getCategoryTrees(): Observable<ProductCategoryTreeItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetCategoryTrees";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTrees(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTrees(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryTreeItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTrees(response: HttpResponseBase): Observable<ProductCategoryTreeItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductCategoryTreeItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryTreeItemDto[]>(<any>null);
    }

    /**
     * 获取某个商品分类包含子分类
     * @param id (optional) 
     * @return Success
     */
    getCategoryTreeById(id: number | undefined): Observable<ProductCategoryTreeItemDto> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/GetCategoryTreeById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTreeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTreeById(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategoryTreeItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategoryTreeItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryTreeById(response: HttpResponseBase): Observable<ProductCategoryTreeItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategoryTreeItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategoryTreeItemDto>(<any>null);
    }

    /**
     * 创建或者更新商品品类
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateProductCategory(body: AddOrUpdateProductCategoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProductCategory/AddOrUpdateProductCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateProductCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateProductCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateProductCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取总数报表
     * @param body (optional) 
     * @return Success
     */
    getCountReportGet(body: GetCountReportInput | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCountReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountReportGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountReportGet(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountReportGet(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }

    /**
     * 获取总数报表
     * @param body (optional) 
     * @return Success
     */
    getCountReportPost(body: GetCountReportInput | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Report/GetCountReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountReportPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountReportPost(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountReportPost(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }
}

@Injectable()
export class SensingDeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取设备下的商品
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProducts(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProducts?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductSdkModelPagedResultDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDapperProducts(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetDapperProducts?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDapperProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDapperProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDapperProducts(response: HttpResponseBase): Observable<ProductSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductSdkModelPagedResultDto>(<any>null);
    }

    /**
     * @param outerId (optional) 
     * @return Success
     */
    getProductBySubKeyAndSkuOuterId(outerId: string | undefined, subKey: string): Observable<GetProductBySubKeyAndOuterIdOutput> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductBySubKeyAndSkuOuterId?";
        if (outerId === null)
            throw new Error("The parameter 'outerId' cannot be null.");
        else if (outerId !== undefined)
            url_ += "OuterId=" + encodeURIComponent("" + outerId) + "&";
        if (subKey === undefined || subKey === null)
            throw new Error("The parameter 'subKey' must be defined and cannot be null.");
        else
            url_ += "SubKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductBySubKeyAndSkuOuterId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductBySubKeyAndSkuOuterId(<any>response_);
                } catch (e) {
                    return <Observable<GetProductBySubKeyAndOuterIdOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductBySubKeyAndOuterIdOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductBySubKeyAndSkuOuterId(response: HttpResponseBase): Observable<GetProductBySubKeyAndOuterIdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductBySubKeyAndOuterIdOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductBySubKeyAndOuterIdOutput>(<any>null);
    }

    /**
     * 获取展示商品的分类，不包含未展示的
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductCategories(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProductCategorySDKModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductCategories?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCategories(<any>response_);
                } catch (e) {
                    return <Observable<ProductCategorySDKModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductCategorySDKModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductCategories(response: HttpResponseBase): Observable<ProductCategorySDKModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategorySDKModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductCategorySDKModelPagedResultDto>(<any>null);
    }

    /**
     * 获取所有的tag
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagSdkModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetTags?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagSdkModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagSdkModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagSdkModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagSdkModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagSdkModelPagedResultDto>(<any>null);
    }

    /**
     * 获取所有的搭配
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMatchInfos(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<MatchInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetMatchInfos?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMatchInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMatchInfos(<any>response_);
                } catch (e) {
                    return <Observable<MatchInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatchInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMatchInfos(response: HttpResponseBase): Observable<MatchInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatchInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatchInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取所有的猜你喜欢
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLikeInfos(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<LikeInfoDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetLikeInfos?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLikeInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLikeInfos(<any>response_);
                } catch (e) {
                    return <Observable<LikeInfoDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LikeInfoDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLikeInfos(response: HttpResponseBase): Observable<LikeInfoDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LikeInfoDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LikeInfoDtoPagedResultDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getBrandIdAndProductIds(tenantId: number | undefined): Observable<BrandProductDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBrandIdAndProductIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandIdAndProductIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandIdAndProductIds(<any>response_);
                } catch (e) {
                    return <Observable<BrandProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandIdAndProductIds(response: HttpResponseBase): Observable<BrandProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandProductDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getBrandIdAndSkuIds(tenantId: number | undefined): Observable<BrandSkuDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetBrandIdAndSkuIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandIdAndSkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandIdAndSkuIds(<any>response_);
                } catch (e) {
                    return <Observable<BrandSkuDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandSkuDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandIdAndSkuIds(response: HttpResponseBase): Observable<BrandSkuDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandSkuDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandSkuDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getSkuIds(tenantId: number | undefined): Observable<SkuIdAndOuterIdDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetSkuIds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "TenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuIds(<any>response_);
                } catch (e) {
                    return <Observable<SkuIdAndOuterIdDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkuIdAndOuterIdDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuIds(response: HttpResponseBase): Observable<SkuIdAndOuterIdDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkuIdAndOuterIdDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkuIdAndOuterIdDto[]>(<any>null);
    }

    /**
     * 获取所有的红包
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCoupons(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CouponDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCoupons?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCoupons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCoupons(<any>response_);
                } catch (e) {
                    return <Observable<CouponDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCoupons(response: HttpResponseBase): Observable<CouponDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponDtoPagedResultDto>(<any>null);
    }

    /**
     * @param couponId (optional) 
     * @return Success
     */
    getCouponUrl(couponId: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCouponUrl?";
        if (couponId === null)
            throw new Error("The parameter 'couponId' cannot be null.");
        else if (couponId !== undefined)
            url_ += "CouponId=" + encodeURIComponent("" + couponId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 获取所有的属性
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProperties(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SensingDevicePropertyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProperties?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProperties(<any>response_);
                } catch (e) {
                    return <Observable<SensingDevicePropertyDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensingDevicePropertyDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProperties(response: HttpResponseBase): Observable<SensingDevicePropertyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensingDevicePropertyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensingDevicePropertyDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取所有商品评价
     * @param subkey (optional) 
     * @param pointRedeemType (optional) 
     * @param tagNames (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductComments(subkey: string | undefined, pointRedeemType: RedeemType | undefined, tagNames: string[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<SensingDeviceProductCommentModelPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetProductComments?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (pointRedeemType === null)
            throw new Error("The parameter 'pointRedeemType' cannot be null.");
        else if (pointRedeemType !== undefined)
            url_ += "PointRedeemType=" + encodeURIComponent("" + pointRedeemType) + "&";
        if (tagNames === null)
            throw new Error("The parameter 'tagNames' cannot be null.");
        else if (tagNames !== undefined)
            tagNames && tagNames.forEach(item => { url_ += "TagNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductComments(<any>response_);
                } catch (e) {
                    return <Observable<SensingDeviceProductCommentModelPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SensingDeviceProductCommentModelPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductComments(response: HttpResponseBase): Observable<SensingDeviceProductCommentModelPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensingDeviceProductCommentModelPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SensingDeviceProductCommentModelPagedResultDto>(<any>null);
    }

    /**
     * @param subkey (optional) 
     * @param updatedTime (optional) 
     * @return Success
     */
    getNeedUpdateStatus(subkey: string | undefined, updatedTime: moment.Moment | undefined): Observable<TableNeedUpdateDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetNeedUpdateStatus?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (updatedTime === null)
            throw new Error("The parameter 'updatedTime' cannot be null.");
        else if (updatedTime !== undefined)
            url_ += "UpdatedTime=" + encodeURIComponent(updatedTime ? "" + updatedTime.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNeedUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNeedUpdateStatus(<any>response_);
                } catch (e) {
                    return <Observable<TableNeedUpdateDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TableNeedUpdateDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetNeedUpdateStatus(response: HttpResponseBase): Observable<TableNeedUpdateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TableNeedUpdateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TableNeedUpdateDto>(<any>null);
    }

    /**
     * 获取商品数量及库存预警
     * @param tenantId (optional) 
     * @param storeId (optional) 
     * @return Success
     */
    productCountAndStorage(tenantId: number | undefined, storeId: number | undefined): Observable<GetProductsCountAndInventoryDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/ProductCountAndStorage?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProductCountAndStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProductCountAndStorage(<any>response_);
                } catch (e) {
                    return <Observable<GetProductsCountAndInventoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProductsCountAndInventoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processProductCountAndStorage(response: HttpResponseBase): Observable<GetProductsCountAndInventoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProductsCountAndInventoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProductsCountAndInventoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    queryProductsOrSkus(body: QueryProductsOrSkusInput | undefined): Observable<SimpleProductOrSkuDto[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/QueryProductsOrSkus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueryProductsOrSkus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueryProductsOrSkus(<any>response_);
                } catch (e) {
                    return <Observable<SimpleProductOrSkuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleProductOrSkuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processQueryProductsOrSkus(response: HttpResponseBase): Observable<SimpleProductOrSkuDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleProductOrSkuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleProductOrSkuDto[]>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @param selfPickupcode (optional) 
     * @return Success
     */
    getCargoInfoForWeimobActivity(subKey: string | undefined, selfPickupcode: string | undefined): Observable<CargoInfoForWeimobActivityDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetCargoInfoForWeimobActivity?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        if (selfPickupcode === null)
            throw new Error("The parameter 'selfPickupcode' cannot be null.");
        else if (selfPickupcode !== undefined)
            url_ += "selfPickupcode=" + encodeURIComponent("" + selfPickupcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCargoInfoForWeimobActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCargoInfoForWeimobActivity(<any>response_);
                } catch (e) {
                    return <Observable<CargoInfoForWeimobActivityDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CargoInfoForWeimobActivityDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCargoInfoForWeimobActivity(response: HttpResponseBase): Observable<CargoInfoForWeimobActivityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CargoInfoForWeimobActivityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CargoInfoForWeimobActivityDto>(<any>null);
    }

    /**
     * @param subKey (optional) 
     * @return Success
     */
    getRecommendProducts(subKey: string | undefined): Observable<ProductSdkModel[]> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetRecommendProducts?";
        if (subKey === null)
            throw new Error("The parameter 'subKey' cannot be null.");
        else if (subKey !== undefined)
            url_ += "subKey=" + encodeURIComponent("" + subKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductSdkModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductSdkModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommendProducts(response: HttpResponseBase): Observable<ProductSdkModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSdkModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductSdkModel[]>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param rfideCode (optional) 
     * @return Success
     */
    getWeishopProductRfidQrcode(tenantId: number | undefined, rfideCode: string | undefined): Observable<RfidQrcodeDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetWeishopProductRfidQrcode?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (rfideCode === null)
            throw new Error("The parameter 'rfideCode' cannot be null.");
        else if (rfideCode !== undefined)
            url_ += "rfideCode=" + encodeURIComponent("" + rfideCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopProductRfidQrcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopProductRfidQrcode(<any>response_);
                } catch (e) {
                    return <Observable<RfidQrcodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RfidQrcodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopProductRfidQrcode(response: HttpResponseBase): Observable<RfidQrcodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RfidQrcodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RfidQrcodeDto>(<any>null);
    }

    /**
     * 批量生成二维码
     * @param body (optional) 
     * @return Success
     */
    getWeishopProductBySkuID(body: PDFDto | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/GetWeishopProductBySkuID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeishopProductBySkuID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeishopProductBySkuID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeishopProductBySkuID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 打印
     * @param title (optional) 
     * @param isTop (optional) 
     * @param column (optional) 
     * @param body (optional) 
     * @return Success
     */
    outputfile(title: string | undefined, isTop: number | undefined, column: number | undefined, body: string[] | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SensingDevice/Outputfile?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (isTop === null)
            throw new Error("The parameter 'isTop' cannot be null.");
        else if (isTop !== undefined)
            url_ += "IsTop=" + encodeURIComponent("" + isTop) + "&";
        if (column === null)
            throw new Error("The parameter 'column' cannot be null.");
        else if (column !== undefined)
            url_ += "Column=" + encodeURIComponent("" + column) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutputfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutputfile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processOutputfile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SensingSkuRfidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 根据RFID 或者BARCODE 获取sku
     * @param subkey (optional) 
     * @param code (optional) 
     * @param type (optional) 
     * @return Success
     */
    getSkuByCode(subkey: string | undefined, code: string | undefined, type: string | undefined): Observable<GetSkuByCodeDto> {
        let url_ = this.baseUrl + "/api/services/app/SensingSkuRfid/GetSkuByCode?";
        if (subkey === null)
            throw new Error("The parameter 'subkey' cannot be null.");
        else if (subkey !== undefined)
            url_ += "Subkey=" + encodeURIComponent("" + subkey) + "&";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkuByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkuByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetSkuByCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSkuByCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkuByCode(response: HttpResponseBase): Observable<GetSkuByCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSkuByCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSkuByCodeDto>(<any>null);
    }

    /**
     * 有效或无效某个促销
     * @param body (optional) 
     * @return Success
     */
    activeOrInactivePromotion(body: ActivePromotionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SensingSkuRfid/ActiveOrInactivePromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveOrInactivePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveOrInactivePromotion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActiveOrInactivePromotion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SkuRfidServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 创建skuRfid
     * @param body (optional) 
     * @return Success
     */
    createSkuRfid(body: CreateSkuRfidInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/CreateSkuRfid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSkuRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSkuRfid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSkuRfid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 跟新SkuRfid
     * @param body (optional) 
     * @return Success
     */
    updateSkuRfid(body: UpdateSkuRfidInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/UpdateSkuRfid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSkuRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSkuRfid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSkuRfid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除某个SkuRfid
     * @param id (optional) 
     * @return Success
     */
    deleteSkuRfid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SkuRfid/DeleteSkuRfid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSkuRfid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSkuRfid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSkuRfid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class StoreServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取线下店的优惠券
     * @param auditStatus (optional) 
     * @param storeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCouponsByStoreId(auditStatus: AuditStatus | undefined, storeId: number | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<CouponOutDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetCouponsByStoreId?";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CouponOutDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCouponsByStoreId(response: HttpResponseBase): Observable<CouponOutDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponOutDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponOutDtoPagedResultDto>(<any>null);
    }

    /**
     * 获取线下店的商品
     * @param currentProductId (optional) 
     * @param startTime (optional) 开始时间（最后更新)
     * @param endTime (optional) 结束时间（最后更新）
     * @param auditStatus (optional) 上下线查询 offline,online
     * @param tagIds (optional) 标签
     * @param catetoryIds (optional) 分类
     * @param price1 (optional) 价格区间1
     * @param price2 (optional) 价格区间2
     * @param stock (optional) 
     * @param salesVolume (optional) 
     * @param sortStatus (optional) asc , desc
     * @param isSearchSku (optional) 
     * @param storeId (optional) 
     * @param language (optional) 
     * @param region (optional) 
     * @param brandIds (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProductsByStoreId(currentProductId: number | undefined, startTime: moment.Moment | undefined, endTime: moment.Moment | undefined, auditStatus: AuditStatus | undefined, tagIds: number[] | undefined, catetoryIds: number[] | undefined, price1: number | undefined, price2: number | undefined, stock: string | undefined, salesVolume: string | undefined, sortStatus: string | undefined, isSearchSku: boolean | undefined, storeId: number | undefined, language: string | undefined, region: string | undefined, brandIds: number[] | undefined, filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<ProuctListOutPutPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Store/GetProductsByStoreId?";
        if (currentProductId === null)
            throw new Error("The parameter 'currentProductId' cannot be null.");
        else if (currentProductId !== undefined)
            url_ += "CurrentProductId=" + encodeURIComponent("" + currentProductId) + "&";
        if (startTime === null)
            throw new Error("The parameter 'startTime' cannot be null.");
        else if (startTime !== undefined)
            url_ += "StartTime=" + encodeURIComponent(startTime ? "" + startTime.toJSON() : "") + "&";
        if (endTime === null)
            throw new Error("The parameter 'endTime' cannot be null.");
        else if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&";
        if (auditStatus === null)
            throw new Error("The parameter 'auditStatus' cannot be null.");
        else if (auditStatus !== undefined)
            url_ += "AuditStatus=" + encodeURIComponent("" + auditStatus) + "&";
        if (tagIds === null)
            throw new Error("The parameter 'tagIds' cannot be null.");
        else if (tagIds !== undefined)
            tagIds && tagIds.forEach(item => { url_ += "TagIds=" + encodeURIComponent("" + item) + "&"; });
        if (catetoryIds === null)
            throw new Error("The parameter 'catetoryIds' cannot be null.");
        else if (catetoryIds !== undefined)
            catetoryIds && catetoryIds.forEach(item => { url_ += "CatetoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (price1 === null)
            throw new Error("The parameter 'price1' cannot be null.");
        else if (price1 !== undefined)
            url_ += "Price1=" + encodeURIComponent("" + price1) + "&";
        if (price2 === null)
            throw new Error("The parameter 'price2' cannot be null.");
        else if (price2 !== undefined)
            url_ += "Price2=" + encodeURIComponent("" + price2) + "&";
        if (stock === null)
            throw new Error("The parameter 'stock' cannot be null.");
        else if (stock !== undefined)
            url_ += "Stock=" + encodeURIComponent("" + stock) + "&";
        if (salesVolume === null)
            throw new Error("The parameter 'salesVolume' cannot be null.");
        else if (salesVolume !== undefined)
            url_ += "salesVolume=" + encodeURIComponent("" + salesVolume) + "&";
        if (sortStatus === null)
            throw new Error("The parameter 'sortStatus' cannot be null.");
        else if (sortStatus !== undefined)
            url_ += "SortStatus=" + encodeURIComponent("" + sortStatus) + "&";
        if (isSearchSku === null)
            throw new Error("The parameter 'isSearchSku' cannot be null.");
        else if (isSearchSku !== undefined)
            url_ += "IsSearchSku=" + encodeURIComponent("" + isSearchSku) + "&";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (language === null)
            throw new Error("The parameter 'language' cannot be null.");
        else if (language !== undefined)
            url_ += "Language=" + encodeURIComponent("" + language) + "&";
        if (region === null)
            throw new Error("The parameter 'region' cannot be null.");
        else if (region !== undefined)
            url_ += "Region=" + encodeURIComponent("" + region) + "&";
        if (brandIds === null)
            throw new Error("The parameter 'brandIds' cannot be null.");
        else if (brandIds !== undefined)
            brandIds && brandIds.forEach(item => { url_ += "BrandIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsByStoreId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByStoreId(<any>response_);
                } catch (e) {
                    return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProuctListOutPutPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByStoreId(response: HttpResponseBase): Observable<ProuctListOutPutPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProuctListOutPutPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProuctListOutPutPagedResultDto>(<any>null);
    }
}

@Injectable()
export class TagServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_PRODUCT_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://119.3.154.130:8005";
    }

    /**
     * 获取tags列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTags(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTags?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * 导出tag到excel
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTagsToExcel(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsToExcel(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * 根据type获得tags列表
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param type (optional) 
     * @return Success
     */
    getTagsByType(filter: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, type: TagType | undefined): Observable<TagDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/GetTagsByType?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTagsByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTagsByType(<any>response_);
                } catch (e) {
                    return <Observable<TagDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTagsByType(response: HttpResponseBase): Observable<TagDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDtoPagedResultDto>(<any>null);
    }

    /**
     * 创建tag
     * @param body (optional) 
     * @return Success
     */
    createTag(body: CreateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/CreateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * 更新tag
     * @param body (optional) 
     * @return Success
     */
    updateTag(body: UpdateTagInput | undefined): Observable<TagDto> {
        let url_ = this.baseUrl + "/api/services/app/Tag/UpdateTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagDto>(<any>null);
    }

    /**
     * 删除单个tag
     * @param id (optional) 
     * @return Success
     */
    deleteTag(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tag/DeleteTag?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据排序号码获取top数量的tag
     * @param count (optional) 
     * @return Success
     */
    top(count: number | undefined): Observable<Int64IdNameDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Tag/Top?";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTop(<any>response_);
                } catch (e) {
                    return <Observable<Int64IdNameDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64IdNameDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processTop(response: HttpResponseBase): Observable<Int64IdNameDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Int64IdNameDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64IdNameDto[]>(<any>null);
    }
}

export class ActivePromotionInput implements IActivePromotionInput {
    promotionId!: string | undefined;
    activeTime!: moment.Moment;
    md5!: string | undefined;
    deletePromotion!: boolean | undefined;

    constructor(data?: IActivePromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            this.activeTime = _data["activeTime"] ? moment(_data["activeTime"].toString()) : <any>undefined;
            this.md5 = _data["md5"];
            this.deletePromotion = _data["deletePromotion"];
        }
    }

    static fromJS(data: any): ActivePromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivePromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        data["activeTime"] = this.activeTime ? this.activeTime.toISOString() : <any>undefined;
        data["md5"] = this.md5;
        data["deletePromotion"] = this.deletePromotion;
        return data; 
    }
}

export interface IActivePromotionInput {
    promotionId: string | undefined;
    activeTime: moment.Moment;
    md5: string | undefined;
    deletePromotion: boolean | undefined;
}

export class AddOrUpdateOutPutInStorageBillInput implements IAddOrUpdateOutPutInStorageBillInput {
    id!: number | undefined;
    /** orderNo */
    outerId!: string | undefined;
    storeId!: number | undefined;
    /** DEVICE */
    from!: string | undefined;
    outPutInStorageType!: OutPutInStorageType;
    descrtption!: string | undefined;
    outPutInStorageSkus!: OutPutInStorageSku[] | undefined;

    constructor(data?: IAddOrUpdateOutPutInStorageBillInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.storeId = _data["storeId"];
            this.from = _data["from"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.descrtption = _data["descrtption"];
            if (Array.isArray(_data["outPutInStorageSkus"])) {
                this.outPutInStorageSkus = [] as any;
                for (let item of _data["outPutInStorageSkus"])
                    this.outPutInStorageSkus!.push(OutPutInStorageSku.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateOutPutInStorageBillInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateOutPutInStorageBillInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["storeId"] = this.storeId;
        data["from"] = this.from;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["descrtption"] = this.descrtption;
        if (Array.isArray(this.outPutInStorageSkus)) {
            data["outPutInStorageSkus"] = [];
            for (let item of this.outPutInStorageSkus)
                data["outPutInStorageSkus"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateOutPutInStorageBillInput {
    id: number | undefined;
    /** orderNo */
    outerId: string | undefined;
    storeId: number | undefined;
    /** DEVICE */
    from: string | undefined;
    outPutInStorageType: OutPutInStorageType;
    descrtption: string | undefined;
    outPutInStorageSkus: OutPutInStorageSku[] | undefined;
}

export class AddOrUpdateProductCategoryInput implements IAddOrUpdateProductCategoryInput {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    parentCode!: string | undefined;
    code!: string | undefined;
    name!: string;
    picUrl!: string | undefined;
    sortOrder!: number;
    fromType!: string | undefined;

    constructor(data?: IAddOrUpdateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.parentCode = _data["parentCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
            this.sortOrder = _data["sortOrder"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): AddOrUpdateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["parentCode"] = this.parentCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        data["sortOrder"] = this.sortOrder;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IAddOrUpdateProductCategoryInput {
    tenantId: number;
    organizationUnitId: number | undefined;
    parentCode: string | undefined;
    code: string | undefined;
    name: string;
    picUrl: string | undefined;
    sortOrder: number;
    fromType: string | undefined;
}

export class AddOrUpdateProductsToPromotionInput implements IAddOrUpdateProductsToPromotionInput {
    promotionId!: number;
    productPromotionInputs!: ProductPromotionInput[] | undefined;

    constructor(data?: IAddOrUpdateProductsToPromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            if (Array.isArray(_data["productPromotionInputs"])) {
                this.productPromotionInputs = [] as any;
                for (let item of _data["productPromotionInputs"])
                    this.productPromotionInputs!.push(ProductPromotionInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddOrUpdateProductsToPromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateProductsToPromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        if (Array.isArray(this.productPromotionInputs)) {
            data["productPromotionInputs"] = [];
            for (let item of this.productPromotionInputs)
                data["productPromotionInputs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddOrUpdateProductsToPromotionInput {
    promotionId: number;
    productPromotionInputs: ProductPromotionInput[] | undefined;
}

export class AddOrUpdatePromotionInput implements IAddOrUpdatePromotionInput {
    id!: number | undefined;
    outerId!: string | undefined;
    name!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    attribute!: any | undefined;
    otherNeed!: string | undefined;
    otherSend!: string | undefined;
    fromType!: string | undefined;
    promotionType!: PromotionTypeEnum;
    discountType!: DiscountType;
    discountAmount!: number | undefined;

    constructor(data?: IAddOrUpdatePromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.attribute = _data["attribute"];
            this.otherNeed = _data["otherNeed"];
            this.otherSend = _data["otherSend"];
            this.fromType = _data["fromType"];
            this.promotionType = _data["promotionType"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): AddOrUpdatePromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdatePromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["attribute"] = this.attribute;
        data["otherNeed"] = this.otherNeed;
        data["otherSend"] = this.otherSend;
        data["fromType"] = this.fromType;
        data["promotionType"] = this.promotionType;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        return data; 
    }
}

export interface IAddOrUpdatePromotionInput {
    id: number | undefined;
    outerId: string | undefined;
    name: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    attribute: any | undefined;
    otherNeed: string | undefined;
    otherSend: string | undefined;
    fromType: string | undefined;
    promotionType: PromotionTypeEnum;
    discountType: DiscountType;
    discountAmount: number | undefined;
}

export class AddStorageCheckInput implements IAddStorageCheckInput {
    storeId!: number | undefined;
    storeOuterId!: string | undefined;
    storageOuterId!: string | undefined;
    skuQuantity!: SkuQuantity[] | undefined;

    constructor(data?: IAddStorageCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.storeOuterId = _data["storeOuterId"];
            this.storageOuterId = _data["storageOuterId"];
            if (Array.isArray(_data["skuQuantity"])) {
                this.skuQuantity = [] as any;
                for (let item of _data["skuQuantity"])
                    this.skuQuantity!.push(SkuQuantity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddStorageCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddStorageCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["storeOuterId"] = this.storeOuterId;
        data["storageOuterId"] = this.storageOuterId;
        if (Array.isArray(this.skuQuantity)) {
            data["skuQuantity"] = [];
            for (let item of this.skuQuantity)
                data["skuQuantity"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAddStorageCheckInput {
    storeId: number | undefined;
    storeOuterId: string | undefined;
    storageOuterId: string | undefined;
    skuQuantity: SkuQuantity[] | undefined;
}

export class ApplyFormDto implements IApplyFormDto {
    reason!: string | undefined;
    applyStatus!: string | undefined;
    applyType!: string | undefined;
    wanted!: string | undefined;
    resultMessage!: string | undefined;
    applyUserName!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplyFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyStatus = _data["applyStatus"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            this.resultMessage = _data["resultMessage"];
            this.applyUserName = _data["applyUserName"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplyFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyStatus"] = this.applyStatus;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        data["resultMessage"] = this.resultMessage;
        data["applyUserName"] = this.applyUserName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplyFormDto {
    reason: string | undefined;
    applyStatus: string | undefined;
    applyType: string | undefined;
    wanted: string | undefined;
    resultMessage: string | undefined;
    applyUserName: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ApplyFormDtoPagedResultDto implements IApplyFormDtoPagedResultDto {
    totalCount!: number;
    items!: ApplyFormDto[] | undefined;

    constructor(data?: IApplyFormDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplyFormDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplyFormDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyFormDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplyFormDtoPagedResultDto {
    totalCount: number;
    items: ApplyFormDto[] | undefined;
}

export enum ApplyFormType {
    Product = 0,
    Ads = 1,
    App = 2,
    Device = 3,
    Sku = 4,
    Coupon = 5,
    Brand = 6,
}

export enum ApplyStatus {
    Applied = 0,
    Cancel = 1,
    Accepted = 2,
    Rejected = 3,
}

export enum ApplyWanted {
    Online = 0,
    Offline = 1,
}

export class AuditApplyFormInput implements IAuditApplyFormInput {
    applyFormId!: number;
    applyStatus!: ApplyStatus;
    resultMessage!: string | undefined;

    constructor(data?: IAuditApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applyFormId = _data["applyFormId"];
            this.applyStatus = _data["applyStatus"];
            this.resultMessage = _data["resultMessage"];
        }
    }

    static fromJS(data: any): AuditApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applyFormId"] = this.applyFormId;
        data["applyStatus"] = this.applyStatus;
        data["resultMessage"] = this.resultMessage;
        return data; 
    }
}

export interface IAuditApplyFormInput {
    applyFormId: number;
    applyStatus: ApplyStatus;
    resultMessage: string | undefined;
}

export enum AuditStatus {
    Offline = 0,
    Online = 1,
}

export class AwardRule implements IAwardRule {
    pointAwardable!: boolean;
    awardAmount!: number;

    constructor(data?: IAwardRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pointAwardable = _data["pointAwardable"];
            this.awardAmount = _data["awardAmount"];
        }
    }

    static fromJS(data: any): AwardRule {
        data = typeof data === 'object' ? data : {};
        let result = new AwardRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pointAwardable"] = this.pointAwardable;
        data["awardAmount"] = this.awardAmount;
        return data; 
    }
}

export interface IAwardRule {
    pointAwardable: boolean;
    awardAmount: number;
}

export class BatchTaskLogDto implements IBatchTaskLogDto {
    name!: string | undefined;
    batchType!: string | undefined;
    completedCount!: number;
    totalCount!: number;
    status!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IBatchTaskLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.batchType = _data["batchType"];
            this.completedCount = _data["completedCount"];
            this.totalCount = _data["totalCount"];
            this.status = _data["status"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BatchTaskLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchTaskLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["batchType"] = this.batchType;
        data["completedCount"] = this.completedCount;
        data["totalCount"] = this.totalCount;
        data["status"] = this.status;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBatchTaskLogDto {
    name: string | undefined;
    batchType: string | undefined;
    completedCount: number;
    totalCount: number;
    status: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class BatchTaskLogDtoPagedResultDto implements IBatchTaskLogDtoPagedResultDto {
    totalCount!: number;
    items!: BatchTaskLogDto[] | undefined;

    constructor(data?: IBatchTaskLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BatchTaskLogDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BatchTaskLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchTaskLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBatchTaskLogDtoPagedResultDto {
    totalCount: number;
    items: BatchTaskLogDto[] | undefined;
}

export class BrandIdAndProductIdsDto implements IBrandIdAndProductIdsDto {
    brandId!: number;
    brandName!: string | undefined;
    productIds!: number[] | undefined;

    constructor(data?: IBrandIdAndProductIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BrandIdAndProductIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandIdAndProductIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        return data; 
    }
}

export interface IBrandIdAndProductIdsDto {
    brandId: number;
    brandName: string | undefined;
    productIds: number[] | undefined;
}

export class BrandIdAndSkuIdsDto implements IBrandIdAndSkuIdsDto {
    brandId!: number;
    brandName!: string | undefined;
    skuIds!: number[] | undefined;
    sku_Ids!: string[] | undefined;

    constructor(data?: IBrandIdAndSkuIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            if (Array.isArray(_data["sku_Ids"])) {
                this.sku_Ids = [] as any;
                for (let item of _data["sku_Ids"])
                    this.sku_Ids!.push(item);
            }
        }
    }

    static fromJS(data: any): BrandIdAndSkuIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandIdAndSkuIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        if (Array.isArray(this.sku_Ids)) {
            data["sku_Ids"] = [];
            for (let item of this.sku_Ids)
                data["sku_Ids"].push(item);
        }
        return data; 
    }
}

export interface IBrandIdAndSkuIdsDto {
    brandId: number;
    brandName: string | undefined;
    skuIds: number[] | undefined;
    sku_Ids: string[] | undefined;
}

export class BrandProductDto implements IBrandProductDto {
    items!: BrandIdAndProductIdsDto[] | undefined;

    constructor(data?: IBrandProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandIdAndProductIdsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrandProductDto {
    items: BrandIdAndProductIdsDto[] | undefined;
}

export class BrandSkuDto implements IBrandSkuDto {
    items!: BrandIdAndSkuIdsDto[] | undefined;

    constructor(data?: IBrandSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BrandIdAndSkuIdsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBrandSkuDto {
    items: BrandIdAndSkuIdsDto[] | undefined;
}

export class CargoInfoForWeimobActivityDto implements ICargoInfoForWeimobActivityDto {
    orderNo!: number | undefined;
    siteId!: number | undefined;
    selfPickupcode!: string | undefined;
    outerId!: string | undefined;
    cargoRoadId!: number | undefined;
    errorMessage!: string | undefined;

    constructor(data?: ICargoInfoForWeimobActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNo = _data["orderNo"];
            this.siteId = _data["siteId"];
            this.selfPickupcode = _data["selfPickupcode"];
            this.outerId = _data["outerId"];
            this.cargoRoadId = _data["cargoRoadId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CargoInfoForWeimobActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CargoInfoForWeimobActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNo"] = this.orderNo;
        data["siteId"] = this.siteId;
        data["selfPickupcode"] = this.selfPickupcode;
        data["outerId"] = this.outerId;
        data["cargoRoadId"] = this.cargoRoadId;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface ICargoInfoForWeimobActivityDto {
    orderNo: number | undefined;
    siteId: number | undefined;
    selfPickupcode: string | undefined;
    outerId: string | undefined;
    cargoRoadId: number | undefined;
    errorMessage: string | undefined;
}

export enum CargoType {
    Product = 0,
    Sku = 1,
    Award = 2,
}

export class CouponDto implements ICouponDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    /** 优惠券其他平台id */
    outerId!: number;
    /** 面额 */
    amount!: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId!: string | undefined;
    /** 优惠券名称 */
    title!: string | undefined;
    /** 优惠券图片 */
    pictures!: string | undefined;
    /** 优惠券生效时间 */
    start_time!: moment.Moment;
    /** 优惠券的截止日期 */
    end_time!: moment.Moment;
    /** 优惠券地址 */
    url!: string | undefined;
    auditStatus!: AuditStatus;
    /** 外部定义的 */
    code!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ICouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.outerId = _data["outerId"];
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? moment(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? moment(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["outerId"] = this.outerId;
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICouponDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    /** 优惠券其他平台id */
    outerId: number;
    /** 面额 */
    amount: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId: string | undefined;
    /** 优惠券名称 */
    title: string | undefined;
    /** 优惠券图片 */
    pictures: string | undefined;
    /** 优惠券生效时间 */
    start_time: moment.Moment;
    /** 优惠券的截止日期 */
    end_time: moment.Moment;
    /** 优惠券地址 */
    url: string | undefined;
    auditStatus: AuditStatus;
    /** 外部定义的 */
    code: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class CouponDtoPagedResultDto implements ICouponDtoPagedResultDto {
    totalCount!: number;
    items!: CouponDto[] | undefined;

    constructor(data?: ICouponDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CouponDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICouponDtoPagedResultDto {
    totalCount: number;
    items: CouponDto[] | undefined;
}

export class CouponOutDto implements ICouponOutDto {
    id!: number;
    creationTime!: moment.Moment;
    /** 面额 */
    amount!: number;
    /** 优惠券名称 */
    title!: string | undefined;
    /** 优惠券图片 */
    pictures!: string | undefined;
    /** 优惠券生效时间 */
    start_time!: moment.Moment;
    /** 优惠券的截止日期 */
    end_time!: moment.Moment;
    /** 优惠券地址 */
    url!: string | undefined;
    auditStatus!: AuditStatus;
    /** 外部定义的 */
    code!: string | undefined;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: ICouponOutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.title = _data["title"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? moment(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? moment(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CouponOutDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponOutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["title"] = this.title;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICouponOutDto {
    id: number;
    creationTime: moment.Moment;
    /** 面额 */
    amount: number;
    /** 优惠券名称 */
    title: string | undefined;
    /** 优惠券图片 */
    pictures: string | undefined;
    /** 优惠券生效时间 */
    start_time: moment.Moment;
    /** 优惠券的截止日期 */
    end_time: moment.Moment;
    /** 优惠券地址 */
    url: string | undefined;
    auditStatus: AuditStatus;
    /** 外部定义的 */
    code: string | undefined;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class CouponOutDtoPagedResultDto implements ICouponOutDtoPagedResultDto {
    totalCount!: number;
    items!: CouponOutDto[] | undefined;

    constructor(data?: ICouponOutDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CouponOutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponOutDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponOutDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICouponOutDtoPagedResultDto {
    totalCount: number;
    items: CouponOutDto[] | undefined;
}

export class CreateApplyFormInput implements ICreateApplyFormInput {
    reason!: string | undefined;
    applyType!: ApplyFormType;
    wanted!: ApplyWanted;
    itemids!: number[] | undefined;
    options!: string | undefined;

    constructor(data?: ICreateApplyFormInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reason = _data["reason"];
            this.applyType = _data["applyType"];
            this.wanted = _data["wanted"];
            if (Array.isArray(_data["itemids"])) {
                this.itemids = [] as any;
                for (let item of _data["itemids"])
                    this.itemids!.push(item);
            }
            this.options = _data["options"];
        }
    }

    static fromJS(data: any): CreateApplyFormInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplyFormInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reason"] = this.reason;
        data["applyType"] = this.applyType;
        data["wanted"] = this.wanted;
        if (Array.isArray(this.itemids)) {
            data["itemids"] = [];
            for (let item of this.itemids)
                data["itemids"].push(item);
        }
        data["options"] = this.options;
        return data; 
    }
}

export interface ICreateApplyFormInput {
    reason: string | undefined;
    applyType: ApplyFormType;
    wanted: ApplyWanted;
    itemids: number[] | undefined;
    options: string | undefined;
}

export class CreateCouponByTicketInput implements ICreateCouponByTicketInput {
    id!: number;
    creationTime!: moment.Moment;
    name!: string | undefined;
    displayName!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    avaliableDays!: number | undefined;
    expireTime!: moment.Moment | undefined;
    isTaked!: boolean;
    description!: string | undefined;
    ticketType!: TicketType;
    takeType!: TakeType;
    value!: number;
    useCondition!: TicketUseCondition;
    takeCondition!: string[] | undefined;
    usage!: string | undefined;
    picUrl!: string | undefined;
    color!: string | undefined;
    limitTimes!: number | undefined;
    takeTimes!: number | undefined;
    repeatTakeTimes!: number;
    mergeUse!: boolean;
    ticketStatus!: AuditStatus;

    constructor(data?: ICreateCouponByTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.avaliableDays = _data["avaliableDays"];
            this.expireTime = _data["expireTime"] ? moment(_data["expireTime"].toString()) : <any>undefined;
            this.isTaked = _data["isTaked"];
            this.description = _data["description"];
            this.ticketType = _data["ticketType"];
            this.takeType = _data["takeType"];
            this.value = _data["value"];
            this.useCondition = _data["useCondition"] ? TicketUseCondition.fromJS(_data["useCondition"]) : <any>undefined;
            if (Array.isArray(_data["takeCondition"])) {
                this.takeCondition = [] as any;
                for (let item of _data["takeCondition"])
                    this.takeCondition!.push(item);
            }
            this.usage = _data["usage"];
            this.picUrl = _data["picUrl"];
            this.color = _data["color"];
            this.limitTimes = _data["limitTimes"];
            this.takeTimes = _data["takeTimes"];
            this.repeatTakeTimes = _data["repeatTakeTimes"];
            this.mergeUse = _data["mergeUse"];
            this.ticketStatus = _data["ticketStatus"];
        }
    }

    static fromJS(data: any): CreateCouponByTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponByTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["avaliableDays"] = this.avaliableDays;
        data["expireTime"] = this.expireTime ? this.expireTime.toISOString() : <any>undefined;
        data["isTaked"] = this.isTaked;
        data["description"] = this.description;
        data["ticketType"] = this.ticketType;
        data["takeType"] = this.takeType;
        data["value"] = this.value;
        data["useCondition"] = this.useCondition ? this.useCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.takeCondition)) {
            data["takeCondition"] = [];
            for (let item of this.takeCondition)
                data["takeCondition"].push(item);
        }
        data["usage"] = this.usage;
        data["picUrl"] = this.picUrl;
        data["color"] = this.color;
        data["limitTimes"] = this.limitTimes;
        data["takeTimes"] = this.takeTimes;
        data["repeatTakeTimes"] = this.repeatTakeTimes;
        data["mergeUse"] = this.mergeUse;
        data["ticketStatus"] = this.ticketStatus;
        return data; 
    }
}

export interface ICreateCouponByTicketInput {
    id: number;
    creationTime: moment.Moment;
    name: string | undefined;
    displayName: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    avaliableDays: number | undefined;
    expireTime: moment.Moment | undefined;
    isTaked: boolean;
    description: string | undefined;
    ticketType: TicketType;
    takeType: TakeType;
    value: number;
    useCondition: TicketUseCondition;
    takeCondition: string[] | undefined;
    usage: string | undefined;
    picUrl: string | undefined;
    color: string | undefined;
    limitTimes: number | undefined;
    takeTimes: number | undefined;
    repeatTakeTimes: number;
    mergeUse: boolean;
    ticketStatus: AuditStatus;
}

export class CreateCouponInput implements ICreateCouponInput {
    /** 面额 */
    amount!: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId!: string | undefined;
    /** 优惠券名称 */
    title!: string;
    /** 优惠券其它平台的Id */
    outerId!: string | undefined;
    /** 优惠券图片 */
    pictures!: string | undefined;
    /** 优惠券生效时间 */
    start_time!: moment.Moment;
    /** 优惠券的截止日期 */
    end_time!: moment.Moment;
    /** 优惠券地址 */
    url!: string | undefined;
    auditStatus!: AuditStatus;
    /** 外部定义的 */
    code!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: ICreateCouponInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? moment(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? moment(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): CreateCouponInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCouponInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ICreateCouponInput {
    /** 面额 */
    amount: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId: string | undefined;
    /** 优惠券名称 */
    title: string;
    /** 优惠券其它平台的Id */
    outerId: string | undefined;
    /** 优惠券图片 */
    pictures: string | undefined;
    /** 优惠券生效时间 */
    start_time: moment.Moment;
    /** 优惠券的截止日期 */
    end_time: moment.Moment;
    /** 优惠券地址 */
    url: string | undefined;
    auditStatus: AuditStatus;
    /** 外部定义的 */
    code: string | undefined;
    organizationUnitId: number | undefined;
}

export class CreateEntityResourceInput implements ICreateEntityResourceInput {
    resouceId!: number;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    entityId!: number;
    orderNumber!: number;
    fromType!: string | undefined;

    constructor(data?: ICreateEntityResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resouceId = _data["resouceId"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.entityId = _data["entityId"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateEntityResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntityResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resouceId"] = this.resouceId;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["entityId"] = this.entityId;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateEntityResourceInput {
    resouceId: number;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    entityId: number;
    orderNumber: number;
    fromType: string | undefined;
}

export class CreateLikeInfoInput implements ICreateLikeInfoInput {
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: ICreateLikeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateLikeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLikeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateLikeInfoInput {
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class CreateLikeItemInput implements ICreateLikeItemInput {
    skuId!: number;
    likeInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: ICreateLikeItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.likeInfoId = _data["likeInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): CreateLikeItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLikeItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["likeInfoId"] = this.likeInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface ICreateLikeItemInput {
    skuId: number;
    likeInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export class CreateMatchInfoInput implements ICreateMatchInfoInput {
    orderNumber!: number;
    /** 展示图 */
    showImage!: string | undefined;
    /** 搭配效果大图 */
    bImg!: string | undefined;
    /** 搭配效果中图 */
    mImg!: string | undefined;
    /** 搭配效果小图 */
    sImg!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    skus!: MainSku[] | undefined;
    description!: string | undefined;

    constructor(data?: ICreateMatchInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(MainSku.fromJS(item));
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateMatchInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateMatchInfoInput {
    orderNumber: number;
    /** 展示图 */
    showImage: string | undefined;
    /** 搭配效果大图 */
    bImg: string | undefined;
    /** 搭配效果中图 */
    mImg: string | undefined;
    /** 搭配效果小图 */
    sImg: string | undefined;
    name: string | undefined;
    code: string | undefined;
    skus: MainSku[] | undefined;
    description: string | undefined;
}

export class CreateMatchItemInput implements ICreateMatchItemInput {
    skuId!: number;
    matchInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: ICreateMatchItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.matchInfoId = _data["matchInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): CreateMatchItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMatchItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["matchInfoId"] = this.matchInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface ICreateMatchItemInput {
    skuId: number;
    matchInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export class CreateProductCategoryInput implements ICreateProductCategoryInput {
    /** 可被理解的分类唯一编码. */
    categoryCode!: string | undefined;
    /** 分类的名称 */
    name!: string;
    /** 父分类 */
    parentCategoryId!: number | undefined;
    /** 分类的图片 */
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: ICreateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateProductCategoryInput {
    /** 可被理解的分类唯一编码. */
    categoryCode: string | undefined;
    /** 分类的名称 */
    name: string;
    /** 父分类 */
    parentCategoryId: number | undefined;
    /** 分类的图片 */
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class CreateProductCommentInput implements ICreateProductCommentInput {
    /** 评论者的用户名 */
    userName!: string | undefined;
    /** 评论者的头像 */
    avatorUrl!: string | undefined;
    /** 评论的内容 */
    content!: string | undefined;
    productId!: number;
    /** 评论时间 */
    commentDateTime!: moment.Moment | undefined;
    orderNumber!: number;

    constructor(data?: ICreateProductCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.productId = _data["productId"];
            this.commentDateTime = _data["commentDateTime"] ? moment(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): CreateProductCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["productId"] = this.productId;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface ICreateProductCommentInput {
    /** 评论者的用户名 */
    userName: string | undefined;
    /** 评论者的头像 */
    avatorUrl: string | undefined;
    /** 评论的内容 */
    content: string | undefined;
    productId: number;
    /** 评论时间 */
    commentDateTime: moment.Moment | undefined;
    orderNumber: number;
}

export class CreateProductInput implements ICreateProductInput {
    /** 商品 Id */
    itemId!: string;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    /** 商品名称 */
    title!: string | undefined;
    /** 二级标题 */
    subTitle!: string | undefined;
    /** 商品主图 */
    picUrl!: string | undefined;
    /** 商品分类 */
    categorys!: number[] | undefined;
    /** 商品关键字 */
    keywords!: string | undefined;
    /** 商品的标签 */
    tags!: number[] | undefined;
    /** 商品库存 */
    quantity!: number;
    /** 数据来源 */
    fromType!: string | undefined;
    /** 价格 */
    price!: number;
    /** 价格 */
    price2!: number | undefined;
    /** 优惠价 */
    promPrice!: number | undefined;
    /** 总销量 */
    salesVolume!: number;
    orderNumber!: number;
    barcode!: string | undefined;
    /** 状态 */
    auditStatus!: number;
    /** 商品备注信息 */
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    material3DUrl!: string | undefined;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    organizationUnitId!: number | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: ICreateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.material3DUrl = _data["material3DUrl"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["material3DUrl"] = this.material3DUrl;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateProductInput {
    /** 商品 Id */
    itemId: string;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    /** 商品名称 */
    title: string | undefined;
    /** 二级标题 */
    subTitle: string | undefined;
    /** 商品主图 */
    picUrl: string | undefined;
    /** 商品分类 */
    categorys: number[] | undefined;
    /** 商品关键字 */
    keywords: string | undefined;
    /** 商品的标签 */
    tags: number[] | undefined;
    /** 商品库存 */
    quantity: number;
    /** 数据来源 */
    fromType: string | undefined;
    /** 价格 */
    price: number;
    /** 价格 */
    price2: number | undefined;
    /** 优惠价 */
    promPrice: number | undefined;
    /** 总销量 */
    salesVolume: number;
    orderNumber: number;
    barcode: string | undefined;
    /** 状态 */
    auditStatus: number;
    /** 商品备注信息 */
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    material3DUrl: string | undefined;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    organizationUnitId: number | undefined;
    pointRule: ProductPointRule;
}

export class CreateProductOnlineInfoInput implements ICreateProductOnlineInfoInput {
    productId!: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId!: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商品的PID */
    pid!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: ICreateProductOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): CreateProductOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ICreateProductOnlineInfoInput {
    productId: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商品的PID */
    pid: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class CreatePropertyInput implements ICreatePropertyInput {
    orderNumber!: number;
    /** 属性的名称 */
    name!: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage!: boolean;
    /** 是否是销售属性 */
    isForSale!: boolean;
    /** 来源类型 */
    fromType!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreatePropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreatePropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreatePropertyInput {
    orderNumber: number;
    /** 属性的名称 */
    name: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage: boolean;
    /** 是否是销售属性 */
    isForSale: boolean;
    /** 来源类型 */
    fromType: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class CreatePropertyValueInput implements ICreatePropertyValueInput {
    orderNumber!: number;
    propertyId!: number;
    value!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: ICreatePropertyValueInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): CreatePropertyValueInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePropertyValueInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ICreatePropertyValueInput {
    orderNumber: number;
    propertyId: number;
    value: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class CreateSkuInput implements ICreateSkuInput {
    productId!: number;
    /** Sku Id */
    sku_id!: string | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    /** Sku 名称 */
    title!: string | undefined;
    /** Sku 价格 */
    price!: number;
    /** 价格 */
    price2!: number | undefined;
    /** Sku 促销价 */
    promPrice!: number | undefined;
    /** 总销量 */
    salesVolume!: number;
    /** Sku 库存 */
    quantity!: number;
    /** Sku 主图 */
    picUrl!: string | undefined;
    /** Sku 针对年龄段 */
    ageScope!: string | undefined;
    /** Sku 针对性别 */
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    tags!: number[] | undefined;
    propertyValueIds!: number[] | undefined;
    starLevel!: number | undefined;
    keywords!: string | undefined;
    pointRule!: ProductPointRule;
    weight!: number | undefined;

    constructor(data?: ICreateSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku_id = _data["sku_id"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["propertyValueIds"])) {
                this.propertyValueIds = [] as any;
                for (let item of _data["propertyValueIds"])
                    this.propertyValueIds!.push(item);
            }
            this.starLevel = _data["starLevel"];
            this.keywords = _data["keywords"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): CreateSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku_id"] = this.sku_id;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.propertyValueIds)) {
            data["propertyValueIds"] = [];
            for (let item of this.propertyValueIds)
                data["propertyValueIds"].push(item);
        }
        data["starLevel"] = this.starLevel;
        data["keywords"] = this.keywords;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface ICreateSkuInput {
    productId: number;
    /** Sku Id */
    sku_id: string | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    /** Sku 名称 */
    title: string | undefined;
    /** Sku 价格 */
    price: number;
    /** 价格 */
    price2: number | undefined;
    /** Sku 促销价 */
    promPrice: number | undefined;
    /** 总销量 */
    salesVolume: number;
    /** Sku 库存 */
    quantity: number;
    /** Sku 主图 */
    picUrl: string | undefined;
    /** Sku 针对年龄段 */
    ageScope: string | undefined;
    /** Sku 针对性别 */
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    tags: number[] | undefined;
    propertyValueIds: number[] | undefined;
    starLevel: number | undefined;
    keywords: string | undefined;
    pointRule: ProductPointRule;
    weight: number | undefined;
}

export class CreateSkuOnlineInfoInput implements ICreateSkuOnlineInfoInput {
    skuId!: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId!: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商品的PID */
    sku_ID!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: ICreateSkuOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): CreateSkuOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ICreateSkuOnlineInfoInput {
    skuId: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商品的PID */
    sku_ID: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class CreateSkuResourceInput implements ICreateSkuResourceInput {
    resouceId!: number;
    usage!: string | undefined;
    description!: string | undefined;
    content!: string | undefined;
    name!: string | undefined;
    skuId!: number;
    fromType!: string | undefined;

    constructor(data?: ICreateSkuResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resouceId = _data["resouceId"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.content = _data["content"];
            this.name = _data["name"];
            this.skuId = _data["skuId"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): CreateSkuResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resouceId"] = this.resouceId;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["content"] = this.content;
        data["name"] = this.name;
        data["skuId"] = this.skuId;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface ICreateSkuResourceInput {
    resouceId: number;
    usage: string | undefined;
    description: string | undefined;
    content: string | undefined;
    name: string | undefined;
    skuId: number;
    fromType: string | undefined;
}

export class CreateSkuRfidInput implements ICreateSkuRfidInput {
    storeId!: number | undefined;
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    rfidCode!: string | undefined;

    constructor(data?: ICreateSkuRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.rfidCode = _data["rfidCode"];
        }
    }

    static fromJS(data: any): CreateSkuRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSkuRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["rfidCode"] = this.rfidCode;
        return data; 
    }
}

export interface ICreateSkuRfidInput {
    storeId: number | undefined;
    skuId: number | undefined;
    sku_Id: string | undefined;
    rfidCode: string | undefined;
}

export class CreateTagInput implements ICreateTagInput {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: ICreateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateTagInput {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class DeviceSkusDto implements IDeviceSkusDto {
    /** Sku Id */
    id!: number;
    /** 属于这个sku的商品的数量， */
    quantity!: number;
    title!: string | undefined;
    price!: number;
    promPrice!: number;
    price2!: number | undefined;
    keywords!: string | undefined;
    auditStatus!: AuditStatus;
    picUrl!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    salesVolume!: number;
    starLevel!: number | undefined;
    creationTime!: moment.Moment;
    skuTags!: Int64IdNameDto[] | undefined;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    isDefault!: boolean;

    constructor(data?: IDeviceSkusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.price2 = _data["price2"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.salesVolume = _data["salesVolume"];
            this.starLevel = _data["starLevel"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(Int64IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): DeviceSkusDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSkusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["price2"] = this.price2;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["salesVolume"] = this.salesVolume;
        data["starLevel"] = this.starLevel;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IDeviceSkusDto {
    /** Sku Id */
    id: number;
    /** 属于这个sku的商品的数量， */
    quantity: number;
    title: string | undefined;
    price: number;
    promPrice: number;
    price2: number | undefined;
    keywords: string | undefined;
    auditStatus: AuditStatus;
    picUrl: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    salesVolume: number;
    starLevel: number | undefined;
    creationTime: moment.Moment;
    skuTags: Int64IdNameDto[] | undefined;
    isMine: boolean;
    organizationUnitId: number | undefined;
    isDefault: boolean;
}

export class DeviceSkusDtoPagedResultDto implements IDeviceSkusDtoPagedResultDto {
    totalCount!: number;
    items!: DeviceSkusDto[] | undefined;

    constructor(data?: IDeviceSkusDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceSkusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceSkusDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceSkusDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeviceSkusDtoPagedResultDto {
    totalCount: number;
    items: DeviceSkusDto[] | undefined;
}

export enum DiscountType {
    Voucher = 0,
    Discount = 1,
}

export enum DownloadType {
    Excel = 0,
}

export class EntityFileDto implements IEntityFileDto {
    entityId!: number;
    resourceId!: number;
    name!: string | undefined;
    /** 资源的地址途径 */
    fileUrl!: string | undefined;
    category!: string | undefined;
    fromType!: string | undefined;
    type!: string | undefined;
    created!: moment.Moment | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IEntityFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.resourceId = _data["resourceId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["resourceId"] = this.resourceId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityFileDto {
    entityId: number;
    resourceId: number;
    name: string | undefined;
    /** 资源的地址途径 */
    fileUrl: string | undefined;
    category: string | undefined;
    fromType: string | undefined;
    type: string | undefined;
    created: moment.Moment | undefined;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class EntityFileDtoPagedResultDto implements IEntityFileDtoPagedResultDto {
    totalCount!: number;
    items!: EntityFileDto[] | undefined;

    constructor(data?: IEntityFileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityFileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityFileDtoPagedResultDto {
    totalCount: number;
    items: EntityFileDto[] | undefined;
}

export class EntityFileSdkModel implements IEntityFileSdkModel {
    id!: number;
    name!: string | undefined;
    fileUrl!: string | undefined;
    fromType!: string | undefined;
    type!: string | undefined;
    content!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    md5!: string | undefined;

    constructor(data?: IEntityFileSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.fromType = _data["fromType"];
            this.type = _data["type"];
            this.content = _data["content"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.md5 = _data["md5"];
        }
    }

    static fromJS(data: any): EntityFileSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFileSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["fromType"] = this.fromType;
        data["type"] = this.type;
        data["content"] = this.content;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["md5"] = this.md5;
        return data; 
    }
}

export interface IEntityFileSdkModel {
    id: number;
    name: string | undefined;
    fileUrl: string | undefined;
    fromType: string | undefined;
    type: string | undefined;
    content: string | undefined;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    md5: string | undefined;
}

export class ExportMissionInput implements IExportMissionInput {
    id!: number | undefined;
    name!: string | undefined;
    missEndTime!: moment.Moment | undefined;
    status!: ExportMissionStatus;
    type!: DownloadType;
    downloadUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IExportMissionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.missEndTime = _data["missEndTime"] ? moment(_data["missEndTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
            this.downloadUrl = _data["downloadUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExportMissionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExportMissionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["missEndTime"] = this.missEndTime ? this.missEndTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["downloadUrl"] = this.downloadUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IExportMissionInput {
    id: number | undefined;
    name: string | undefined;
    missEndTime: moment.Moment | undefined;
    status: ExportMissionStatus;
    type: DownloadType;
    downloadUrl: string | undefined;
    from: string | undefined;
}

export enum ExportMissionStatus {
    Acting = 0,
    Success = 1,
    Failed = 2,
}

export class ExportTaskDto implements IExportTaskDto {
    id!: number;
    creationTime!: moment.Moment;
    name!: string | undefined;
    missEndTime!: moment.Moment | undefined;
    status!: ExportMissionStatus;
    type!: DownloadType;
    downloadUrl!: string | undefined;
    from!: string | undefined;

    constructor(data?: IExportTaskDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.missEndTime = _data["missEndTime"] ? moment(_data["missEndTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
            this.downloadUrl = _data["downloadUrl"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): ExportTaskDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportTaskDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["missEndTime"] = this.missEndTime ? this.missEndTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        data["downloadUrl"] = this.downloadUrl;
        data["from"] = this.from;
        return data; 
    }
}

export interface IExportTaskDto {
    id: number;
    creationTime: moment.Moment;
    name: string | undefined;
    missEndTime: moment.Moment | undefined;
    status: ExportMissionStatus;
    type: DownloadType;
    downloadUrl: string | undefined;
    from: string | undefined;
}

export class ExportTaskDtoPagedResultDto implements IExportTaskDtoPagedResultDto {
    totalCount!: number;
    items!: ExportTaskDto[] | undefined;

    constructor(data?: IExportTaskDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExportTaskDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportTaskDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportTaskDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExportTaskDtoPagedResultDto {
    totalCount: number;
    items: ExportTaskDto[] | undefined;
}

export class ExternalSkuDto implements IExternalSkuDto {
    id!: number;
    sku_id!: string | undefined;
    productId!: number;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 事物都该有个名字来表示 */
    subTitle!: string | undefined;
    picUrl!: string | undefined;
    categoryIds!: number[] | undefined;
    keywords!: string | undefined;
    tagIds!: number[] | undefined;
    quantity!: number;
    price!: number;
    price2!: number;
    prom_Price!: number;
    ageScope!: string | undefined;
    gender!: string | undefined;
    barcode!: string | undefined;
    salesVolume!: number;
    orderNumber!: number;
    starLevel!: number;
    isRealSku!: boolean;
    description!: string | undefined;
    auditStatus!: AuditStatus;
    rfideCount!: number;

    constructor(data?: IExternalSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.productId = _data["productId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.prom_Price = _data["prom_Price"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.starLevel = _data["starLevel"];
            this.isRealSku = _data["isRealSku"];
            this.description = _data["description"];
            this.auditStatus = _data["auditStatus"];
            this.rfideCount = _data["rfideCount"];
        }
    }

    static fromJS(data: any): ExternalSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["productId"] = this.productId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["prom_Price"] = this.prom_Price;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["starLevel"] = this.starLevel;
        data["isRealSku"] = this.isRealSku;
        data["description"] = this.description;
        data["auditStatus"] = this.auditStatus;
        data["rfideCount"] = this.rfideCount;
        return data; 
    }
}

export interface IExternalSkuDto {
    id: number;
    sku_id: string | undefined;
    productId: number;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 事物都该有个名字来表示 */
    subTitle: string | undefined;
    picUrl: string | undefined;
    categoryIds: number[] | undefined;
    keywords: string | undefined;
    tagIds: number[] | undefined;
    quantity: number;
    price: number;
    price2: number;
    prom_Price: number;
    ageScope: string | undefined;
    gender: string | undefined;
    barcode: string | undefined;
    salesVolume: number;
    orderNumber: number;
    starLevel: number;
    isRealSku: boolean;
    description: string | undefined;
    auditStatus: AuditStatus;
    rfideCount: number;
}

export class ExternalSkuDtoPagedResultDto implements IExternalSkuDtoPagedResultDto {
    totalCount!: number;
    items!: ExternalSkuDto[] | undefined;

    constructor(data?: IExternalSkuDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalSkuDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalSkuDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSkuDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IExternalSkuDtoPagedResultDto {
    totalCount: number;
    items: ExternalSkuDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class GetCountReportInput implements IGetCountReportInput {
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    storeOrOuList!: IdTypeDto[] | undefined;
    /** coupon,product,sku */
    filter!: string | undefined;

    constructor(data?: IGetCountReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["storeOrOuList"])) {
                this.storeOrOuList = [] as any;
                for (let item of _data["storeOrOuList"])
                    this.storeOrOuList!.push(IdTypeDto.fromJS(item));
            }
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): GetCountReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCountReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        if (Array.isArray(this.storeOrOuList)) {
            data["storeOrOuList"] = [];
            for (let item of this.storeOrOuList)
                data["storeOrOuList"].push(item.toJSON());
        }
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IGetCountReportInput {
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    storeOrOuList: IdTypeDto[] | undefined;
    /** coupon,product,sku */
    filter: string | undefined;
}

export class GetOutPutInStorageBillDto implements IGetOutPutInStorageBillDto {
    id!: number;
    creationTime!: moment.Moment;
    billNo!: string | undefined;
    outerId!: string | undefined;
    skuNumber!: number;
    skuCount!: number;
    description!: string | undefined;
    outPutInStorageType!: OutPutInStorageType;
    from!: string | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    storeId!: number | undefined;

    constructor(data?: IGetOutPutInStorageBillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.billNo = _data["billNo"];
            this.outerId = _data["outerId"];
            this.skuNumber = _data["skuNumber"];
            this.skuCount = _data["skuCount"];
            this.description = _data["description"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.from = _data["from"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageBillDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageBillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["billNo"] = this.billNo;
        data["outerId"] = this.outerId;
        data["skuNumber"] = this.skuNumber;
        data["skuCount"] = this.skuCount;
        data["description"] = this.description;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["from"] = this.from;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IGetOutPutInStorageBillDto {
    id: number;
    creationTime: moment.Moment;
    billNo: string | undefined;
    outerId: string | undefined;
    skuNumber: number;
    skuCount: number;
    description: string | undefined;
    outPutInStorageType: OutPutInStorageType;
    from: string | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    storeId: number | undefined;
}

export class GetOutPutInStorageBillDtoPagedResultDto implements IGetOutPutInStorageBillDtoPagedResultDto {
    totalCount!: number;
    items!: GetOutPutInStorageBillDto[] | undefined;

    constructor(data?: IGetOutPutInStorageBillDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOutPutInStorageBillDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetOutPutInStorageBillDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageBillDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetOutPutInStorageBillDtoPagedResultDto {
    totalCount: number;
    items: GetOutPutInStorageBillDto[] | undefined;
}

export class GetOutPutInStorageBillInput implements IGetOutPutInStorageBillInput {
    storeId!: number[] | undefined;
    ignoreStore!: boolean;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    outPutInStorageType!: OutPutInStorageType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetOutPutInStorageBillInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeId"])) {
                this.storeId = [] as any;
                for (let item of _data["storeId"])
                    this.storeId!.push(item);
            }
            this.ignoreStore = _data["ignoreStore"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageBillInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageBillInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeId)) {
            data["storeId"] = [];
            for (let item of this.storeId)
                data["storeId"].push(item);
        }
        data["ignoreStore"] = this.ignoreStore;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetOutPutInStorageBillInput {
    storeId: number[] | undefined;
    ignoreStore: boolean;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    outPutInStorageType: OutPutInStorageType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetOutPutInStorageRecordDto implements IGetOutPutInStorageRecordDto {
    id!: number;
    number!: number;
    quantityBefore!: number;
    quantityAfter!: number;
    sku!: SkuDto;
    bill!: GetOutPutInStorageBillDto;

    constructor(data?: IGetOutPutInStorageRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.quantityBefore = _data["quantityBefore"];
            this.quantityAfter = _data["quantityAfter"];
            this.sku = _data["sku"] ? SkuDto.fromJS(_data["sku"]) : <any>undefined;
            this.bill = _data["bill"] ? GetOutPutInStorageBillDto.fromJS(_data["bill"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOutPutInStorageRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["quantityBefore"] = this.quantityBefore;
        data["quantityAfter"] = this.quantityAfter;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["bill"] = this.bill ? this.bill.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetOutPutInStorageRecordDto {
    id: number;
    number: number;
    quantityBefore: number;
    quantityAfter: number;
    sku: SkuDto;
    bill: GetOutPutInStorageBillDto;
}

export class GetOutPutInStorageRecordDtoPagedResultDto implements IGetOutPutInStorageRecordDtoPagedResultDto {
    totalCount!: number;
    items!: GetOutPutInStorageRecordDto[] | undefined;

    constructor(data?: IGetOutPutInStorageRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetOutPutInStorageRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetOutPutInStorageRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetOutPutInStorageRecordDtoPagedResultDto {
    totalCount: number;
    items: GetOutPutInStorageRecordDto[] | undefined;
}

export class GetOutPutInStorageRecordInput implements IGetOutPutInStorageRecordInput {
    outPutInStorageBillId!: number | undefined;
    skuId!: number | undefined;
    storeId!: number[] | undefined;
    startTime!: moment.Moment | undefined;
    endtTime!: moment.Moment | undefined;
    ignoreStore!: boolean;
    outPutInStorageType!: OutPutInStorageType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetOutPutInStorageRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outPutInStorageBillId = _data["outPutInStorageBillId"];
            this.skuId = _data["skuId"];
            if (Array.isArray(_data["storeId"])) {
                this.storeId = [] as any;
                for (let item of _data["storeId"])
                    this.storeId!.push(item);
            }
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endtTime = _data["endtTime"] ? moment(_data["endtTime"].toString()) : <any>undefined;
            this.ignoreStore = _data["ignoreStore"];
            this.outPutInStorageType = _data["outPutInStorageType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetOutPutInStorageRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOutPutInStorageRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outPutInStorageBillId"] = this.outPutInStorageBillId;
        data["skuId"] = this.skuId;
        if (Array.isArray(this.storeId)) {
            data["storeId"] = [];
            for (let item of this.storeId)
                data["storeId"].push(item);
        }
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endtTime"] = this.endtTime ? this.endtTime.toISOString() : <any>undefined;
        data["ignoreStore"] = this.ignoreStore;
        data["outPutInStorageType"] = this.outPutInStorageType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetOutPutInStorageRecordInput {
    outPutInStorageBillId: number | undefined;
    skuId: number | undefined;
    storeId: number[] | undefined;
    startTime: moment.Moment | undefined;
    endtTime: moment.Moment | undefined;
    ignoreStore: boolean;
    outPutInStorageType: OutPutInStorageType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetProductBySubKeyAndOuterIdOutput implements IGetProductBySubKeyAndOuterIdOutput {
    id!: number;
    itemId!: string | undefined;
    quantity!: number;
    title!: string | undefined;
    organizationUnitId!: number | undefined;
    /** 一句话营销. */
    subTitle!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: number;
    promPrice!: number;
    barcode!: string | undefined;
    /** 总销量 */
    salesVolume!: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    picUrl!: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount!: number;
    description!: string | undefined;
    isFromBrand!: boolean;
    sellerId!: string | undefined;
    outerId!: string | undefined;
    fromType!: string | undefined;
    hasRealSkus!: boolean;
    propImgs!: ProductDecideImageViewModel[] | undefined;
    categoryIds!: number[] | undefined;
    propValueIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    skus!: SkuSdkModel[] | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    groupQrCodeInfo!: string | undefined;
    orderNumber!: number;
    brandId!: number | undefined;
    brandName!: string | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IGetProductBySubKeyAndOuterIdOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isFromBrand = _data["isFromBrand"];
            this.sellerId = _data["sellerId"];
            this.outerId = _data["outerId"];
            this.fromType = _data["fromType"];
            this.hasRealSkus = _data["hasRealSkus"];
            if (Array.isArray(_data["propImgs"])) {
                this.propImgs = [] as any;
                for (let item of _data["propImgs"])
                    this.propImgs!.push(ProductDecideImageViewModel.fromJS(item));
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.groupQrCodeInfo = _data["groupQrCodeInfo"];
            this.orderNumber = _data["orderNumber"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetProductBySubKeyAndOuterIdOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductBySubKeyAndOuterIdOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["organizationUnitId"] = this.organizationUnitId;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isFromBrand"] = this.isFromBrand;
        data["sellerId"] = this.sellerId;
        data["outerId"] = this.outerId;
        data["fromType"] = this.fromType;
        data["hasRealSkus"] = this.hasRealSkus;
        if (Array.isArray(this.propImgs)) {
            data["propImgs"] = [];
            for (let item of this.propImgs)
                data["propImgs"].push(item.toJSON());
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["groupQrCodeInfo"] = this.groupQrCodeInfo;
        data["orderNumber"] = this.orderNumber;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetProductBySubKeyAndOuterIdOutput {
    id: number;
    itemId: string | undefined;
    quantity: number;
    title: string | undefined;
    organizationUnitId: number | undefined;
    /** 一句话营销. */
    subTitle: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: number;
    promPrice: number;
    barcode: string | undefined;
    /** 总销量 */
    salesVolume: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    picUrl: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount: number;
    description: string | undefined;
    isFromBrand: boolean;
    sellerId: string | undefined;
    outerId: string | undefined;
    fromType: string | undefined;
    hasRealSkus: boolean;
    propImgs: ProductDecideImageViewModel[] | undefined;
    categoryIds: number[] | undefined;
    propValueIds: number[] | undefined;
    tagIds: number[] | undefined;
    skus: SkuSdkModel[] | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    groupQrCodeInfo: string | undefined;
    orderNumber: number;
    brandId: number | undefined;
    brandName: string | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class GetProductIdAndName implements IGetProductIdAndName {
    outerIdAndTypes!: OuterIdAndType[] | undefined;

    constructor(data?: IGetProductIdAndName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["outerIdAndTypes"])) {
                this.outerIdAndTypes = [] as any;
                for (let item of _data["outerIdAndTypes"])
                    this.outerIdAndTypes!.push(OuterIdAndType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductIdAndName {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductIdAndName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.outerIdAndTypes)) {
            data["outerIdAndTypes"] = [];
            for (let item of this.outerIdAndTypes)
                data["outerIdAndTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductIdAndName {
    outerIdAndTypes: OuterIdAndType[] | undefined;
}

export class GetProductPicturesByItemIdInput implements IGetProductPicturesByItemIdInput {
    itemIdTypes!: ItemIdTypeDto[] | undefined;

    constructor(data?: IGetProductPicturesByItemIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemIdTypes"])) {
                this.itemIdTypes = [] as any;
                for (let item of _data["itemIdTypes"])
                    this.itemIdTypes!.push(ItemIdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductPicturesByItemIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPicturesByItemIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemIdTypes)) {
            data["itemIdTypes"] = [];
            for (let item of this.itemIdTypes)
                data["itemIdTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductPicturesByItemIdInput {
    itemIdTypes: ItemIdTypeDto[] | undefined;
}

export class GetProductPicturesInput implements IGetProductPicturesInput {
    idTypes!: IdTypeDto[] | undefined;

    constructor(data?: IGetProductPicturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["idTypes"])) {
                this.idTypes = [] as any;
                for (let item of _data["idTypes"])
                    this.idTypes!.push(IdTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductPicturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPicturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.idTypes)) {
            data["idTypes"] = [];
            for (let item of this.idTypes)
                data["idTypes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductPicturesInput {
    idTypes: IdTypeDto[] | undefined;
}

export class GetProductPromotionDto implements IGetProductPromotionDto {
    id!: number;
    product!: ProductDto;
    discountType!: DiscountType;
    discountValue!: number;
    price!: number;

    constructor(data?: IGetProductPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? ProductDto.fromJS(_data["product"]) : <any>undefined;
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): GetProductPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["price"] = this.price;
        return data; 
    }
}

export interface IGetProductPromotionDto {
    id: number;
    product: ProductDto;
    discountType: DiscountType;
    discountValue: number;
    price: number;
}

export class GetProductPromotionDtoPagedResultDto implements IGetProductPromotionDtoPagedResultDto {
    totalCount!: number;
    items!: GetProductPromotionDto[] | undefined;

    constructor(data?: IGetProductPromotionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetProductPromotionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductPromotionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductPromotionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductPromotionDtoPagedResultDto {
    totalCount: number;
    items: GetProductPromotionDto[] | undefined;
}

export class GetProductsCountAndInventoryDto implements IGetProductsCountAndInventoryDto {
    productCount!: number;
    sku!: number;
    skuCount!: number;
    storage!: Int64IdNameDto[] | undefined;

    constructor(data?: IGetProductsCountAndInventoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productCount = _data["productCount"];
            this.sku = _data["sku"];
            this.skuCount = _data["skuCount"];
            if (Array.isArray(_data["storage"])) {
                this.storage = [] as any;
                for (let item of _data["storage"])
                    this.storage!.push(Int64IdNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetProductsCountAndInventoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsCountAndInventoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCount"] = this.productCount;
        data["sku"] = this.sku;
        data["skuCount"] = this.skuCount;
        if (Array.isArray(this.storage)) {
            data["storage"] = [];
            for (let item of this.storage)
                data["storage"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetProductsCountAndInventoryDto {
    productCount: number;
    sku: number;
    skuCount: number;
    storage: Int64IdNameDto[] | undefined;
}

export class GetProductsInput implements IGetProductsInput {
    currentProductId!: number;
    /** 开始时间（最后更新) */
    startTime!: moment.Moment | undefined;
    /** 结束时间（最后更新） */
    endTime!: moment.Moment | undefined;
    auditStatus!: AuditStatus;
    /** 标签 */
    tagIds!: number[] | undefined;
    /** 分类 */
    catetoryIds!: number[] | undefined;
    /** 价格区间1 */
    price1!: number | undefined;
    /** 价格区间2 */
    price2!: number | undefined;
    stock!: string | undefined;
    salesVolume!: string | undefined;
    /** asc , desc */
    sortStatus!: string | undefined;
    isSearchSku!: boolean | undefined;
    organizationId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    brandIds!: number[] | undefined;
    pointRedeemType!: RedeemType;
    filter!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetProductsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentProductId = _data["currentProductId"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.auditStatus = _data["auditStatus"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["catetoryIds"])) {
                this.catetoryIds = [] as any;
                for (let item of _data["catetoryIds"])
                    this.catetoryIds!.push(item);
            }
            this.price1 = _data["price1"];
            this.price2 = _data["price2"];
            this.stock = _data["stock"];
            this.salesVolume = _data["salesVolume"];
            this.sortStatus = _data["sortStatus"];
            this.isSearchSku = _data["isSearchSku"];
            this.organizationId = _data["organizationId"];
            this.language = _data["language"];
            this.region = _data["region"];
            if (Array.isArray(_data["brandIds"])) {
                this.brandIds = [] as any;
                for (let item of _data["brandIds"])
                    this.brandIds!.push(item);
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.filter = _data["filter"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetProductsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentProductId"] = this.currentProductId;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.catetoryIds)) {
            data["catetoryIds"] = [];
            for (let item of this.catetoryIds)
                data["catetoryIds"].push(item);
        }
        data["price1"] = this.price1;
        data["price2"] = this.price2;
        data["stock"] = this.stock;
        data["salesVolume"] = this.salesVolume;
        data["sortStatus"] = this.sortStatus;
        data["isSearchSku"] = this.isSearchSku;
        data["organizationId"] = this.organizationId;
        data["language"] = this.language;
        data["region"] = this.region;
        if (Array.isArray(this.brandIds)) {
            data["brandIds"] = [];
            for (let item of this.brandIds)
                data["brandIds"].push(item);
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetProductsInput {
    currentProductId: number;
    /** 开始时间（最后更新) */
    startTime: moment.Moment | undefined;
    /** 结束时间（最后更新） */
    endTime: moment.Moment | undefined;
    auditStatus: AuditStatus;
    /** 标签 */
    tagIds: number[] | undefined;
    /** 分类 */
    catetoryIds: number[] | undefined;
    /** 价格区间1 */
    price1: number | undefined;
    /** 价格区间2 */
    price2: number | undefined;
    stock: string | undefined;
    salesVolume: string | undefined;
    /** asc , desc */
    sortStatus: string | undefined;
    isSearchSku: boolean | undefined;
    organizationId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    brandIds: number[] | undefined;
    pointRedeemType: RedeemType;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetPromotioDto implements IGetPromotioDto {
    id!: number;
    outerId!: string | undefined;
    name!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    attribute!: any | undefined;
    otherNeed!: string | undefined;
    otherSend!: string | undefined;
    fromType!: string | undefined;
    promotionType!: PromotionTypeEnum;
    discountType!: DiscountType;
    discountAmount!: number | undefined;

    constructor(data?: IGetPromotioDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.outerId = _data["outerId"];
            this.name = _data["name"];
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.attribute = _data["attribute"];
            this.otherNeed = _data["otherNeed"];
            this.otherSend = _data["otherSend"];
            this.fromType = _data["fromType"];
            this.promotionType = _data["promotionType"];
            this.discountType = _data["discountType"];
            this.discountAmount = _data["discountAmount"];
        }
    }

    static fromJS(data: any): GetPromotioDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPromotioDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["outerId"] = this.outerId;
        data["name"] = this.name;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["attribute"] = this.attribute;
        data["otherNeed"] = this.otherNeed;
        data["otherSend"] = this.otherSend;
        data["fromType"] = this.fromType;
        data["promotionType"] = this.promotionType;
        data["discountType"] = this.discountType;
        data["discountAmount"] = this.discountAmount;
        return data; 
    }
}

export interface IGetPromotioDto {
    id: number;
    outerId: string | undefined;
    name: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    attribute: any | undefined;
    otherNeed: string | undefined;
    otherSend: string | undefined;
    fromType: string | undefined;
    promotionType: PromotionTypeEnum;
    discountType: DiscountType;
    discountAmount: number | undefined;
}

export class GetPromotioDtoPagedResultDto implements IGetPromotioDtoPagedResultDto {
    totalCount!: number;
    items!: GetPromotioDto[] | undefined;

    constructor(data?: IGetPromotioDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetPromotioDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPromotioDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPromotioDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetPromotioDtoPagedResultDto {
    totalCount: number;
    items: GetPromotioDto[] | undefined;
}

export class GetSkuByCodeDto implements IGetSkuByCodeDto {
    id!: number;
    code!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    sku!: SkuCodeDto;
    isPurchased!: boolean;
    purchaseTime!: moment.Moment | undefined;

    constructor(data?: IGetSkuByCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.sku = _data["sku"] ? SkuCodeDto.fromJS(_data["sku"]) : <any>undefined;
            this.isPurchased = _data["isPurchased"];
            this.purchaseTime = _data["purchaseTime"] ? moment(_data["purchaseTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSkuByCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSkuByCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["isPurchased"] = this.isPurchased;
        data["purchaseTime"] = this.purchaseTime ? this.purchaseTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetSkuByCodeDto {
    id: number;
    code: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    sku: SkuCodeDto;
    isPurchased: boolean;
    purchaseTime: moment.Moment | undefined;
}

export class GetSkuRfidDto implements IGetSkuRfidDto {
    id!: number;
    rfidCode!: string | undefined;
    storeId!: number | undefined;
    storeName!: string | undefined;
    storeOuterId!: string | undefined;
    sku!: SkuDto;
    isPurchased!: boolean;
    purchaseTime!: moment.Moment | undefined;

    constructor(data?: IGetSkuRfidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rfidCode = _data["rfidCode"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.storeOuterId = _data["storeOuterId"];
            this.sku = _data["sku"] ? SkuDto.fromJS(_data["sku"]) : <any>undefined;
            this.isPurchased = _data["isPurchased"];
            this.purchaseTime = _data["purchaseTime"] ? moment(_data["purchaseTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSkuRfidDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSkuRfidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rfidCode"] = this.rfidCode;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["storeOuterId"] = this.storeOuterId;
        data["sku"] = this.sku ? this.sku.toJSON() : <any>undefined;
        data["isPurchased"] = this.isPurchased;
        data["purchaseTime"] = this.purchaseTime ? this.purchaseTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IGetSkuRfidDto {
    id: number;
    rfidCode: string | undefined;
    storeId: number | undefined;
    storeName: string | undefined;
    storeOuterId: string | undefined;
    sku: SkuDto;
    isPurchased: boolean;
    purchaseTime: moment.Moment | undefined;
}

export class GetSkuRfidDtoPagedResultDto implements IGetSkuRfidDtoPagedResultDto {
    totalCount!: number;
    items!: GetSkuRfidDto[] | undefined;

    constructor(data?: IGetSkuRfidDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetSkuRfidDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSkuRfidDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSkuRfidDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSkuRfidDtoPagedResultDto {
    totalCount: number;
    items: GetSkuRfidDto[] | undefined;
}

export class GroupDto implements IGroupDto {
    organizationUnitTypeId!: number;
    /** 门店商家自用编码,T-6300182 */
    outerId!: string | undefined;
    qrCodeExtraInfo!: string | undefined;
    /** 组织架构的Logo */
    logoUrl!: string | undefined;
    /** 官网地址 */
    webAddressUrl!: string | undefined;
    /** 二维码 */
    qrCodeUrl!: string | undefined;
    /** 淘宝线下门店的StoreId */
    taobaoStoreId!: string | undefined;
    /** 门店联系方式，多个以;分隔，如：0571-81113563-123;0571-81113563;13826881688;400-820-5555 */
    contact!: string | undefined;
    /** 门店业务类型，默认为商品类业务300 */
    bizType!: string | undefined;
    /** 门店类目 */
    categoryId!: string | undefined;
    /** Thing的上下架需要审批. */
    isNeedThingApprove!: boolean;
    /** Ads的上下架需要审批. */
    isNeedAdsApprove!: boolean;
    /** APP的上下架需要审批. */
    isNeedAppApprove!: boolean;
    /** 设备上下线是否要审核 */
    isNeedDeviceApprove!: boolean;
    /** 红包上下线审核 */
    isNeedCouponApprove!: boolean;
    isNeedActivityApprove!: boolean;
    isNeedTrainingApprove!: boolean;
    /** 广告是否自动下发, */
    isAdsAutoSendDown!: boolean;
    /** App是否下发 */
    isAppAutoSendDown!: boolean;
    isProductAutoSendDown!: boolean;
    /** 红包是否下发 */
    isCouponAutoSendDown!: boolean;
    /** Ads是否下发是否接受 */
    canAcceptAdsAutoSendDown!: boolean;
    /** App是否下发是否接受 */
    canAcceptAppAutoSendDown!: boolean;
    /** Product是否下发是否接受 */
    canAcceptProductAutoSendDown!: boolean;
    /** 红包是否下发是否接受 */
    canAcceptCouponAutoSendDown!: boolean;
    positionId!: number | undefined;
    position!: PositionDto;
    addressDetail!: string | undefined;
    openingTime!: moment.Moment | undefined;
    closedTime!: moment.Moment | undefined;
    defaultOnlineShopName!: string | undefined;
    /** 自己电商的二维码规则. */
    qrcodeRules!: string | undefined;
    /** 月销售目标 */
    targetSalesOfMonth!: number | undefined;
    /** 月注册会员数目标 */
    targetRegisterOfMonth!: number | undefined;
    /** 店铺类型 */
    storeDevicesInfo!: string | undefined;
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitTypeId = _data["organizationUnitTypeId"];
            this.outerId = _data["outerId"];
            this.qrCodeExtraInfo = _data["qrCodeExtraInfo"];
            this.logoUrl = _data["logoUrl"];
            this.webAddressUrl = _data["webAddressUrl"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.taobaoStoreId = _data["taobaoStoreId"];
            this.contact = _data["contact"];
            this.bizType = _data["bizType"];
            this.categoryId = _data["categoryId"];
            this.isNeedThingApprove = _data["isNeedThingApprove"];
            this.isNeedAdsApprove = _data["isNeedAdsApprove"];
            this.isNeedAppApprove = _data["isNeedAppApprove"];
            this.isNeedDeviceApprove = _data["isNeedDeviceApprove"];
            this.isNeedCouponApprove = _data["isNeedCouponApprove"];
            this.isNeedActivityApprove = _data["isNeedActivityApprove"];
            this.isNeedTrainingApprove = _data["isNeedTrainingApprove"];
            this.isAdsAutoSendDown = _data["isAdsAutoSendDown"];
            this.isAppAutoSendDown = _data["isAppAutoSendDown"];
            this.isProductAutoSendDown = _data["isProductAutoSendDown"];
            this.isCouponAutoSendDown = _data["isCouponAutoSendDown"];
            this.canAcceptAdsAutoSendDown = _data["canAcceptAdsAutoSendDown"];
            this.canAcceptAppAutoSendDown = _data["canAcceptAppAutoSendDown"];
            this.canAcceptProductAutoSendDown = _data["canAcceptProductAutoSendDown"];
            this.canAcceptCouponAutoSendDown = _data["canAcceptCouponAutoSendDown"];
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? PositionDto.fromJS(_data["position"]) : <any>undefined;
            this.addressDetail = _data["addressDetail"];
            this.openingTime = _data["openingTime"] ? moment(_data["openingTime"].toString()) : <any>undefined;
            this.closedTime = _data["closedTime"] ? moment(_data["closedTime"].toString()) : <any>undefined;
            this.defaultOnlineShopName = _data["defaultOnlineShopName"];
            this.qrcodeRules = _data["qrcodeRules"];
            this.targetSalesOfMonth = _data["targetSalesOfMonth"];
            this.targetRegisterOfMonth = _data["targetRegisterOfMonth"];
            this.storeDevicesInfo = _data["storeDevicesInfo"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitTypeId"] = this.organizationUnitTypeId;
        data["outerId"] = this.outerId;
        data["qrCodeExtraInfo"] = this.qrCodeExtraInfo;
        data["logoUrl"] = this.logoUrl;
        data["webAddressUrl"] = this.webAddressUrl;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["taobaoStoreId"] = this.taobaoStoreId;
        data["contact"] = this.contact;
        data["bizType"] = this.bizType;
        data["categoryId"] = this.categoryId;
        data["isNeedThingApprove"] = this.isNeedThingApprove;
        data["isNeedAdsApprove"] = this.isNeedAdsApprove;
        data["isNeedAppApprove"] = this.isNeedAppApprove;
        data["isNeedDeviceApprove"] = this.isNeedDeviceApprove;
        data["isNeedCouponApprove"] = this.isNeedCouponApprove;
        data["isNeedActivityApprove"] = this.isNeedActivityApprove;
        data["isNeedTrainingApprove"] = this.isNeedTrainingApprove;
        data["isAdsAutoSendDown"] = this.isAdsAutoSendDown;
        data["isAppAutoSendDown"] = this.isAppAutoSendDown;
        data["isProductAutoSendDown"] = this.isProductAutoSendDown;
        data["isCouponAutoSendDown"] = this.isCouponAutoSendDown;
        data["canAcceptAdsAutoSendDown"] = this.canAcceptAdsAutoSendDown;
        data["canAcceptAppAutoSendDown"] = this.canAcceptAppAutoSendDown;
        data["canAcceptProductAutoSendDown"] = this.canAcceptProductAutoSendDown;
        data["canAcceptCouponAutoSendDown"] = this.canAcceptCouponAutoSendDown;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["addressDetail"] = this.addressDetail;
        data["openingTime"] = this.openingTime ? this.openingTime.toISOString() : <any>undefined;
        data["closedTime"] = this.closedTime ? this.closedTime.toISOString() : <any>undefined;
        data["defaultOnlineShopName"] = this.defaultOnlineShopName;
        data["qrcodeRules"] = this.qrcodeRules;
        data["targetSalesOfMonth"] = this.targetSalesOfMonth;
        data["targetRegisterOfMonth"] = this.targetRegisterOfMonth;
        data["storeDevicesInfo"] = this.storeDevicesInfo;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IGroupDto {
    organizationUnitTypeId: number;
    /** 门店商家自用编码,T-6300182 */
    outerId: string | undefined;
    qrCodeExtraInfo: string | undefined;
    /** 组织架构的Logo */
    logoUrl: string | undefined;
    /** 官网地址 */
    webAddressUrl: string | undefined;
    /** 二维码 */
    qrCodeUrl: string | undefined;
    /** 淘宝线下门店的StoreId */
    taobaoStoreId: string | undefined;
    /** 门店联系方式，多个以;分隔，如：0571-81113563-123;0571-81113563;13826881688;400-820-5555 */
    contact: string | undefined;
    /** 门店业务类型，默认为商品类业务300 */
    bizType: string | undefined;
    /** 门店类目 */
    categoryId: string | undefined;
    /** Thing的上下架需要审批. */
    isNeedThingApprove: boolean;
    /** Ads的上下架需要审批. */
    isNeedAdsApprove: boolean;
    /** APP的上下架需要审批. */
    isNeedAppApprove: boolean;
    /** 设备上下线是否要审核 */
    isNeedDeviceApprove: boolean;
    /** 红包上下线审核 */
    isNeedCouponApprove: boolean;
    isNeedActivityApprove: boolean;
    isNeedTrainingApprove: boolean;
    /** 广告是否自动下发, */
    isAdsAutoSendDown: boolean;
    /** App是否下发 */
    isAppAutoSendDown: boolean;
    isProductAutoSendDown: boolean;
    /** 红包是否下发 */
    isCouponAutoSendDown: boolean;
    /** Ads是否下发是否接受 */
    canAcceptAdsAutoSendDown: boolean;
    /** App是否下发是否接受 */
    canAcceptAppAutoSendDown: boolean;
    /** Product是否下发是否接受 */
    canAcceptProductAutoSendDown: boolean;
    /** 红包是否下发是否接受 */
    canAcceptCouponAutoSendDown: boolean;
    positionId: number | undefined;
    position: PositionDto;
    addressDetail: string | undefined;
    openingTime: moment.Moment | undefined;
    closedTime: moment.Moment | undefined;
    defaultOnlineShopName: string | undefined;
    /** 自己电商的二维码规则. */
    qrcodeRules: string | undefined;
    /** 月销售目标 */
    targetSalesOfMonth: number | undefined;
    /** 月注册会员数目标 */
    targetRegisterOfMonth: number | undefined;
    /** 店铺类型 */
    storeDevicesInfo: string | undefined;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class IdAndTotalCount implements IIdAndTotalCount {
    id!: number;
    totalCount!: number;

    constructor(data?: IIdAndTotalCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): IdAndTotalCount {
        data = typeof data === 'object' ? data : {};
        let result = new IdAndTotalCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalCount"] = this.totalCount;
        return data; 
    }
}

export interface IIdAndTotalCount {
    id: number;
    totalCount: number;
}

export class IdNameDto implements IIdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IIdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IIdNameDto {
    id: number;
    name: string | undefined;
}

export class IdNameItemIdDto implements IIdNameItemIdDto {
    id!: number;
    name!: string | undefined;
    /** 可能是sku_id,itemId,outerid */
    itemId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IIdNameItemIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.itemId = _data["itemId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdNameItemIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameItemIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["itemId"] = this.itemId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdNameItemIdDto {
    id: number;
    name: string | undefined;
    /** 可能是sku_id,itemId,outerid */
    itemId: string | undefined;
    type: string | undefined;
}

export class IdNamePicDto implements IIdNamePicDto {
    id!: number;
    name!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IIdNamePicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): IdNamePicDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNamePicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IIdNamePicDto {
    id: number;
    name: string | undefined;
    picUrl: string | undefined;
}

export class IdNamePicDtoPagedResultDto implements IIdNamePicDtoPagedResultDto {
    totalCount!: number;
    items!: IdNamePicDto[] | undefined;

    constructor(data?: IIdNamePicDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdNamePicDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdNamePicDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdNamePicDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIdNamePicDtoPagedResultDto {
    totalCount: number;
    items: IdNamePicDto[] | undefined;
}

export class IdPicUrlDto implements IIdPicUrlDto {
    id!: number;
    picUrl!: string | undefined;
    /** sku,product区分 */
    category!: string | undefined;

    constructor(data?: IIdPicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.picUrl = _data["picUrl"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): IdPicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdPicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picUrl"] = this.picUrl;
        data["category"] = this.category;
        return data; 
    }
}

export interface IIdPicUrlDto {
    id: number;
    picUrl: string | undefined;
    /** sku,product区分 */
    category: string | undefined;
}

export class IdTypeDto implements IIdTypeDto {
    id!: number;
    type!: string | undefined;

    constructor(data?: IIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IIdTypeDto {
    id: number;
    type: string | undefined;
}

export class Int32IdNameDto implements IInt32IdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IInt32IdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Int32IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int32IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt32IdNameDto {
    id: number;
    name: string | undefined;
}

export class Int64IdNameDto implements IInt64IdNameDto {
    id!: number;
    name!: string | undefined;

    constructor(data?: IInt64IdNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Int64IdNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64IdNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IInt64IdNameDto {
    id: number;
    name: string | undefined;
}

export class ItemIdPicUrlDto implements IItemIdPicUrlDto {
    itemId!: string | undefined;
    picUrl!: string | undefined;

    constructor(data?: IItemIdPicUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): ItemIdPicUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdPicUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IItemIdPicUrlDto {
    itemId: string | undefined;
    picUrl: string | undefined;
}

export class ItemIdTypeDto implements IItemIdTypeDto {
    itemId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IItemIdTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemId = _data["itemId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ItemIdTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemIdTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IItemIdTypeDto {
    itemId: string | undefined;
    type: string | undefined;
}

export class LikeInfoDto implements ILikeInfoDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    code!: string;
    orderNumber!: number;
    likeItems!: LikeItemDto[] | undefined;
    name!: string | undefined;
    image!: string | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ILikeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["likeItems"])) {
                this.likeItems = [] as any;
                for (let item of _data["likeItems"])
                    this.likeItems!.push(LikeItemDto.fromJS(item));
            }
            this.name = _data["name"];
            this.image = _data["image"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LikeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.likeItems)) {
            data["likeItems"] = [];
            for (let item of this.likeItems)
                data["likeItems"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["image"] = this.image;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILikeInfoDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    code: string;
    orderNumber: number;
    likeItems: LikeItemDto[] | undefined;
    name: string | undefined;
    image: string | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class LikeInfoDtoPagedResultDto implements ILikeInfoDtoPagedResultDto {
    totalCount!: number;
    items!: LikeInfoDto[] | undefined;

    constructor(data?: ILikeInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LikeInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LikeInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILikeInfoDtoPagedResultDto {
    totalCount: number;
    items: LikeInfoDto[] | undefined;
}

export class LikeItemDto implements ILikeItemDto {
    id!: number;
    likeInfoId!: number;
    skuId!: number;
    skuPicUrl!: string | undefined;
    skuTitle!: string | undefined;
    salesVolume!: number;
    quantity!: number;
    price!: string | undefined;
    reason!: string | undefined;
    isMain!: boolean;
    auditStatus!: AuditStatus;
    creationTime!: moment.Moment;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: ILikeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.likeInfoId = _data["likeInfoId"];
            this.skuId = _data["skuId"];
            this.skuPicUrl = _data["skuPicUrl"];
            this.skuTitle = _data["skuTitle"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
            this.auditStatus = _data["auditStatus"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): LikeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["likeInfoId"] = this.likeInfoId;
        data["skuId"] = this.skuId;
        data["skuPicUrl"] = this.skuPicUrl;
        data["skuTitle"] = this.skuTitle;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        data["auditStatus"] = this.auditStatus;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface ILikeItemDto {
    id: number;
    likeInfoId: number;
    skuId: number;
    skuPicUrl: string | undefined;
    skuTitle: string | undefined;
    salesVolume: number;
    quantity: number;
    price: string | undefined;
    reason: string | undefined;
    isMain: boolean;
    auditStatus: AuditStatus;
    creationTime: moment.Moment;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class LikeItemDtoPagedResultDto implements ILikeItemDtoPagedResultDto {
    totalCount!: number;
    items!: LikeItemDto[] | undefined;

    constructor(data?: ILikeItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LikeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LikeItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LikeItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILikeItemDtoPagedResultDto {
    totalCount: number;
    items: LikeItemDto[] | undefined;
}

export class MainSku implements IMainSku {
    skuId!: number;
    isMain!: boolean;

    constructor(data?: IMainSku) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): MainSku {
        data = typeof data === 'object' ? data : {};
        let result = new MainSku();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface IMainSku {
    skuId: number;
    isMain: boolean;
}

export class MatchInfoDto implements IMatchInfoDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    code!: string;
    orderNumber!: number;
    /** 展示图 */
    showImage!: string | undefined;
    /** 搭配效果大图 */
    bImg!: string | undefined;
    /** 搭配效果中图 */
    mImg!: string | undefined;
    /** 搭配效果小图 */
    sImg!: string | undefined;
    name!: string | undefined;
    matchItems!: MatchItemDto[] | undefined;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IMatchInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            if (Array.isArray(_data["matchItems"])) {
                this.matchItems = [] as any;
                for (let item of _data["matchItems"])
                    this.matchItems!.push(MatchItemDto.fromJS(item));
            }
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MatchInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        if (Array.isArray(this.matchItems)) {
            data["matchItems"] = [];
            for (let item of this.matchItems)
                data["matchItems"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMatchInfoDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    code: string;
    orderNumber: number;
    /** 展示图 */
    showImage: string | undefined;
    /** 搭配效果大图 */
    bImg: string | undefined;
    /** 搭配效果中图 */
    mImg: string | undefined;
    /** 搭配效果小图 */
    sImg: string | undefined;
    name: string | undefined;
    matchItems: MatchItemDto[] | undefined;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class MatchInfoDtoPagedResultDto implements IMatchInfoDtoPagedResultDto {
    totalCount!: number;
    items!: MatchInfoDto[] | undefined;

    constructor(data?: IMatchInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MatchInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMatchInfoDtoPagedResultDto {
    totalCount: number;
    items: MatchInfoDto[] | undefined;
}

export class MatchItemDto implements IMatchItemDto {
    id!: number;
    matchInfoId!: number;
    skuId!: number;
    skuPicUrl!: string | undefined;
    skuTitle!: string | undefined;
    salesVolume!: number;
    quantity!: number;
    price!: string | undefined;
    reason!: string | undefined;
    isMain!: boolean;
    auditStatus!: AuditStatus;
    creationTime!: moment.Moment;
    isMine!: boolean;
    organizationUnitId!: number | undefined;

    constructor(data?: IMatchItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.matchInfoId = _data["matchInfoId"];
            this.skuId = _data["skuId"];
            this.skuPicUrl = _data["skuPicUrl"];
            this.skuTitle = _data["skuTitle"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
            this.auditStatus = _data["auditStatus"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): MatchItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["matchInfoId"] = this.matchInfoId;
        data["skuId"] = this.skuId;
        data["skuPicUrl"] = this.skuPicUrl;
        data["skuTitle"] = this.skuTitle;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        data["auditStatus"] = this.auditStatus;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IMatchItemDto {
    id: number;
    matchInfoId: number;
    skuId: number;
    skuPicUrl: string | undefined;
    skuTitle: string | undefined;
    salesVolume: number;
    quantity: number;
    price: string | undefined;
    reason: string | undefined;
    isMain: boolean;
    auditStatus: AuditStatus;
    creationTime: moment.Moment;
    isMine: boolean;
    organizationUnitId: number | undefined;
}

export class MatchItemDtoPagedResultDto implements IMatchItemDtoPagedResultDto {
    totalCount!: number;
    items!: MatchItemDto[] | undefined;

    constructor(data?: IMatchItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MatchItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatchItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMatchItemDtoPagedResultDto {
    totalCount: number;
    items: MatchItemDto[] | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export enum OnlineStore {
    MyStore = 0,
    Taobao = 1,
    JD = 2,
    Suning = 3,
    Shangpai = 4,
    Baisheng_Openshop = 5,
    Amazon = 6,
    Amazonedi = 7,
    Yihaodian = 8,
    Dangdang = 9,
    Baisheng_Encm = 10,
    Vjia = 11,
    Yougou = 12,
    Yintai = 13,
    Jumei = 14,
    Weigou = 15,
    M18 = 16,
    Baisheng_Ishop = 17,
    Taobao_Fenxiao = 18,
    Baisheng_Icrm = 19,
    Baisheng_M6 = 20,
    Koudaitong = 21,
    Feiniu = 22,
    Feiniu_zd = 23,
    Suning_hwg = 24,
    Jingdong_qqg = 25,
    Weimeng = 26,
    Magento = 27,
    Icbc = 28,
    Juanpi = 29,
    Xiaodian = 30,
    Zhe800 = 31,
    Kaola = 32,
    Beibei = 33,
    Paipai = 34,
    Baidu = 35,
    Chuchujie = 36,
    Guomei = 37,
    Mogujie = 38,
    Alibaba = 39,
    Cbc = 40,
    Hichao = 41,
    Mengdian = 42,
    Mia = 43,
    Renren = 44,
    Aliexpress = 45,
    Shangpin = 46,
    Okbuy = 47,
    Pinduoduo = 48,
    Qiake = 49,
    Wangyi = 50,
    Lefeng = 51,
    EBay = 52,
    Xindan = 53,
    Weipinhui = 54,
    Weipinhui_jit = 55,
    ECSHOP = 56,
    ZhinengmendianPad = 57,
    ProductApp = 58,
    Youhuo = 59,
    Shimao = 60,
    Zhenpin = 61,
    Yunji = 62,
    Haiziwang = 63,
    Siku = 64,
    Suning_temai = 65,
    Yike = 66,
}

export class OnlineStoreInfoViewModel implements IOnlineStoreInfoViewModel {
    /** JD,Taobao */
    onlineStoreName!: string | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;
    skuId!: number;
    sku_Id!: string | undefined;

    constructor(data?: IOnlineStoreInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlineStoreName = _data["onlineStoreName"];
            this.qrcode = _data["qrcode"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
        }
    }

    static fromJS(data: any): OnlineStoreInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OnlineStoreInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlineStoreName"] = this.onlineStoreName;
        data["qrcode"] = this.qrcode;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        return data; 
    }
}

export interface IOnlineStoreInfoViewModel {
    /** JD,Taobao */
    onlineStoreName: string | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
    skuId: number;
    sku_Id: string | undefined;
}

export class OuterIdAndType implements IOuterIdAndType {
    outerId!: string | undefined;
    type!: string | undefined;

    constructor(data?: IOuterIdAndType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outerId = _data["outerId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OuterIdAndType {
        data = typeof data === 'object' ? data : {};
        let result = new OuterIdAndType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outerId"] = this.outerId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IOuterIdAndType {
    outerId: string | undefined;
    type: string | undefined;
}

export class OutPutInStorageSku implements IOutPutInStorageSku {
    productId!: number;
    skuId!: number;
    number!: number;

    constructor(data?: IOutPutInStorageSku) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.skuId = _data["skuId"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): OutPutInStorageSku {
        data = typeof data === 'object' ? data : {};
        let result = new OutPutInStorageSku();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["number"] = this.number;
        return data; 
    }
}

export interface IOutPutInStorageSku {
    productId: number;
    skuId: number;
    number: number;
}

export enum OutPutInStorageType {
    Out = 0,
    Put = 1,
    Check = 2,
}

export class PDFDto implements IPDFDto {
    tenantId!: number;
    skuId!: number;
    ids!: number[] | undefined;
    isTop!: number;
    textForPDF!: TextForPDF[] | undefined;
    column!: number;

    constructor(data?: IPDFDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.skuId = _data["skuId"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.isTop = _data["isTop"];
            if (Array.isArray(_data["textForPDF"])) {
                this.textForPDF = [] as any;
                for (let item of _data["textForPDF"])
                    this.textForPDF!.push(TextForPDF.fromJS(item));
            }
            this.column = _data["column"];
        }
    }

    static fromJS(data: any): PDFDto {
        data = typeof data === 'object' ? data : {};
        let result = new PDFDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["skuId"] = this.skuId;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["isTop"] = this.isTop;
        if (Array.isArray(this.textForPDF)) {
            data["textForPDF"] = [];
            for (let item of this.textForPDF)
                data["textForPDF"].push(item.toJSON());
        }
        data["column"] = this.column;
        return data; 
    }
}

export interface IPDFDto {
    tenantId: number;
    skuId: number;
    ids: number[] | undefined;
    isTop: number;
    textForPDF: TextForPDF[] | undefined;
    column: number;
}

export class PositionDto implements IPositionDto {
    id!: number | undefined;
    state!: string | undefined;
    area!: string | undefined;
    /** 省份 */
    province!: string | undefined;
    /** 城市 */
    city!: string | undefined;
    /** 县区 */
    county!: string | undefined;
    /** 详细地址 */
    location!: string | undefined;
    longitude!: number | undefined;
    /** 纬度 */
    latitude!: number | undefined;
    code!: string | undefined;
    zipCode!: string | undefined;

    constructor(data?: IPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.state = _data["state"];
            this.area = _data["area"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.county = _data["county"];
            this.location = _data["location"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.code = _data["code"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): PositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["state"] = this.state;
        data["area"] = this.area;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["location"] = this.location;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["code"] = this.code;
        data["zipCode"] = this.zipCode;
        return data; 
    }
}

export interface IPositionDto {
    id: number | undefined;
    state: string | undefined;
    area: string | undefined;
    /** 省份 */
    province: string | undefined;
    /** 城市 */
    city: string | undefined;
    /** 县区 */
    county: string | undefined;
    /** 详细地址 */
    location: string | undefined;
    longitude: number | undefined;
    /** 纬度 */
    latitude: number | undefined;
    code: string | undefined;
    zipCode: string | undefined;
}

export class PriceDefaultDto implements IPriceDefaultDto {
    defaultSku!: SkuDto;
    bindSku!: SkuDto;

    constructor(data?: IPriceDefaultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultSku = _data["defaultSku"] ? SkuDto.fromJS(_data["defaultSku"]) : <any>undefined;
            this.bindSku = _data["bindSku"] ? SkuDto.fromJS(_data["bindSku"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PriceDefaultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceDefaultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultSku"] = this.defaultSku ? this.defaultSku.toJSON() : <any>undefined;
        data["bindSku"] = this.bindSku ? this.bindSku.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPriceDefaultDto {
    defaultSku: SkuDto;
    bindSku: SkuDto;
}

export class PriceTagPriceTagIntegrationInput implements IPriceTagPriceTagIntegrationInput {
    deviceIds!: number[] | undefined;
    command!: string | undefined;

    constructor(data?: IPriceTagPriceTagIntegrationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deviceIds"])) {
                this.deviceIds = [] as any;
                for (let item of _data["deviceIds"])
                    this.deviceIds!.push(item);
            }
            this.command = _data["command"];
        }
    }

    static fromJS(data: any): PriceTagPriceTagIntegrationInput {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTagPriceTagIntegrationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deviceIds)) {
            data["deviceIds"] = [];
            for (let item of this.deviceIds)
                data["deviceIds"].push(item);
        }
        data["command"] = this.command;
        return data; 
    }
}

export interface IPriceTagPriceTagIntegrationInput {
    deviceIds: number[] | undefined;
    command: string | undefined;
}

export class PriceTagSyncProductInput implements IPriceTagSyncProductInput {
    customerStoreCode!: string | undefined;
    storeCode!: string | undefined;
    batchSize!: number;
    batchNo!: string | undefined;
    items!: SyncItem[] | undefined;

    constructor(data?: IPriceTagSyncProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerStoreCode = _data["customerStoreCode"];
            this.storeCode = _data["storeCode"];
            this.batchSize = _data["batchSize"];
            this.batchNo = _data["batchNo"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SyncItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceTagSyncProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new PriceTagSyncProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerStoreCode"] = this.customerStoreCode;
        data["storeCode"] = this.storeCode;
        data["batchSize"] = this.batchSize;
        data["batchNo"] = this.batchNo;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPriceTagSyncProductInput {
    customerStoreCode: string | undefined;
    storeCode: string | undefined;
    batchSize: number;
    batchNo: string | undefined;
    items: SyncItem[] | undefined;
}

export class ProductCategoryDto implements IProductCategoryDto {
    organizationUnitId!: number | undefined;
    /** 可被理解的分类唯一编码. */
    categoryCode!: string | undefined;
    /** 分类的名称 */
    name!: string | undefined;
    /** 父分类 */
    parentCategoryId!: number | undefined;
    parentCategoryName!: string | undefined;
    /** 分类的图片 */
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductCategoryDto {
    organizationUnitId: number | undefined;
    /** 可被理解的分类唯一编码. */
    categoryCode: string | undefined;
    /** 分类的名称 */
    name: string | undefined;
    /** 父分类 */
    parentCategoryId: number | undefined;
    parentCategoryName: string | undefined;
    /** 分类的图片 */
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ProductCategoryDtoPagedResultDto implements IProductCategoryDtoPagedResultDto {
    totalCount!: number;
    items!: ProductCategoryDto[] | undefined;

    constructor(data?: IProductCategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCategoryDtoPagedResultDto {
    totalCount: number;
    items: ProductCategoryDto[] | undefined;
}

export class ProductCategorySDKModel implements IProductCategorySDKModel {
    id!: number;
    /** 可被理解的分类唯一编码. */
    categoryCode!: string | undefined;
    /** 分类的名称 */
    name!: string | undefined;
    parentCategoryId!: number;
    /** 分类的图片 */
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IProductCategorySDKModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): ProductCategorySDKModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategorySDKModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IProductCategorySDKModel {
    id: number;
    /** 可被理解的分类唯一编码. */
    categoryCode: string | undefined;
    /** 分类的名称 */
    name: string | undefined;
    parentCategoryId: number;
    /** 分类的图片 */
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class ProductCategorySDKModelPagedResultDto implements IProductCategorySDKModelPagedResultDto {
    totalCount!: number;
    items!: ProductCategorySDKModel[] | undefined;

    constructor(data?: IProductCategorySDKModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCategorySDKModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategorySDKModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategorySDKModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCategorySDKModelPagedResultDto {
    totalCount: number;
    items: ProductCategorySDKModel[] | undefined;
}

export class ProductCategoryTreeItemDto implements IProductCategoryTreeItemDto {
    iconUrl!: string | undefined;
    text!: string | undefined;
    id!: number;
    type!: string | undefined;
    isSelected!: boolean;
    imageUrl!: string | undefined;
    productCount!: number;
    children!: ProductCategoryTreeItemDto[] | undefined;

    constructor(data?: IProductCategoryTreeItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iconUrl = _data["iconUrl"];
            this.text = _data["text"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.isSelected = _data["isSelected"];
            this.imageUrl = _data["imageUrl"];
            this.productCount = _data["productCount"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(ProductCategoryTreeItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategoryTreeItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategoryTreeItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["iconUrl"] = this.iconUrl;
        data["text"] = this.text;
        data["id"] = this.id;
        data["type"] = this.type;
        data["isSelected"] = this.isSelected;
        data["imageUrl"] = this.imageUrl;
        data["productCount"] = this.productCount;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCategoryTreeItemDto {
    iconUrl: string | undefined;
    text: string | undefined;
    id: number;
    type: string | undefined;
    isSelected: boolean;
    imageUrl: string | undefined;
    productCount: number;
    children: ProductCategoryTreeItemDto[] | undefined;
}

export class ProductCommentDto implements IProductCommentDto {
    id!: number;
    /** 评论者的用户名 */
    userName!: string | undefined;
    starLevel!: number | undefined;
    /** 评论者的头像 */
    avatorUrl!: string | undefined;
    /** 评论的内容 */
    content!: string | undefined;
    productId!: number;
    /** 评论时间 */
    commentDateTime!: moment.Moment;
    orderNumber!: number;
    picUrl!: string | undefined;

    constructor(data?: IProductCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.starLevel = _data["starLevel"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.productId = _data["productId"];
            this.commentDateTime = _data["commentDateTime"] ? moment(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
            this.picUrl = _data["picUrl"];
        }
    }

    static fromJS(data: any): ProductCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["starLevel"] = this.starLevel;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["productId"] = this.productId;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        data["picUrl"] = this.picUrl;
        return data; 
    }
}

export interface IProductCommentDto {
    id: number;
    /** 评论者的用户名 */
    userName: string | undefined;
    starLevel: number | undefined;
    /** 评论者的头像 */
    avatorUrl: string | undefined;
    /** 评论的内容 */
    content: string | undefined;
    productId: number;
    /** 评论时间 */
    commentDateTime: moment.Moment;
    orderNumber: number;
    picUrl: string | undefined;
}

export class ProductCommentDtoPagedResultDto implements IProductCommentDtoPagedResultDto {
    totalCount!: number;
    items!: ProductCommentDto[] | undefined;

    constructor(data?: IProductCommentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductCommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCommentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCommentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCommentDtoPagedResultDto {
    totalCount: number;
    items: ProductCommentDto[] | undefined;
}

export class ProductDecideImageViewModel implements IProductDecideImageViewModel {
    propertyName!: string | undefined;
    imageUrl!: string | undefined;

    constructor(data?: IProductDecideImageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): ProductDecideImageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDecideImageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IProductDecideImageViewModel {
    propertyName: string | undefined;
    imageUrl: string | undefined;
}

export class ProductDto implements IProductDto {
    id!: number;
    itemId!: string | undefined;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    quantity!: number;
    propsName!: string | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 商品的子标题，给商品增加卖点等描述 */
    subTitle!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: number;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl!: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount!: number;
    description!: string | undefined;
    created!: moment.Moment | undefined;
    lastUpdated!: moment.Moment | undefined;
    orderNumber!: number;
    p_ProductCategories!: Int64IdNameDto[] | undefined;
    skus!: SkuDto[] | undefined;
    itemImagesOrVideos!: EntityFileDto[] | undefined;
    productTags!: Int64IdNameDto[] | undefined;
    onlineStoreInfos!: ProductOnlineStoreInfoDto[] | undefined;
    skuProperties!: PropertyDto[] | undefined;
    sumPropsName!: string | undefined;
    sellerId!: string | undefined;
    visualImagePropertyId!: number | undefined;
    promPrice!: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    /** 商品的Barcode. */
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preProductId!: number;
    nextProductId!: number;
    brand!: Int32IdNameDto;
    creationTime!: moment.Moment;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
            this.lastUpdated = _data["lastUpdated"] ? moment(_data["lastUpdated"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["p_ProductCategories"])) {
                this.p_ProductCategories = [] as any;
                for (let item of _data["p_ProductCategories"])
                    this.p_ProductCategories!.push(Int64IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileDto.fromJS(item));
            }
            if (Array.isArray(_data["productTags"])) {
                this.productTags = [] as any;
                for (let item of _data["productTags"])
                    this.productTags!.push(Int64IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(ProductOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["skuProperties"])) {
                this.skuProperties = [] as any;
                for (let item of _data["skuProperties"])
                    this.skuProperties!.push(PropertyDto.fromJS(item));
            }
            this.sumPropsName = _data["sumPropsName"];
            this.sellerId = _data["sellerId"];
            this.visualImagePropertyId = _data["visualImagePropertyId"];
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preProductId = _data["preProductId"];
            this.nextProductId = _data["nextProductId"];
            this.brand = _data["brand"] ? Int32IdNameDto.fromJS(_data["brand"]) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastUpdated"] = this.lastUpdated ? this.lastUpdated.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.p_ProductCategories)) {
            data["p_ProductCategories"] = [];
            for (let item of this.p_ProductCategories)
                data["p_ProductCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.productTags)) {
            data["productTags"] = [];
            for (let item of this.productTags)
                data["productTags"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.skuProperties)) {
            data["skuProperties"] = [];
            for (let item of this.skuProperties)
                data["skuProperties"].push(item.toJSON());
        }
        data["sumPropsName"] = this.sumPropsName;
        data["sellerId"] = this.sellerId;
        data["visualImagePropertyId"] = this.visualImagePropertyId;
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preProductId"] = this.preProductId;
        data["nextProductId"] = this.nextProductId;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductDto {
    id: number;
    itemId: string | undefined;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    quantity: number;
    propsName: string | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 商品的子标题，给商品增加卖点等描述 */
    subTitle: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: number;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus: string | undefined;
    picUrl: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount: number;
    description: string | undefined;
    created: moment.Moment | undefined;
    lastUpdated: moment.Moment | undefined;
    orderNumber: number;
    p_ProductCategories: Int64IdNameDto[] | undefined;
    skus: SkuDto[] | undefined;
    itemImagesOrVideos: EntityFileDto[] | undefined;
    productTags: Int64IdNameDto[] | undefined;
    onlineStoreInfos: ProductOnlineStoreInfoDto[] | undefined;
    skuProperties: PropertyDto[] | undefined;
    sumPropsName: string | undefined;
    sellerId: string | undefined;
    visualImagePropertyId: number | undefined;
    promPrice: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    /** 商品的Barcode. */
    barcode: string | undefined;
    starLevel: number | undefined;
    preProductId: number;
    nextProductId: number;
    brand: Int32IdNameDto;
    creationTime: moment.Moment;
    isMine: boolean;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class ProductDtoPagedResultDto implements IProductDtoPagedResultDto {
    totalCount!: number;
    items!: ProductDto[] | undefined;

    constructor(data?: IProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductDtoPagedResultDto {
    totalCount: number;
    items: ProductDto[] | undefined;
}

export class ProductOnlineStoreInfoDto implements IProductOnlineStoreInfoDto {
    id!: number;
    productId!: number;
    /** 线上商场的Id. */
    storeId!: string | undefined;
    type!: OnlineStore;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商品的PID */
    pid!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: IProductOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.storeId = _data["storeId"];
            this.type = _data["type"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): ProductOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["storeId"] = this.storeId;
        data["type"] = this.type;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IProductOnlineStoreInfoDto {
    id: number;
    productId: number;
    /** 线上商场的Id. */
    storeId: string | undefined;
    type: OnlineStore;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商品的PID */
    pid: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class ProductOnlineStoreInfoDtoPagedResultDto implements IProductOnlineStoreInfoDtoPagedResultDto {
    totalCount!: number;
    items!: ProductOnlineStoreInfoDto[] | undefined;

    constructor(data?: IProductOnlineStoreInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductOnlineStoreInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductOnlineStoreInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOnlineStoreInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductOnlineStoreInfoDtoPagedResultDto {
    totalCount: number;
    items: ProductOnlineStoreInfoDto[] | undefined;
}

export class ProductPointRule implements IProductPointRule {
    redeemRule!: RedeemRule;
    awardRule!: AwardRule;

    constructor(data?: IProductPointRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redeemRule = _data["redeemRule"] ? RedeemRule.fromJS(_data["redeemRule"]) : <any>undefined;
            this.awardRule = _data["awardRule"] ? AwardRule.fromJS(_data["awardRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductPointRule {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPointRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redeemRule"] = this.redeemRule ? this.redeemRule.toJSON() : <any>undefined;
        data["awardRule"] = this.awardRule ? this.awardRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductPointRule {
    redeemRule: RedeemRule;
    awardRule: AwardRule;
}

export class ProductPromotionInput implements IProductPromotionInput {
    productId!: number;
    discountType!: DiscountType;
    discountValue!: number | undefined;

    constructor(data?: IProductPromotionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
        }
    }

    static fromJS(data: any): ProductPromotionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromotionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        return data; 
    }
}

export interface IProductPromotionInput {
    productId: number;
    discountType: DiscountType;
    discountValue: number | undefined;
}

export class ProductPropertyDto implements IProductPropertyDto {
    propertyId!: number;
    propertyName!: string | undefined;
    isForSale!: boolean;
    isDefaultDecideImage!: boolean;
    propertyValues!: PropertyValueDto[] | undefined;

    constructor(data?: IProductPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.isForSale = _data["isForSale"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["isForSale"] = this.isForSale;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductPropertyDto {
    propertyId: number;
    propertyName: string | undefined;
    isForSale: boolean;
    isDefaultDecideImage: boolean;
    propertyValues: PropertyValueDto[] | undefined;
}

export class ProductSdkModel implements IProductSdkModel {
    id!: number;
    itemId!: string | undefined;
    quantity!: number;
    title!: string | undefined;
    organizationUnitId!: number | undefined;
    /** 一句话营销. */
    subTitle!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: number;
    promPrice!: number;
    barcode!: string | undefined;
    /** 总销量 */
    salesVolume!: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    picUrl!: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount!: number;
    description!: string | undefined;
    isFromBrand!: boolean;
    sellerId!: string | undefined;
    outerId!: string | undefined;
    fromType!: string | undefined;
    hasRealSkus!: boolean;
    propImgs!: ProductDecideImageViewModel[] | undefined;
    categoryIds!: number[] | undefined;
    propValueIds!: number[] | undefined;
    tagIds!: number[] | undefined;
    skus!: SkuSdkModel[] | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    groupQrCodeInfo!: string | undefined;
    orderNumber!: number;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProductSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.quantity = _data["quantity"];
            this.title = _data["title"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.subTitle = _data["subTitle"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.barcode = _data["barcode"];
            this.salesVolume = _data["salesVolume"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.likeCount = _data["likeCount"];
            this.description = _data["description"];
            this.isFromBrand = _data["isFromBrand"];
            this.sellerId = _data["sellerId"];
            this.outerId = _data["outerId"];
            this.fromType = _data["fromType"];
            this.hasRealSkus = _data["hasRealSkus"];
            if (Array.isArray(_data["propImgs"])) {
                this.propImgs = [] as any;
                for (let item of _data["propImgs"])
                    this.propImgs!.push(ProductDecideImageViewModel.fromJS(item));
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(SkuSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.groupQrCodeInfo = _data["groupQrCodeInfo"];
            this.orderNumber = _data["orderNumber"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["quantity"] = this.quantity;
        data["title"] = this.title;
        data["organizationUnitId"] = this.organizationUnitId;
        data["subTitle"] = this.subTitle;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["barcode"] = this.barcode;
        data["salesVolume"] = this.salesVolume;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["likeCount"] = this.likeCount;
        data["description"] = this.description;
        data["isFromBrand"] = this.isFromBrand;
        data["sellerId"] = this.sellerId;
        data["outerId"] = this.outerId;
        data["fromType"] = this.fromType;
        data["hasRealSkus"] = this.hasRealSkus;
        if (Array.isArray(this.propImgs)) {
            data["propImgs"] = [];
            for (let item of this.propImgs)
                data["propImgs"].push(item.toJSON());
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["groupQrCodeInfo"] = this.groupQrCodeInfo;
        data["orderNumber"] = this.orderNumber;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductSdkModel {
    id: number;
    itemId: string | undefined;
    quantity: number;
    title: string | undefined;
    organizationUnitId: number | undefined;
    /** 一句话营销. */
    subTitle: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: number;
    promPrice: number;
    barcode: string | undefined;
    /** 总销量 */
    salesVolume: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    picUrl: string | undefined;
    /** Thing被专门喜欢的此处. */
    likeCount: number;
    description: string | undefined;
    isFromBrand: boolean;
    sellerId: string | undefined;
    outerId: string | undefined;
    fromType: string | undefined;
    hasRealSkus: boolean;
    propImgs: ProductDecideImageViewModel[] | undefined;
    categoryIds: number[] | undefined;
    propValueIds: number[] | undefined;
    tagIds: number[] | undefined;
    skus: SkuSdkModel[] | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    groupQrCodeInfo: string | undefined;
    orderNumber: number;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class ProductSdkModelPagedResultDto implements IProductSdkModelPagedResultDto {
    totalCount!: number;
    items!: ProductSdkModel[] | undefined;

    constructor(data?: IProductSdkModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductSdkModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSdkModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductSdkModelPagedResultDto {
    totalCount: number;
    items: ProductSdkModel[] | undefined;
}

export enum PromotionTypeEnum {
    InShop = 0,
    InGroup = 1,
    InProduct = 2,
}

export class PropertyDto implements IPropertyDto {
    tenantId!: number;
    organizationUnitId!: number | undefined;
    orderNumber!: number;
    /** 属性的名称 */
    name!: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage!: boolean;
    /** 是否是销售属性 */
    isForSale!: boolean;
    /** 来源类型 */
    fromType!: string | undefined;
    propertyValues!: PropertyValueDto[] | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValueDto.fromJS(item));
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyDto {
    tenantId: number;
    organizationUnitId: number | undefined;
    orderNumber: number;
    /** 属性的名称 */
    name: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage: boolean;
    /** 是否是销售属性 */
    isForSale: boolean;
    /** 来源类型 */
    fromType: string | undefined;
    propertyValues: PropertyValueDto[] | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PropertyDtoPagedResultDto implements IPropertyDtoPagedResultDto {
    totalCount!: number;
    items!: PropertyDto[] | undefined;

    constructor(data?: IPropertyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPropertyDtoPagedResultDto {
    totalCount: number;
    items: PropertyDto[] | undefined;
}

export class PropertyValueDto implements IPropertyValueDto {
    id!: number;
    propertyId!: number;
    propertyName!: string | undefined;
    value!: string | undefined;
    description!: string | undefined;
    defaultImage!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.defaultImage = _data["defaultImage"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): PropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        data["value"] = this.value;
        data["description"] = this.description;
        data["defaultImage"] = this.defaultImage;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IPropertyValueDto {
    id: number;
    propertyId: number;
    propertyName: string | undefined;
    value: string | undefined;
    description: string | undefined;
    defaultImage: string | undefined;
    iconUrl: string | undefined;
}

export class PropertyValueDtoPagedResultDto implements IPropertyValueDtoPagedResultDto {
    totalCount!: number;
    items!: PropertyValueDto[] | undefined;

    constructor(data?: IPropertyValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPropertyValueDtoPagedResultDto {
    totalCount: number;
    items: PropertyValueDto[] | undefined;
}

export class ProuctListOutPut implements IProuctListOutPut {
    id!: number;
    itemId!: string | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: number;
    /** Thing(商品/服务/需要上下架) */
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    creationTime!: moment.Moment;
    lastModificationTime!: moment.Moment | undefined;
    productCategories!: IdNamePicDto[] | undefined;
    productTags!: IdNamePicDto[] | undefined;
    /** RFID编号 */
    salesVolume!: number;
    quantity!: number;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: IProuctListOutPut) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["productCategories"])) {
                this.productCategories = [] as any;
                for (let item of _data["productCategories"])
                    this.productCategories!.push(IdNamePicDto.fromJS(item));
            }
            if (Array.isArray(_data["productTags"])) {
                this.productTags = [] as any;
                for (let item of _data["productTags"])
                    this.productTags!.push(IdNamePicDto.fromJS(item));
            }
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProuctListOutPut {
        data = typeof data === 'object' ? data : {};
        let result = new ProuctListOutPut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.productCategories)) {
            data["productCategories"] = [];
            for (let item of this.productCategories)
                data["productCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productTags)) {
            data["productTags"] = [];
            for (let item of this.productTags)
                data["productTags"].push(item.toJSON());
        }
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProuctListOutPut {
    id: number;
    itemId: string | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: number;
    /** Thing(商品/服务/需要上下架) */
    auditStatus: string | undefined;
    picUrl: string | undefined;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment | undefined;
    productCategories: IdNamePicDto[] | undefined;
    productTags: IdNamePicDto[] | undefined;
    /** RFID编号 */
    salesVolume: number;
    quantity: number;
    isMine: boolean;
    organizationUnitId: number | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class ProuctListOutPutPagedResultDto implements IProuctListOutPutPagedResultDto {
    totalCount!: number;
    items!: ProuctListOutPut[] | undefined;

    constructor(data?: IProuctListOutPutPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProuctListOutPut.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProuctListOutPutPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProuctListOutPutPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProuctListOutPutPagedResultDto {
    totalCount: number;
    items: ProuctListOutPut[] | undefined;
}

export class PublishEntitiesInput implements IPublishEntitiesInput {
    entityIds!: number[] | undefined;
    ouOrDeviceOrStoreList!: IdTypeDto[] | undefined;
    action!: string | undefined;
    includeSku!: boolean;
    isCreateDefaultSchedule!: boolean;
    informDevice!: boolean;
    type!: string | undefined;

    constructor(data?: IPublishEntitiesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            if (Array.isArray(_data["ouOrDeviceOrStoreList"])) {
                this.ouOrDeviceOrStoreList = [] as any;
                for (let item of _data["ouOrDeviceOrStoreList"])
                    this.ouOrDeviceOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
            this.isCreateDefaultSchedule = _data["isCreateDefaultSchedule"];
            this.informDevice = _data["informDevice"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PublishEntitiesInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishEntitiesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        if (Array.isArray(this.ouOrDeviceOrStoreList)) {
            data["ouOrDeviceOrStoreList"] = [];
            for (let item of this.ouOrDeviceOrStoreList)
                data["ouOrDeviceOrStoreList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        data["isCreateDefaultSchedule"] = this.isCreateDefaultSchedule;
        data["informDevice"] = this.informDevice;
        data["type"] = this.type;
        return data; 
    }
}

export interface IPublishEntitiesInput {
    entityIds: number[] | undefined;
    ouOrDeviceOrStoreList: IdTypeDto[] | undefined;
    action: string | undefined;
    includeSku: boolean;
    isCreateDefaultSchedule: boolean;
    informDevice: boolean;
    type: string | undefined;
}

export class PublishSearchedProductInput implements IPublishSearchedProductInput {
    searchCondition!: GetProductsInput;
    ouOrDeviceOrStoreList!: IdTypeDto[] | undefined;
    /** add,addonly,delete */
    action!: string | undefined;
    includeSku!: boolean;

    constructor(data?: IPublishSearchedProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCondition = _data["searchCondition"] ? GetProductsInput.fromJS(_data["searchCondition"]) : <any>undefined;
            if (Array.isArray(_data["ouOrDeviceOrStoreList"])) {
                this.ouOrDeviceOrStoreList = [] as any;
                for (let item of _data["ouOrDeviceOrStoreList"])
                    this.ouOrDeviceOrStoreList!.push(IdTypeDto.fromJS(item));
            }
            this.action = _data["action"];
            this.includeSku = _data["includeSku"];
        }
    }

    static fromJS(data: any): PublishSearchedProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new PublishSearchedProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCondition"] = this.searchCondition ? this.searchCondition.toJSON() : <any>undefined;
        if (Array.isArray(this.ouOrDeviceOrStoreList)) {
            data["ouOrDeviceOrStoreList"] = [];
            for (let item of this.ouOrDeviceOrStoreList)
                data["ouOrDeviceOrStoreList"].push(item.toJSON());
        }
        data["action"] = this.action;
        data["includeSku"] = this.includeSku;
        return data; 
    }
}

export interface IPublishSearchedProductInput {
    searchCondition: GetProductsInput;
    ouOrDeviceOrStoreList: IdTypeDto[] | undefined;
    /** add,addonly,delete */
    action: string | undefined;
    includeSku: boolean;
}

export class QueryProductsOrSkusInput implements IQueryProductsOrSkusInput {
    usage!: string | undefined;
    things!: ThingDto[] | undefined;
    subKey!: string;

    constructor(data?: IQueryProductsOrSkusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usage = _data["usage"];
            if (Array.isArray(_data["things"])) {
                this.things = [] as any;
                for (let item of _data["things"])
                    this.things!.push(ThingDto.fromJS(item));
            }
            this.subKey = _data["subKey"];
        }
    }

    static fromJS(data: any): QueryProductsOrSkusInput {
        data = typeof data === 'object' ? data : {};
        let result = new QueryProductsOrSkusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usage"] = this.usage;
        if (Array.isArray(this.things)) {
            data["things"] = [];
            for (let item of this.things)
                data["things"].push(item.toJSON());
        }
        data["subKey"] = this.subKey;
        return data; 
    }
}

export interface IQueryProductsOrSkusInput {
    usage: string | undefined;
    things: ThingDto[] | undefined;
    subKey: string;
}

export class RedeemRule implements IRedeemRule {
    pointRedeemable!: boolean;
    redeemType!: RedeemType;
    redeemAmount!: number;
    cashAmount!: number;

    constructor(data?: IRedeemRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pointRedeemable = _data["pointRedeemable"];
            this.redeemType = _data["redeemType"];
            this.redeemAmount = _data["redeemAmount"];
            this.cashAmount = _data["cashAmount"];
        }
    }

    static fromJS(data: any): RedeemRule {
        data = typeof data === 'object' ? data : {};
        let result = new RedeemRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pointRedeemable"] = this.pointRedeemable;
        data["redeemType"] = this.redeemType;
        data["redeemAmount"] = this.redeemAmount;
        data["cashAmount"] = this.cashAmount;
        return data; 
    }
}

export interface IRedeemRule {
    pointRedeemable: boolean;
    redeemType: RedeemType;
    redeemAmount: number;
    cashAmount: number;
}

export enum RedeemType {
    None = 0,
    Full = 1,
    Partial = 2,
}

export class RfidQrcodeDto implements IRfidQrcodeDto {
    qrcodeUrl!: string | undefined;
    qrcodeImageUrl!: string | undefined;

    constructor(data?: IRfidQrcodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrcodeUrl = _data["qrcodeUrl"];
            this.qrcodeImageUrl = _data["qrcodeImageUrl"];
        }
    }

    static fromJS(data: any): RfidQrcodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfidQrcodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrcodeUrl"] = this.qrcodeUrl;
        data["qrcodeImageUrl"] = this.qrcodeImageUrl;
        return data; 
    }
}

export interface IRfidQrcodeDto {
    qrcodeUrl: string | undefined;
    qrcodeImageUrl: string | undefined;
}

export class SensingDeviceProductCommentModel implements ISensingDeviceProductCommentModel {
    id!: number;
    userName!: string | undefined;
    commentDateTime!: moment.Moment;
    content!: string | undefined;
    orderNumber!: number;
    avatorUrl!: string | undefined;
    productId!: number;

    constructor(data?: ISensingDeviceProductCommentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.commentDateTime = _data["commentDateTime"] ? moment(_data["commentDateTime"].toString()) : <any>undefined;
            this.content = _data["content"];
            this.orderNumber = _data["orderNumber"];
            this.avatorUrl = _data["avatorUrl"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): SensingDeviceProductCommentModel {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceProductCommentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toISOString() : <any>undefined;
        data["content"] = this.content;
        data["orderNumber"] = this.orderNumber;
        data["avatorUrl"] = this.avatorUrl;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface ISensingDeviceProductCommentModel {
    id: number;
    userName: string | undefined;
    commentDateTime: moment.Moment;
    content: string | undefined;
    orderNumber: number;
    avatorUrl: string | undefined;
    productId: number;
}

export class SensingDeviceProductCommentModelPagedResultDto implements ISensingDeviceProductCommentModelPagedResultDto {
    totalCount!: number;
    items!: SensingDeviceProductCommentModel[] | undefined;

    constructor(data?: ISensingDeviceProductCommentModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDeviceProductCommentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingDeviceProductCommentModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDeviceProductCommentModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingDeviceProductCommentModelPagedResultDto {
    totalCount: number;
    items: SensingDeviceProductCommentModel[] | undefined;
}

export class SensingDevicePropertyDto implements ISensingDevicePropertyDto {
    propertyValues!: SensingDevicePropertyValueDto[] | undefined;
    id!: number;
    name!: string | undefined;
    isForSale!: boolean;
    isDefaultDecideImage!: boolean;
    description!: string | undefined;

    constructor(data?: ISensingDevicePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(SensingDevicePropertyValueDto.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.isForSale = _data["isForSale"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SensingDevicePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDevicePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["isForSale"] = this.isForSale;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISensingDevicePropertyDto {
    propertyValues: SensingDevicePropertyValueDto[] | undefined;
    id: number;
    name: string | undefined;
    isForSale: boolean;
    isDefaultDecideImage: boolean;
    description: string | undefined;
}

export class SensingDevicePropertyDtoPagedResultDto implements ISensingDevicePropertyDtoPagedResultDto {
    totalCount!: number;
    items!: SensingDevicePropertyDto[] | undefined;

    constructor(data?: ISensingDevicePropertyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SensingDevicePropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensingDevicePropertyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDevicePropertyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISensingDevicePropertyDtoPagedResultDto {
    totalCount: number;
    items: SensingDevicePropertyDto[] | undefined;
}

export class SensingDevicePropertyValueDto implements ISensingDevicePropertyValueDto {
    id!: number;
    value!: string | undefined;
    description!: string | undefined;
    defaultImage!: string | undefined;

    constructor(data?: ISensingDevicePropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.defaultImage = _data["defaultImage"];
        }
    }

    static fromJS(data: any): SensingDevicePropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new SensingDevicePropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["description"] = this.description;
        data["defaultImage"] = this.defaultImage;
        return data; 
    }
}

export interface ISensingDevicePropertyValueDto {
    id: number;
    value: string | undefined;
    description: string | undefined;
    defaultImage: string | undefined;
}

export class SetProductCategoryDto implements ISetProductCategoryDto {
    categoryIds!: number[] | undefined;
    productIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetProductCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetProductCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetProductCategoryDto {
    categoryIds: number[] | undefined;
    productIds: number[] | undefined;
    action: string | undefined;
}

export class SetProductTagsDto implements ISetProductTagsDto {
    tagIds!: number[] | undefined;
    productIds!: number[] | undefined;
    action!: string | undefined;

    constructor(data?: ISetProductTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.action = _data["action"];
        }
    }

    static fromJS(data: any): SetProductTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetProductTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["action"] = this.action;
        return data; 
    }
}

export interface ISetProductTagsDto {
    tagIds: number[] | undefined;
    productIds: number[] | undefined;
    action: string | undefined;
}

export enum ShopFreightBindingType {
    Calculate = 0,
    Fixed = 1,
}

export class SimpleFileDto implements ISimpleFileDto {
    fileUrl!: string | undefined;
    type!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;

    constructor(data?: ISimpleFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.type = _data["type"];
            this.usage = _data["usage"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): SimpleFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["type"] = this.type;
        data["usage"] = this.usage;
        data["description"] = this.description;
        return data; 
    }
}

export interface ISimpleFileDto {
    fileUrl: string | undefined;
    type: string | undefined;
    usage: string | undefined;
    description: string | undefined;
}

export class SimpleProductOrSkuDto implements ISimpleProductOrSkuDto {
    thingId!: number;
    title!: string | undefined;
    type!: CargoType;
    price!: number;
    promPrice!: number | undefined;
    picUrl!: string | undefined;
    quantity!: number;
    description!: string | undefined;
    imagesOrVideos!: SimpleFileDto[] | undefined;

    constructor(data?: ISimpleProductOrSkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.picUrl = _data["picUrl"];
            this.quantity = _data["quantity"];
            this.description = _data["description"];
            if (Array.isArray(_data["imagesOrVideos"])) {
                this.imagesOrVideos = [] as any;
                for (let item of _data["imagesOrVideos"])
                    this.imagesOrVideos!.push(SimpleFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SimpleProductOrSkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleProductOrSkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["title"] = this.title;
        data["type"] = this.type;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["picUrl"] = this.picUrl;
        data["quantity"] = this.quantity;
        data["description"] = this.description;
        if (Array.isArray(this.imagesOrVideos)) {
            data["imagesOrVideos"] = [];
            for (let item of this.imagesOrVideos)
                data["imagesOrVideos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISimpleProductOrSkuDto {
    thingId: number;
    title: string | undefined;
    type: CargoType;
    price: number;
    promPrice: number | undefined;
    picUrl: string | undefined;
    quantity: number;
    description: string | undefined;
    imagesOrVideos: SimpleFileDto[] | undefined;
}

export class Sku_PropertyValueDto implements ISku_PropertyValueDto {
    propertyId!: number;
    propertyValueId!: number;
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: ISku_PropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyValueId = _data["propertyValueId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Sku_PropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new Sku_PropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyValueId"] = this.propertyValueId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface ISku_PropertyValueDto {
    propertyId: number;
    propertyValueId: number;
    name: string | undefined;
    value: string | undefined;
}

export class SkuCodeDto implements ISkuCodeDto {
    id!: number;
    sku_id!: string | undefined;
    quantity!: number;
    propsName!: string | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl!: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    skuTags!: Int64IdNameDto[] | undefined;
    skuCategories!: Int64IdNameDto[] | undefined;
    isMine!: boolean;
    onlineStoreInfos!: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos!: SkuFileDto[] | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    /** 商品的Barcode. */
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preSkuId!: number;
    nextSkuId!: number;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    productId!: number;

    constructor(data?: ISkuCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(Int64IdNameDto.fromJS(item));
            }
            if (Array.isArray(_data["skuCategories"])) {
                this.skuCategories = [] as any;
                for (let item of _data["skuCategories"])
                    this.skuCategories!.push(Int64IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(SkuFileDto.fromJS(item));
            }
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preSkuId = _data["preSkuId"];
            this.nextSkuId = _data["nextSkuId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): SkuCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        if (Array.isArray(this.skuCategories)) {
            data["skuCategories"] = [];
            for (let item of this.skuCategories)
                data["skuCategories"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preSkuId"] = this.preSkuId;
        data["nextSkuId"] = this.nextSkuId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["productId"] = this.productId;
        return data; 
    }
}

export interface ISkuCodeDto {
    id: number;
    sku_id: string | undefined;
    quantity: number;
    propsName: string | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    orderNumber: number;
    skuTags: Int64IdNameDto[] | undefined;
    skuCategories: Int64IdNameDto[] | undefined;
    isMine: boolean;
    onlineStoreInfos: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos: SkuFileDto[] | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    /** 商品的Barcode. */
    barcode: string | undefined;
    starLevel: number | undefined;
    preSkuId: number;
    nextSkuId: number;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    productId: number;
}

export class SkuDto implements ISkuDto {
    id!: number;
    sku_id!: string | undefined;
    quantity!: number;
    propsName!: string | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl!: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    skuTags!: Int64IdNameDto[] | undefined;
    isMine!: boolean;
    onlineStoreInfos!: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos!: SkuFileDto[] | undefined;
    currentSkuPropertyValues!: Sku_PropertyValueDto[] | undefined;
    promPrice!: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    outerId!: string | undefined;
    salesVolume!: number;
    /** 商品的Barcode. */
    barcode!: string | undefined;
    starLevel!: number | undefined;
    preSkuId!: number;
    nextSkuId!: number;
    organizationUnitId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    productId!: number;
    skuCategories!: Int64IdNameDto[] | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;
    weight!: number;

    constructor(data?: ISkuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku_id = _data["sku_id"];
            this.quantity = _data["quantity"];
            this.propsName = _data["propsName"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.auditStatus = _data["auditStatus"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["skuTags"])) {
                this.skuTags = [] as any;
                for (let item of _data["skuTags"])
                    this.skuTags!.push(Int64IdNameDto.fromJS(item));
            }
            this.isMine = _data["isMine"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(SkuFileDto.fromJS(item));
            }
            if (Array.isArray(_data["currentSkuPropertyValues"])) {
                this.currentSkuPropertyValues = [] as any;
                for (let item of _data["currentSkuPropertyValues"])
                    this.currentSkuPropertyValues!.push(Sku_PropertyValueDto.fromJS(item));
            }
            this.promPrice = _data["promPrice"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.outerId = _data["outerId"];
            this.salesVolume = _data["salesVolume"];
            this.barcode = _data["barcode"];
            this.starLevel = _data["starLevel"];
            this.preSkuId = _data["preSkuId"];
            this.nextSkuId = _data["nextSkuId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.productId = _data["productId"];
            if (Array.isArray(_data["skuCategories"])) {
                this.skuCategories = [] as any;
                for (let item of _data["skuCategories"])
                    this.skuCategories!.push(Int64IdNameDto.fromJS(item));
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): SkuDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku_id"] = this.sku_id;
        data["quantity"] = this.quantity;
        data["propsName"] = this.propsName;
        data["title"] = this.title;
        data["price"] = this.price;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["auditStatus"] = this.auditStatus;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.skuTags)) {
            data["skuTags"] = [];
            for (let item of this.skuTags)
                data["skuTags"].push(item.toJSON());
        }
        data["isMine"] = this.isMine;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        if (Array.isArray(this.currentSkuPropertyValues)) {
            data["currentSkuPropertyValues"] = [];
            for (let item of this.currentSkuPropertyValues)
                data["currentSkuPropertyValues"].push(item.toJSON());
        }
        data["promPrice"] = this.promPrice;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["outerId"] = this.outerId;
        data["salesVolume"] = this.salesVolume;
        data["barcode"] = this.barcode;
        data["starLevel"] = this.starLevel;
        data["preSkuId"] = this.preSkuId;
        data["nextSkuId"] = this.nextSkuId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["productId"] = this.productId;
        if (Array.isArray(this.skuCategories)) {
            data["skuCategories"] = [];
            for (let item of this.skuCategories)
                data["skuCategories"].push(item.toJSON());
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface ISkuDto {
    id: number;
    sku_id: string | undefined;
    quantity: number;
    propsName: string | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    /** Thing(商品/服务/需要上下架) */
    auditStatus: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    orderNumber: number;
    skuTags: Int64IdNameDto[] | undefined;
    isMine: boolean;
    onlineStoreInfos: SkuOnlineStoreInfoDto[] | undefined;
    itemImagesOrVideos: SkuFileDto[] | undefined;
    currentSkuPropertyValues: Sku_PropertyValueDto[] | undefined;
    promPrice: string | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    outerId: string | undefined;
    salesVolume: number;
    /** 商品的Barcode. */
    barcode: string | undefined;
    starLevel: number | undefined;
    preSkuId: number;
    nextSkuId: number;
    organizationUnitId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    productId: number;
    skuCategories: Int64IdNameDto[] | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
    weight: number;
}

export class SkuFileDto implements ISkuFileDto {
    id!: number;
    skuId!: number;
    resourceId!: number;
    name!: string | undefined;
    /** 资源的地址途径 */
    fileUrl!: string | undefined;
    category!: string | undefined;
    fromType!: string | undefined;
    usage!: string | undefined;
    description!: string | undefined;
    type!: string | undefined;
    created!: moment.Moment | undefined;

    constructor(data?: ISkuFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.resourceId = _data["resourceId"];
            this.name = _data["name"];
            this.fileUrl = _data["fileUrl"];
            this.category = _data["category"];
            this.fromType = _data["fromType"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["resourceId"] = this.resourceId;
        data["name"] = this.name;
        data["fileUrl"] = this.fileUrl;
        data["category"] = this.category;
        data["fromType"] = this.fromType;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["type"] = this.type;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISkuFileDto {
    id: number;
    skuId: number;
    resourceId: number;
    name: string | undefined;
    /** 资源的地址途径 */
    fileUrl: string | undefined;
    category: string | undefined;
    fromType: string | undefined;
    usage: string | undefined;
    description: string | undefined;
    type: string | undefined;
    created: moment.Moment | undefined;
}

export class SkuFileDtoPagedResultDto implements ISkuFileDtoPagedResultDto {
    totalCount!: number;
    items!: SkuFileDto[] | undefined;

    constructor(data?: ISkuFileDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuFileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuFileDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuFileDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuFileDtoPagedResultDto {
    totalCount: number;
    items: SkuFileDto[] | undefined;
}

export class SkuIdAndOuterIdDto implements ISkuIdAndOuterIdDto {
    skuId!: number;
    title!: string | undefined;
    outerId!: string | undefined;

    constructor(data?: ISkuIdAndOuterIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
        }
    }

    static fromJS(data: any): SkuIdAndOuterIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuIdAndOuterIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        return data; 
    }
}

export interface ISkuIdAndOuterIdDto {
    skuId: number;
    title: string | undefined;
    outerId: string | undefined;
}

export class SkuOnlineStoreInfoDto implements ISkuOnlineStoreInfoDto {
    id!: number;
    skuId!: number;
    /** 线上商场的Id. */
    storeId!: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商城的PID */
    sku_ID!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: ISkuOnlineStoreInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): SkuOnlineStoreInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuOnlineStoreInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface ISkuOnlineStoreInfoDto {
    id: number;
    skuId: number;
    /** 线上商场的Id. */
    storeId: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商城的PID */
    sku_ID: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class SkuOnlineStoreInfoDtoPagedResultDto implements ISkuOnlineStoreInfoDtoPagedResultDto {
    totalCount!: number;
    items!: SkuOnlineStoreInfoDto[] | undefined;

    constructor(data?: ISkuOnlineStoreInfoDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuOnlineStoreInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuOnlineStoreInfoDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuOnlineStoreInfoDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuOnlineStoreInfoDtoPagedResultDto {
    totalCount: number;
    items: SkuOnlineStoreInfoDto[] | undefined;
}

export class SkuQuantity implements ISkuQuantity {
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    quantity!: number;

    constructor(data?: ISkuQuantity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): SkuQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new SkuQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface ISkuQuantity {
    skuId: number | undefined;
    sku_Id: string | undefined;
    quantity: number;
}

export class SkuSdkModel implements ISkuSdkModel {
    id!: number;
    skuId!: string | undefined;
    quantity!: number;
    barcode!: string | undefined;
    propsName!: string | undefined;
    /** SKU属性值的Ids. */
    propValueIds!: number[] | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: number;
    /** 促销价格 */
    promPrice!: number;
    /** 总销量 */
    salesVolume!: number;
    likeCount!: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    outerId!: string | undefined;
    orderNumber!: number;
    tagIds!: number[] | undefined;
    fromType!: string | undefined;
    colorName!: string | undefined;
    onlineStoreInfos!: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope!: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender!: string | undefined;
    /** RFID编号 */
    rfidCode!: string | undefined;
    price2!: number | undefined;
    weight!: number | undefined;
    itemImagesOrVideos!: EntityFileSdkModel[] | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;

    constructor(data?: ISkuSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.quantity = _data["quantity"];
            this.barcode = _data["barcode"];
            this.propsName = _data["propsName"];
            if (Array.isArray(_data["propValueIds"])) {
                this.propValueIds = [] as any;
                for (let item of _data["propValueIds"])
                    this.propValueIds!.push(item);
            }
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.likeCount = _data["likeCount"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.outerId = _data["outerId"];
            this.orderNumber = _data["orderNumber"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            this.fromType = _data["fromType"];
            this.colorName = _data["colorName"];
            if (Array.isArray(_data["onlineStoreInfos"])) {
                this.onlineStoreInfos = [] as any;
                for (let item of _data["onlineStoreInfos"])
                    this.onlineStoreInfos!.push(OnlineStoreInfoViewModel.fromJS(item));
            }
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.rfidCode = _data["rfidCode"];
            this.price2 = _data["price2"];
            this.weight = _data["weight"];
            if (Array.isArray(_data["itemImagesOrVideos"])) {
                this.itemImagesOrVideos = [] as any;
                for (let item of _data["itemImagesOrVideos"])
                    this.itemImagesOrVideos!.push(EntityFileSdkModel.fromJS(item));
            }
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SkuSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["quantity"] = this.quantity;
        data["barcode"] = this.barcode;
        data["propsName"] = this.propsName;
        if (Array.isArray(this.propValueIds)) {
            data["propValueIds"] = [];
            for (let item of this.propValueIds)
                data["propValueIds"].push(item);
        }
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["likeCount"] = this.likeCount;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["outerId"] = this.outerId;
        data["orderNumber"] = this.orderNumber;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        data["fromType"] = this.fromType;
        data["colorName"] = this.colorName;
        if (Array.isArray(this.onlineStoreInfos)) {
            data["onlineStoreInfos"] = [];
            for (let item of this.onlineStoreInfos)
                data["onlineStoreInfos"].push(item.toJSON());
        }
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["rfidCode"] = this.rfidCode;
        data["price2"] = this.price2;
        data["weight"] = this.weight;
        if (Array.isArray(this.itemImagesOrVideos)) {
            data["itemImagesOrVideos"] = [];
            for (let item of this.itemImagesOrVideos)
                data["itemImagesOrVideos"].push(item.toJSON());
        }
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISkuSdkModel {
    id: number;
    skuId: string | undefined;
    quantity: number;
    barcode: string | undefined;
    propsName: string | undefined;
    /** SKU属性值的Ids. */
    propValueIds: number[] | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: number;
    /** 促销价格 */
    promPrice: number;
    /** 总销量 */
    salesVolume: number;
    likeCount: number;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    outerId: string | undefined;
    orderNumber: number;
    tagIds: number[] | undefined;
    fromType: string | undefined;
    colorName: string | undefined;
    onlineStoreInfos: OnlineStoreInfoViewModel[] | undefined;
    /** Sku 针对年龄段
例：该Sku适合20-25岁，且适合60-70岁的场合，填入【20-25,60-70】多年龄段半角逗号隔开，为空代表无针对。 */
    ageScope: string | undefined;
    /** Sku 针对性别
例：男=Male，女=Female 。为空代表无针对。 */
    gender: string | undefined;
    /** RFID编号 */
    rfidCode: string | undefined;
    price2: number | undefined;
    weight: number | undefined;
    itemImagesOrVideos: EntityFileSdkModel[] | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
}

export class SkuSimpleDto implements ISkuSimpleDto {
    sku_id!: string | undefined;
    /** 事物都该有个名字来表示 */
    title!: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price!: string | undefined;
    promPrice!: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl!: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords!: string | undefined;
    picUrl!: string | undefined;
    description!: string | undefined;
    productId!: number;
    quantity!: number;
    starLevel!: number | undefined;
    auditStatus!: AuditStatus;
    salesVolume!: number;
    isMine!: boolean;
    organizationUnitId!: number | undefined;
    barcode!: string | undefined;
    pointRedeemType!: RedeemType;
    pointRule!: ProductPointRule;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISkuSimpleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku_id = _data["sku_id"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.promPrice = _data["promPrice"];
            this.qrCodeUrl = _data["qrCodeUrl"];
            this.keywords = _data["keywords"];
            this.picUrl = _data["picUrl"];
            this.description = _data["description"];
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.starLevel = _data["starLevel"];
            this.auditStatus = _data["auditStatus"];
            this.salesVolume = _data["salesVolume"];
            this.isMine = _data["isMine"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.barcode = _data["barcode"];
            this.pointRedeemType = _data["pointRedeemType"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SkuSimpleDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSimpleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku_id"] = this.sku_id;
        data["title"] = this.title;
        data["price"] = this.price;
        data["promPrice"] = this.promPrice;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["keywords"] = this.keywords;
        data["picUrl"] = this.picUrl;
        data["description"] = this.description;
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["starLevel"] = this.starLevel;
        data["auditStatus"] = this.auditStatus;
        data["salesVolume"] = this.salesVolume;
        data["isMine"] = this.isMine;
        data["organizationUnitId"] = this.organizationUnitId;
        data["barcode"] = this.barcode;
        data["pointRedeemType"] = this.pointRedeemType;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISkuSimpleDto {
    sku_id: string | undefined;
    /** 事物都该有个名字来表示 */
    title: string | undefined;
    /** 在当今社会,任何事物都是可以明码标价的,难道不是! */
    price: string | undefined;
    promPrice: string | undefined;
    /** 二维码这么流行,没个这玩意都不好意思说我在编程. */
    qrCodeUrl: string | undefined;
    /** 万物总有属于他自己的关键字,让别人好找到它. */
    keywords: string | undefined;
    picUrl: string | undefined;
    description: string | undefined;
    productId: number;
    quantity: number;
    starLevel: number | undefined;
    auditStatus: AuditStatus;
    salesVolume: number;
    isMine: boolean;
    organizationUnitId: number | undefined;
    barcode: string | undefined;
    pointRedeemType: RedeemType;
    pointRule: ProductPointRule;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class SkuSimpleDtoPagedResultDto implements ISkuSimpleDtoPagedResultDto {
    totalCount!: number;
    items!: SkuSimpleDto[] | undefined;

    constructor(data?: ISkuSimpleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SkuSimpleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SkuSimpleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SkuSimpleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISkuSimpleDtoPagedResultDto {
    totalCount: number;
    items: SkuSimpleDto[] | undefined;
}

export class SyncItem implements ISyncItem {
    sku!: string | undefined;
    customerStoreCode!: string | undefined;
    itemName!: string | undefined;
    price1!: string | undefined;
    /** 条形码 */
    ean!: string | undefined;
    /** 二维码 */
    qrCode!: string | undefined;
    /** 分类 */
    level1CategoryName!: string | undefined;
    /** 销量 */
    rsrvTxt1!: string | undefined;
    /** 语言 */
    rsrvTxt2!: string | undefined;
    /** 资源图 */
    rsrvBlob!: string | undefined;

    constructor(data?: ISyncItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.customerStoreCode = _data["customerStoreCode"];
            this.itemName = _data["itemName"];
            this.price1 = _data["price1"];
            this.ean = _data["ean"];
            this.qrCode = _data["qrCode"];
            this.level1CategoryName = _data["level1CategoryName"];
            this.rsrvTxt1 = _data["rsrvTxt1"];
            this.rsrvTxt2 = _data["rsrvTxt2"];
            this.rsrvBlob = _data["rsrvBlob"];
        }
    }

    static fromJS(data: any): SyncItem {
        data = typeof data === 'object' ? data : {};
        let result = new SyncItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["customerStoreCode"] = this.customerStoreCode;
        data["itemName"] = this.itemName;
        data["price1"] = this.price1;
        data["ean"] = this.ean;
        data["qrCode"] = this.qrCode;
        data["level1CategoryName"] = this.level1CategoryName;
        data["rsrvTxt1"] = this.rsrvTxt1;
        data["rsrvTxt2"] = this.rsrvTxt2;
        data["rsrvBlob"] = this.rsrvBlob;
        return data; 
    }
}

export interface ISyncItem {
    sku: string | undefined;
    customerStoreCode: string | undefined;
    itemName: string | undefined;
    price1: string | undefined;
    /** 条形码 */
    ean: string | undefined;
    /** 二维码 */
    qrCode: string | undefined;
    /** 分类 */
    level1CategoryName: string | undefined;
    /** 销量 */
    rsrvTxt1: string | undefined;
    /** 语言 */
    rsrvTxt2: string | undefined;
    /** 资源图 */
    rsrvBlob: string | undefined;
}

export class TableNeedUpdateDto implements ITableNeedUpdateDto {
    ads!: boolean;
    apps!: boolean;
    productCategories!: boolean;
    products!: boolean;
    skus!: boolean;
    tags!: boolean;
    productComments!: boolean;
    properties!: boolean;
    propertyValues!: boolean;
    coupons!: boolean;
    staffs!: boolean;
    matchInfos!: boolean;
    likeInfos!: boolean;
    brands!: boolean;

    constructor(data?: ITableNeedUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ads = _data["ads"];
            this.apps = _data["apps"];
            this.productCategories = _data["productCategories"];
            this.products = _data["products"];
            this.skus = _data["skus"];
            this.tags = _data["tags"];
            this.productComments = _data["productComments"];
            this.properties = _data["properties"];
            this.propertyValues = _data["propertyValues"];
            this.coupons = _data["coupons"];
            this.staffs = _data["staffs"];
            this.matchInfos = _data["matchInfos"];
            this.likeInfos = _data["likeInfos"];
            this.brands = _data["brands"];
        }
    }

    static fromJS(data: any): TableNeedUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TableNeedUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ads"] = this.ads;
        data["apps"] = this.apps;
        data["productCategories"] = this.productCategories;
        data["products"] = this.products;
        data["skus"] = this.skus;
        data["tags"] = this.tags;
        data["productComments"] = this.productComments;
        data["properties"] = this.properties;
        data["propertyValues"] = this.propertyValues;
        data["coupons"] = this.coupons;
        data["staffs"] = this.staffs;
        data["matchInfos"] = this.matchInfos;
        data["likeInfos"] = this.likeInfos;
        data["brands"] = this.brands;
        return data; 
    }
}

export interface ITableNeedUpdateDto {
    ads: boolean;
    apps: boolean;
    productCategories: boolean;
    products: boolean;
    skus: boolean;
    tags: boolean;
    productComments: boolean;
    properties: boolean;
    propertyValues: boolean;
    coupons: boolean;
    staffs: boolean;
    matchInfos: boolean;
    likeInfos: boolean;
    brands: boolean;
}

export class TagDto implements ITagDto {
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    tenantId!: number;
    organizationUnitId!: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ITagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.tenantId = _data["tenantId"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TagDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["tenantId"] = this.tenantId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITagDto {
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    tenantId: number;
    organizationUnitId: number | undefined;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TagDtoPagedResultDto implements ITagDtoPagedResultDto {
    totalCount!: number;
    items!: TagDto[] | undefined;

    constructor(data?: ITagDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagDtoPagedResultDto {
    totalCount: number;
    items: TagDto[] | undefined;
}

export class TagSdkModel implements ITagSdkModel {
    id!: number;
    value!: string | undefined;
    type!: string | undefined;
    isSpecial!: boolean;
    iconUrl!: string | undefined;

    constructor(data?: ITagSdkModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.isSpecial = _data["isSpecial"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): TagSdkModel {
        data = typeof data === 'object' ? data : {};
        let result = new TagSdkModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["isSpecial"] = this.isSpecial;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface ITagSdkModel {
    id: number;
    value: string | undefined;
    type: string | undefined;
    isSpecial: boolean;
    iconUrl: string | undefined;
}

export class TagSdkModelPagedResultDto implements ITagSdkModelPagedResultDto {
    totalCount!: number;
    items!: TagSdkModel[] | undefined;

    constructor(data?: ITagSdkModelPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TagSdkModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagSdkModelPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagSdkModelPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITagSdkModelPagedResultDto {
    totalCount: number;
    items: TagSdkModel[] | undefined;
}

export enum TagType {
    Resource = 0,
    Device = 1,
    Product = 2,
    Ads = 3,
    Other = 4,
    Brand = 5,
    Question = 6,
    Counter = 7,
    WechatPublicMessage = 8,
}

export enum TakeType {
    UserTake = 0,
    ManagerGrant = 1,
    RegisterAutoGrant = 2,
    GameAutoGrant = 3,
}

/** 输入字段 */
export class TextForPDF implements ITextForPDF {
    content!: string | undefined;
    bold!: boolean;
    fontSize!: number;

    constructor(data?: ITextForPDF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.bold = _data["bold"];
            this.fontSize = _data["fontSize"];
        }
    }

    static fromJS(data: any): TextForPDF {
        data = typeof data === 'object' ? data : {};
        let result = new TextForPDF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["bold"] = this.bold;
        data["fontSize"] = this.fontSize;
        return data; 
    }
}

/** 输入字段 */
export interface ITextForPDF {
    content: string | undefined;
    bold: boolean;
    fontSize: number;
}

export class ThingDto implements IThingDto {
    thingId!: number;
    type!: CargoType;

    constructor(data?: IThingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thingId = _data["thingId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ThingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thingId"] = this.thingId;
        data["type"] = this.type;
        return data; 
    }
}

export interface IThingDto {
    thingId: number;
    type: CargoType;
}

export enum TicketType {
    Voucher = 0,
    Discount = 1,
}

export class TicketUseCondition implements ITicketUseCondition {
    amount!: number | undefined;
    tagIds!: number[] | undefined;
    categoryIds!: number[] | undefined;

    constructor(data?: ITicketUseCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): TicketUseCondition {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUseCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        return data; 
    }
}

export interface ITicketUseCondition {
    amount: number | undefined;
    tagIds: number[] | undefined;
    categoryIds: number[] | undefined;
}

export class UpdateCouponInput implements IUpdateCouponInput {
    id!: number;
    /** 面额 */
    amount!: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId!: string | undefined;
    /** 优惠券名称 */
    title!: string;
    /** 优惠券其它平台的Id */
    outerId!: string | undefined;
    /** 优惠券图片 */
    pictures!: string | undefined;
    /** 优惠券生效时间 */
    start_time!: moment.Moment;
    /** 优惠券的截止日期 */
    end_time!: moment.Moment;
    /** 优惠券地址 */
    url!: string | undefined;
    auditStatus!: AuditStatus;
    /** 外部定义的 */
    code!: string | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUpdateCouponInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.amount = _data["amount"];
            this.spreadId = _data["spreadId"];
            this.title = _data["title"];
            this.outerId = _data["outerId"];
            this.pictures = _data["pictures"];
            this.start_time = _data["start_time"] ? moment(_data["start_time"].toString()) : <any>undefined;
            this.end_time = _data["end_time"] ? moment(_data["end_time"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.auditStatus = _data["auditStatus"];
            this.code = _data["code"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UpdateCouponInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCouponInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["amount"] = this.amount;
        data["spreadId"] = this.spreadId;
        data["title"] = this.title;
        data["outerId"] = this.outerId;
        data["pictures"] = this.pictures;
        data["start_time"] = this.start_time ? this.start_time.toISOString() : <any>undefined;
        data["end_time"] = this.end_time ? this.end_time.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["auditStatus"] = this.auditStatus;
        data["code"] = this.code;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUpdateCouponInput {
    id: number;
    /** 面额 */
    amount: number;
    /** 优惠券活动ID 应该是模板id */
    spreadId: string | undefined;
    /** 优惠券名称 */
    title: string;
    /** 优惠券其它平台的Id */
    outerId: string | undefined;
    /** 优惠券图片 */
    pictures: string | undefined;
    /** 优惠券生效时间 */
    start_time: moment.Moment;
    /** 优惠券的截止日期 */
    end_time: moment.Moment;
    /** 优惠券地址 */
    url: string | undefined;
    auditStatus: AuditStatus;
    /** 外部定义的 */
    code: string | undefined;
    organizationUnitId: number | undefined;
}

export class UpdateDefaultPriceTagInput implements IUpdateDefaultPriceTagInput {
    deviceId!: number;
    targetSkuId!: number;

    constructor(data?: IUpdateDefaultPriceTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.targetSkuId = _data["targetSkuId"];
        }
    }

    static fromJS(data: any): UpdateDefaultPriceTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDefaultPriceTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["targetSkuId"] = this.targetSkuId;
        return data; 
    }
}

export interface IUpdateDefaultPriceTagInput {
    deviceId: number;
    targetSkuId: number;
}

export class UpdateEntityResourceInput implements IUpdateEntityResourceInput {
    id!: number;
    resouceId!: number;
    usage!: string | undefined;
    description!: string | undefined;
    orderNumber!: number;
    fromType!: string | undefined;

    constructor(data?: IUpdateEntityResourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resouceId = _data["resouceId"];
            this.usage = _data["usage"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): UpdateEntityResourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntityResourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resouceId"] = this.resouceId;
        data["usage"] = this.usage;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IUpdateEntityResourceInput {
    id: number;
    resouceId: number;
    usage: string | undefined;
    description: string | undefined;
    orderNumber: number;
    fromType: string | undefined;
}

export class UpdateLikeInfoInput implements IUpdateLikeInfoInput {
    id!: number;
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateLikeInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLikeInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLikeInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateLikeInfoInput {
    id: number;
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class UpdateLikeItemInput implements IUpdateLikeItemInput {
    id!: number;
    code!: string;
    orderNumber!: number;
    name!: string | undefined;
    image!: string | undefined;
    skuIds!: number[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateLikeItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.image = _data["image"];
            if (Array.isArray(_data["skuIds"])) {
                this.skuIds = [] as any;
                for (let item of _data["skuIds"])
                    this.skuIds!.push(item);
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLikeItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLikeItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["image"] = this.image;
        if (Array.isArray(this.skuIds)) {
            data["skuIds"] = [];
            for (let item of this.skuIds)
                data["skuIds"].push(item);
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateLikeItemInput {
    id: number;
    code: string;
    orderNumber: number;
    name: string | undefined;
    image: string | undefined;
    skuIds: number[] | undefined;
    description: string | undefined;
}

export class UpdateMatchInfoInput implements IUpdateMatchInfoInput {
    id!: number;
    orderNumber!: number;
    /** 展示图 */
    showImage!: string | undefined;
    /** 搭配效果大图 */
    bImg!: string | undefined;
    /** 搭配效果中图 */
    mImg!: string | undefined;
    /** 搭配效果小图 */
    sImg!: string | undefined;
    name!: string | undefined;
    code!: string | undefined;
    skus!: MainSku[] | undefined;
    description!: string | undefined;

    constructor(data?: IUpdateMatchInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.showImage = _data["showImage"];
            this.bImg = _data["bImg"];
            this.mImg = _data["mImg"];
            this.sImg = _data["sImg"];
            this.name = _data["name"];
            this.code = _data["code"];
            if (Array.isArray(_data["skus"])) {
                this.skus = [] as any;
                for (let item of _data["skus"])
                    this.skus!.push(MainSku.fromJS(item));
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateMatchInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMatchInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["showImage"] = this.showImage;
        data["bImg"] = this.bImg;
        data["mImg"] = this.mImg;
        data["sImg"] = this.sImg;
        data["name"] = this.name;
        data["code"] = this.code;
        if (Array.isArray(this.skus)) {
            data["skus"] = [];
            for (let item of this.skus)
                data["skus"].push(item.toJSON());
        }
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateMatchInfoInput {
    id: number;
    orderNumber: number;
    /** 展示图 */
    showImage: string | undefined;
    /** 搭配效果大图 */
    bImg: string | undefined;
    /** 搭配效果中图 */
    mImg: string | undefined;
    /** 搭配效果小图 */
    sImg: string | undefined;
    name: string | undefined;
    code: string | undefined;
    skus: MainSku[] | undefined;
    description: string | undefined;
}

export class UpdateMatchItemInput implements IUpdateMatchItemInput {
    id!: number;
    skuId!: number;
    matchInfoId!: number;
    reason!: string | undefined;
    isMain!: boolean;

    constructor(data?: IUpdateMatchItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.skuId = _data["skuId"];
            this.matchInfoId = _data["matchInfoId"];
            this.reason = _data["reason"];
            this.isMain = _data["isMain"];
        }
    }

    static fromJS(data: any): UpdateMatchItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMatchItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["skuId"] = this.skuId;
        data["matchInfoId"] = this.matchInfoId;
        data["reason"] = this.reason;
        data["isMain"] = this.isMain;
        return data; 
    }
}

export interface IUpdateMatchItemInput {
    id: number;
    skuId: number;
    matchInfoId: number;
    reason: string | undefined;
    isMain: boolean;
}

export class UpdateProductCategoryInput implements IUpdateProductCategoryInput {
    id!: number;
    /** 可被理解的分类唯一编码. */
    categoryCode!: string | undefined;
    /** 分类的名称 */
    name!: string;
    /** 父分类 */
    parentCategoryId!: number | undefined;
    /** 分类的图片 */
    imageUrl!: string | undefined;
    iconUrl!: string | undefined;
    isLocal!: boolean;
    isSpecial!: boolean;
    fromType!: string | undefined;

    constructor(data?: IUpdateProductCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryCode = _data["categoryCode"];
            this.name = _data["name"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.imageUrl = _data["imageUrl"];
            this.iconUrl = _data["iconUrl"];
            this.isLocal = _data["isLocal"];
            this.isSpecial = _data["isSpecial"];
            this.fromType = _data["fromType"];
        }
    }

    static fromJS(data: any): UpdateProductCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryCode"] = this.categoryCode;
        data["name"] = this.name;
        data["parentCategoryId"] = this.parentCategoryId;
        data["imageUrl"] = this.imageUrl;
        data["iconUrl"] = this.iconUrl;
        data["isLocal"] = this.isLocal;
        data["isSpecial"] = this.isSpecial;
        data["fromType"] = this.fromType;
        return data; 
    }
}

export interface IUpdateProductCategoryInput {
    id: number;
    /** 可被理解的分类唯一编码. */
    categoryCode: string | undefined;
    /** 分类的名称 */
    name: string;
    /** 父分类 */
    parentCategoryId: number | undefined;
    /** 分类的图片 */
    imageUrl: string | undefined;
    iconUrl: string | undefined;
    isLocal: boolean;
    isSpecial: boolean;
    fromType: string | undefined;
}

export class UpdateProductCommentInput implements IUpdateProductCommentInput {
    id!: number;
    /** 评论者的用户名 */
    userName!: string | undefined;
    /** 评论者的头像 */
    avatorUrl!: string | undefined;
    /** 评论的内容 */
    content!: string | undefined;
    /** 评论时间 */
    commentDateTime!: moment.Moment | undefined;
    orderNumber!: number;

    constructor(data?: IUpdateProductCommentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.avatorUrl = _data["avatorUrl"];
            this.content = _data["content"];
            this.commentDateTime = _data["commentDateTime"] ? moment(_data["commentDateTime"].toString()) : <any>undefined;
            this.orderNumber = _data["orderNumber"];
        }
    }

    static fromJS(data: any): UpdateProductCommentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["avatorUrl"] = this.avatorUrl;
        data["content"] = this.content;
        data["commentDateTime"] = this.commentDateTime ? this.commentDateTime.toISOString() : <any>undefined;
        data["orderNumber"] = this.orderNumber;
        return data; 
    }
}

export interface IUpdateProductCommentInput {
    id: number;
    /** 评论者的用户名 */
    userName: string | undefined;
    /** 评论者的头像 */
    avatorUrl: string | undefined;
    /** 评论的内容 */
    content: string | undefined;
    /** 评论时间 */
    commentDateTime: moment.Moment | undefined;
    orderNumber: number;
}

export class UpdateProductInput implements IUpdateProductInput {
    id!: number;
    /** 商品 Id */
    itemId!: string;
    shopFreightId!: number | undefined;
    freightType!: ShopFreightBindingType;
    fixedPrice!: number | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    /** 商品名称 */
    title!: string | undefined;
    /** 二级标题 */
    subTitle!: string | undefined;
    /** 商品主图 */
    picUrl!: string | undefined;
    /** 商品分类 */
    categorys!: number[] | undefined;
    /** 商品关键字 */
    keywords!: string | undefined;
    /** 商品的标签 */
    tags!: number[] | undefined;
    /** 商品库存 */
    quantity!: number;
    /** 数据来源 */
    fromType!: string | undefined;
    /** 价格 */
    price!: number;
    /** 价格 */
    price2!: number | undefined;
    /** 优惠价 */
    promPrice!: number | undefined;
    /** 总销量 */
    salesVolume!: number;
    orderNumber!: number;
    barcode!: string | undefined;
    /** 状态 */
    auditStatus!: number;
    /** 商品备注信息 */
    description!: string | undefined;
    ageScope!: string | undefined;
    gender!: string | undefined;
    starLevel!: number | undefined;
    material3DUrl!: string | undefined;
    brandId!: number | undefined;
    language!: string | undefined;
    region!: string | undefined;
    organizationUnitId!: number | undefined;
    pointRule!: ProductPointRule;

    constructor(data?: IUpdateProductInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.itemId = _data["itemId"];
            this.shopFreightId = _data["shopFreightId"];
            this.freightType = _data["freightType"];
            this.fixedPrice = _data["fixedPrice"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.subTitle = _data["subTitle"];
            this.picUrl = _data["picUrl"];
            if (Array.isArray(_data["categorys"])) {
                this.categorys = [] as any;
                for (let item of _data["categorys"])
                    this.categorys!.push(item);
            }
            this.keywords = _data["keywords"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.quantity = _data["quantity"];
            this.fromType = _data["fromType"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.starLevel = _data["starLevel"];
            this.material3DUrl = _data["material3DUrl"];
            this.brandId = _data["brandId"];
            this.language = _data["language"];
            this.region = _data["region"];
            this.organizationUnitId = _data["organizationUnitId"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProductInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["itemId"] = this.itemId;
        data["shopFreightId"] = this.shopFreightId;
        data["freightType"] = this.freightType;
        data["fixedPrice"] = this.fixedPrice;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["subTitle"] = this.subTitle;
        data["picUrl"] = this.picUrl;
        if (Array.isArray(this.categorys)) {
            data["categorys"] = [];
            for (let item of this.categorys)
                data["categorys"].push(item);
        }
        data["keywords"] = this.keywords;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["quantity"] = this.quantity;
        data["fromType"] = this.fromType;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["starLevel"] = this.starLevel;
        data["material3DUrl"] = this.material3DUrl;
        data["brandId"] = this.brandId;
        data["language"] = this.language;
        data["region"] = this.region;
        data["organizationUnitId"] = this.organizationUnitId;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateProductInput {
    id: number;
    /** 商品 Id */
    itemId: string;
    shopFreightId: number | undefined;
    freightType: ShopFreightBindingType;
    fixedPrice: number | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    /** 商品名称 */
    title: string | undefined;
    /** 二级标题 */
    subTitle: string | undefined;
    /** 商品主图 */
    picUrl: string | undefined;
    /** 商品分类 */
    categorys: number[] | undefined;
    /** 商品关键字 */
    keywords: string | undefined;
    /** 商品的标签 */
    tags: number[] | undefined;
    /** 商品库存 */
    quantity: number;
    /** 数据来源 */
    fromType: string | undefined;
    /** 价格 */
    price: number;
    /** 价格 */
    price2: number | undefined;
    /** 优惠价 */
    promPrice: number | undefined;
    /** 总销量 */
    salesVolume: number;
    orderNumber: number;
    barcode: string | undefined;
    /** 状态 */
    auditStatus: number;
    /** 商品备注信息 */
    description: string | undefined;
    ageScope: string | undefined;
    gender: string | undefined;
    starLevel: number | undefined;
    material3DUrl: string | undefined;
    brandId: number | undefined;
    language: string | undefined;
    region: string | undefined;
    organizationUnitId: number | undefined;
    pointRule: ProductPointRule;
}

export class UpdateProductOnlineInfoInput implements IUpdateProductOnlineInfoInput {
    id!: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId!: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商品的PID */
    pid!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: IUpdateProductOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.pid = _data["pid"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): UpdateProductOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["pid"] = this.pid;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IUpdateProductOnlineInfoInput {
    id: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商品的PID */
    pid: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class UpdatePropertyInput implements IUpdatePropertyInput {
    id!: number;
    orderNumber!: number;
    /** 属性的名称 */
    name!: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage!: boolean;
    /** 是否是销售属性 */
    isForSale!: boolean;
    /** 来源类型 */
    fromType!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdatePropertyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.name = _data["name"];
            this.isDefaultDecideImage = _data["isDefaultDecideImage"];
            this.isForSale = _data["isForSale"];
            this.fromType = _data["fromType"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdatePropertyInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePropertyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["name"] = this.name;
        data["isDefaultDecideImage"] = this.isDefaultDecideImage;
        data["isForSale"] = this.isForSale;
        data["fromType"] = this.fromType;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdatePropertyInput {
    id: number;
    orderNumber: number;
    /** 属性的名称 */
    name: string;
    /** 是否是显图属性,是显图属性一定是销售属性 */
    isDefaultDecideImage: boolean;
    /** 是否是销售属性 */
    isForSale: boolean;
    /** 来源类型 */
    fromType: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class UpdatePropertyValueInput implements IUpdatePropertyValueInput {
    id!: number;
    orderNumber!: number;
    propertyId!: number;
    value!: string | undefined;
    description!: string | undefined;
    iconUrl!: string | undefined;

    constructor(data?: IUpdatePropertyValueInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): UpdatePropertyValueInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePropertyValueInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        return data; 
    }
}

export interface IUpdatePropertyValueInput {
    id: number;
    orderNumber: number;
    propertyId: number;
    value: string | undefined;
    description: string | undefined;
    iconUrl: string | undefined;
}

export class UpdateSkuInput implements IUpdateSkuInput {
    id!: number;
    productId!: number;
    /** Sku Id */
    sku_id!: string | undefined;
    rfidCode!: string | undefined;
    outerId!: string | undefined;
    /** Sku 名称 */
    title!: string | undefined;
    /** Sku 价格 */
    price!: number;
    /** 价格 */
    price2!: number | undefined;
    /** Sku 促销价 */
    promPrice!: number | undefined;
    /** 总销量 */
    salesVolume!: number;
    /** Sku 库存 */
    quantity!: number;
    /** Sku 主图 */
    picUrl!: string | undefined;
    /** Sku 针对年龄段 */
    ageScope!: string | undefined;
    /** Sku 针对性别 */
    gender!: string | undefined;
    auditStatus!: number;
    description!: string | undefined;
    orderNumber!: number;
    barcode!: string | undefined;
    tags!: number[] | undefined;
    propertyValueIds!: number[] | undefined;
    starLevel!: number | undefined;
    keywords!: string | undefined;
    pointRule!: ProductPointRule;
    weight!: number | undefined;

    constructor(data?: IUpdateSkuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.sku_id = _data["sku_id"];
            this.rfidCode = _data["rfidCode"];
            this.outerId = _data["outerId"];
            this.title = _data["title"];
            this.price = _data["price"];
            this.price2 = _data["price2"];
            this.promPrice = _data["promPrice"];
            this.salesVolume = _data["salesVolume"];
            this.quantity = _data["quantity"];
            this.picUrl = _data["picUrl"];
            this.ageScope = _data["ageScope"];
            this.gender = _data["gender"];
            this.auditStatus = _data["auditStatus"];
            this.description = _data["description"];
            this.orderNumber = _data["orderNumber"];
            this.barcode = _data["barcode"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["propertyValueIds"])) {
                this.propertyValueIds = [] as any;
                for (let item of _data["propertyValueIds"])
                    this.propertyValueIds!.push(item);
            }
            this.starLevel = _data["starLevel"];
            this.keywords = _data["keywords"];
            this.pointRule = _data["pointRule"] ? ProductPointRule.fromJS(_data["pointRule"]) : <any>undefined;
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): UpdateSkuInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["sku_id"] = this.sku_id;
        data["rfidCode"] = this.rfidCode;
        data["outerId"] = this.outerId;
        data["title"] = this.title;
        data["price"] = this.price;
        data["price2"] = this.price2;
        data["promPrice"] = this.promPrice;
        data["salesVolume"] = this.salesVolume;
        data["quantity"] = this.quantity;
        data["picUrl"] = this.picUrl;
        data["ageScope"] = this.ageScope;
        data["gender"] = this.gender;
        data["auditStatus"] = this.auditStatus;
        data["description"] = this.description;
        data["orderNumber"] = this.orderNumber;
        data["barcode"] = this.barcode;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.propertyValueIds)) {
            data["propertyValueIds"] = [];
            for (let item of this.propertyValueIds)
                data["propertyValueIds"].push(item);
        }
        data["starLevel"] = this.starLevel;
        data["keywords"] = this.keywords;
        data["pointRule"] = this.pointRule ? this.pointRule.toJSON() : <any>undefined;
        data["weight"] = this.weight;
        return data; 
    }
}

export interface IUpdateSkuInput {
    id: number;
    productId: number;
    /** Sku Id */
    sku_id: string | undefined;
    rfidCode: string | undefined;
    outerId: string | undefined;
    /** Sku 名称 */
    title: string | undefined;
    /** Sku 价格 */
    price: number;
    /** 价格 */
    price2: number | undefined;
    /** Sku 促销价 */
    promPrice: number | undefined;
    /** 总销量 */
    salesVolume: number;
    /** Sku 库存 */
    quantity: number;
    /** Sku 主图 */
    picUrl: string | undefined;
    /** Sku 针对年龄段 */
    ageScope: string | undefined;
    /** Sku 针对性别 */
    gender: string | undefined;
    auditStatus: number;
    description: string | undefined;
    orderNumber: number;
    barcode: string | undefined;
    tags: number[] | undefined;
    propertyValueIds: number[] | undefined;
    starLevel: number | undefined;
    keywords: string | undefined;
    pointRule: ProductPointRule;
    weight: number | undefined;
}

export class UpdateSkuOnlineInfoInput implements IUpdateSkuOnlineInfoInput {
    id!: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId!: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName!: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId!: number;
    /** 线上商品的PID */
    sku_ID!: string | undefined;
    /** 线上商场Product的价格. */
    price!: number | undefined;
    /** 线上商城的库存. */
    inventory!: number | undefined;
    /** 线上商城的二维码. */
    qrcode!: string | undefined;

    constructor(data?: IUpdateSkuOnlineInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.onlineStoreName = _data["onlineStoreName"];
            this.onlineStoreId = _data["onlineStoreId"];
            this.sku_ID = _data["sku_ID"];
            this.price = _data["price"];
            this.inventory = _data["inventory"];
            this.qrcode = _data["qrcode"];
        }
    }

    static fromJS(data: any): UpdateSkuOnlineInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuOnlineInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["onlineStoreName"] = this.onlineStoreName;
        data["onlineStoreId"] = this.onlineStoreId;
        data["sku_ID"] = this.sku_ID;
        data["price"] = this.price;
        data["inventory"] = this.inventory;
        data["qrcode"] = this.qrcode;
        return data; 
    }
}

export interface IUpdateSkuOnlineInfoInput {
    id: number;
    /** 线上商场的Id.比如 自然醒天猫旗舰店，自然醒京东旗舰店 */
    storeId: string | undefined;
    /** 线上商城的类型. 比如天猫，京东 */
    onlineStoreName: string | undefined;
    /** 第三方系统定义的商城类型id，所属第三方系统 */
    onlineStoreId: number;
    /** 线上商品的PID */
    sku_ID: string | undefined;
    /** 线上商场Product的价格. */
    price: number | undefined;
    /** 线上商城的库存. */
    inventory: number | undefined;
    /** 线上商城的二维码. */
    qrcode: string | undefined;
}

export class UpdateSkuRfidInput implements IUpdateSkuRfidInput {
    id!: number;
    storeId!: number | undefined;
    skuId!: number | undefined;
    sku_Id!: string | undefined;
    rfidCode!: string | undefined;

    constructor(data?: IUpdateSkuRfidInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeId = _data["storeId"];
            this.skuId = _data["skuId"];
            this.sku_Id = _data["sku_Id"];
            this.rfidCode = _data["rfidCode"];
        }
    }

    static fromJS(data: any): UpdateSkuRfidInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkuRfidInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["skuId"] = this.skuId;
        data["sku_Id"] = this.sku_Id;
        data["rfidCode"] = this.rfidCode;
        return data; 
    }
}

export interface IUpdateSkuRfidInput {
    id: number;
    storeId: number | undefined;
    skuId: number | undefined;
    sku_Id: string | undefined;
    rfidCode: string | undefined;
}

export class UpdateTagInput implements IUpdateTagInput {
    id!: number;
    value!: string | undefined;
    type!: TagType;
    iconUrl!: string | undefined;
    isSpecial!: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber!: number;
    description!: string | undefined;

    constructor(data?: IUpdateTagInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.type = _data["type"];
            this.iconUrl = _data["iconUrl"];
            this.isSpecial = _data["isSpecial"];
            this.orderNumber = _data["orderNumber"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTagInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTagInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["type"] = this.type;
        data["iconUrl"] = this.iconUrl;
        data["isSpecial"] = this.isSpecial;
        data["orderNumber"] = this.orderNumber;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateTagInput {
    id: number;
    value: string | undefined;
    type: TagType;
    iconUrl: string | undefined;
    isSpecial: boolean;
    /** 显示 Entity 的排序顺序. */
    orderNumber: number;
    description: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}