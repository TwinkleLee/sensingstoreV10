/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_USER_URL = new InjectionToken<string>('API_USER_URL');

@Injectable()
export class ApplicationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_USER_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createApplication(input: CreateApplicationInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Application/CreateApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApplication(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateApplication(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateApplication(input: UpdateApplicationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/UpdateApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteApplication(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/DeleteApplication?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    batchDeleteApplication(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/BatchDeleteApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeleteApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeleteApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeleteApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplications(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/GetApplications?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplications(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfApplicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfApplicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplications(response: HttpResponseBase): Observable<PagedResultDtoOfApplicationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfApplicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfApplicationDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSingleApplication(id: number | null | undefined): Observable<ApplicationDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/GetSingleApplication?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSingleApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleApplication(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSingleApplication(response: HttpResponseBase): Observable<ApplicationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationDto>(<any>null);
    }

    /**
     * @param applicationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApplicationPages(applicationId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfPageDto> {
        let url_ = this.baseUrl + "/api/services/app/Application/GetApplicationPages?";
        if (applicationId !== undefined)
            url_ += "ApplicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApplicationPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApplicationPages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetApplicationPages(response: HttpResponseBase): Observable<PagedResultDtoOfPageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfPageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPages(input: CreatePagesInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Application/CreatePages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePages(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePages(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updatePages(input: UpdatePagesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/UpdatePages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/DeletePage?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    batchDeletePages(ids: number[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Application/BatchDeletePages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDeletePages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDeletePages(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDeletePages(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AppointmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_USER_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    createAppointment(input: CreateAppointmentInput | null | undefined, tenantId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/CreateAppointment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAppointment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    updateAppointment(input: UpdateAppointmentInput | null | undefined, tenantId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/UpdateAppointment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAppointment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAppointment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param openId (optional) 
     * @param storeId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getAppointmentsForHall(openId: string | null | undefined, storeId: number | null | undefined, tenantId: number | null | undefined): Observable<AppointmentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/GetAppointmentsForHall?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        if (storeId !== undefined)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentsForHall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsForHall(<any>response_);
                } catch (e) {
                    return <Observable<AppointmentDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppointmentDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppointmentsForHall(response: HttpResponseBase): Observable<AppointmentDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppointmentDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppointmentDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    auditAppointment(input: AuditAppointmentInput | null | undefined, tenantId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Appointment/AuditAppointment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuditAppointment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuditAppointment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAuditAppointment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IdentityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_USER_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getClaims(): Observable<string> {
        let url_ = this.baseUrl + "/Identity/GetClaims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class PageExtraServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_USER_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param productId (optional) 
     * @param skuId (optional) 
     * @param deviceActivityGameId (optional) 
     * @param salesId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getPageExtras(applicationName: string, pageName: string, productId: number | null | undefined, skuId: number | null | undefined, deviceActivityGameId: number | null | undefined, salesId: number | null | undefined, tenantId: number | null | undefined): Observable<PageExtrasDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PageExtra/GetPageExtras?";
        if (applicationName === undefined || applicationName === null)
            throw new Error("The parameter 'applicationName' must be defined and cannot be null.");
        else
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&"; 
        if (pageName === undefined || pageName === null)
            throw new Error("The parameter 'pageName' must be defined and cannot be null.");
        else
            url_ += "PageName=" + encodeURIComponent("" + pageName) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (skuId !== undefined)
            url_ += "SkuId=" + encodeURIComponent("" + skuId) + "&"; 
        if (deviceActivityGameId !== undefined)
            url_ += "DeviceActivityGameId=" + encodeURIComponent("" + deviceActivityGameId) + "&"; 
        if (salesId !== undefined)
            url_ += "SalesId=" + encodeURIComponent("" + salesId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageExtras(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageExtras(<any>response_);
                } catch (e) {
                    return <Observable<PageExtrasDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageExtrasDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageExtras(response: HttpResponseBase): Observable<PageExtrasDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PageExtrasDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageExtrasDto[]>(<any>null);
    }
}

@Injectable()
export class UserDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_USER_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param appKey (optional) 
     * @param input (optional) 
     * @return Success
     */
    addMarketData(appKey: string | null | undefined, input: AddMarketDataInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UserData/AddMarketData?";
        if (appKey !== undefined)
            url_ += "appKey=" + encodeURIComponent("" + appKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMarketData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMarketData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddMarketData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param appKey (optional) 
     * @param id (optional) 
     * @return Success
     */
    updateMarketData(appKey: string | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserData/UpdateMarketData?";
        if (appKey !== undefined)
            url_ += "appKey=" + encodeURIComponent("" + appKey) + "&"; 
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMarketData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMarketData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMarketData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appKey (optional) 
     * @param input (optional) 
     * @return Success
     */
    addOrUpdateRequirement(appKey: string | null | undefined, input: AddOrUpdateRequirementInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserData/AddOrUpdateRequirement?";
        if (appKey !== undefined)
            url_ += "appKey=" + encodeURIComponent("" + appKey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddOrUpdateRequirement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddOrUpdateRequirement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddOrUpdateRequirement(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param handled (optional) 
     * @param applicationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getCustomerRequirements(handled: boolean | null | undefined, applicationId: number | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetRequirementsDto> {
        let url_ = this.baseUrl + "/api/services/app/UserData/GetCustomerRequirements?";
        if (handled !== undefined)
            url_ += "Handled=" + encodeURIComponent("" + handled) + "&"; 
        if (applicationId !== undefined)
            url_ += "ApplicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerRequirements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerRequirements(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRequirementsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRequirementsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerRequirements(response: HttpResponseBase): Observable<PagedResultDtoOfGetRequirementsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRequirementsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRequirementsDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    handleRequirements(input: HandleRequirementsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserData/HandleRequirements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleRequirements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleRequirements(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHandleRequirements(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param recordAction (optional) 
     * @param collectionStartTime (optional) 
     * @param collectionEndTime (optional) 
     * @param openId (optional) 
     * @param from (optional) 
     * @param pageName (optional) 
     * @param applicationName (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getSpecifiedActionCount(recordAction: string | null | undefined, collectionStartTime: moment.Moment | null | undefined, collectionEndTime: moment.Moment | null | undefined, openId: string | null | undefined, from: string | null | undefined, pageName: string | null | undefined, applicationName: string | null | undefined, tenantId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/UserData/GetSpecifiedActionCount?";
        if (recordAction !== undefined)
            url_ += "recordAction=" + encodeURIComponent("" + recordAction) + "&"; 
        if (collectionStartTime !== undefined)
            url_ += "CollectionStartTime=" + encodeURIComponent(collectionStartTime ? "" + collectionStartTime.toJSON() : "") + "&"; 
        if (collectionEndTime !== undefined)
            url_ += "CollectionEndTime=" + encodeURIComponent(collectionEndTime ? "" + collectionEndTime.toJSON() : "") + "&"; 
        if (openId !== undefined)
            url_ += "OpenId=" + encodeURIComponent("" + openId) + "&"; 
        if (from !== undefined)
            url_ += "From=" + encodeURIComponent("" + from) + "&"; 
        if (pageName !== undefined)
            url_ += "PageName=" + encodeURIComponent("" + pageName) + "&"; 
        if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecifiedActionCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecifiedActionCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpecifiedActionCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param applicationName (optional) 
     * @param pageName (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getRecentVisitorInfo(applicationName: string | null | undefined, pageName: string | null | undefined, tenantId: number | null | undefined): Observable<VisitorInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/UserData/GetRecentVisitorInfo?";
        if (applicationName !== undefined)
            url_ += "ApplicationName=" + encodeURIComponent("" + applicationName) + "&"; 
        if (pageName !== undefined)
            url_ += "PageName=" + encodeURIComponent("" + pageName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentVisitorInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentVisitorInfo(<any>response_);
                } catch (e) {
                    return <Observable<VisitorInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VisitorInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentVisitorInfo(response: HttpResponseBase): Observable<VisitorInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitorInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VisitorInfoDto>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @return Success
     */
    getRecentAction4Hall(tenantId: number | null | undefined): Observable<RecentActionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserData/GetRecentAction4Hall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "tenantId": tenantId !== undefined && tenantId !== null ? "" + tenantId : "", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentAction4Hall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentAction4Hall(<any>response_);
                } catch (e) {
                    return <Observable<RecentActionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecentActionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentAction4Hall(response: HttpResponseBase): Observable<RecentActionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecentActionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecentActionDto[]>(<any>null);
    }
}

export class CreateApplicationInput implements ICreateApplicationInput {
    name!: string | undefined;
    host!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: ICreateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.host = data["host"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): CreateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["host"] = this.host;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface ICreateApplicationInput {
    name: string | undefined;
    host: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class UpdateApplicationInput implements IUpdateApplicationInput {
    id!: number | undefined;
    name!: string | undefined;
    host!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IUpdateApplicationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.host = data["host"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): UpdateApplicationInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["host"] = this.host;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IUpdateApplicationInput {
    id: number | undefined;
    name: string | undefined;
    host: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class PagedResultDtoOfApplicationDto implements IPagedResultDtoOfApplicationDto {
    totalCount!: number | undefined;
    items!: ApplicationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfApplicationDto {
    totalCount: number | undefined;
    items: ApplicationDto[] | undefined;
}

export class ApplicationDto implements IApplicationDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    appKey!: string | undefined;
    name!: string | undefined;
    host!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.appKey = data["appKey"];
            this.name = data["name"];
            this.host = data["host"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            if (Array.isArray(data["pages"])) {
                this.pages = [] as any;
                for (let item of data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["appKey"] = this.appKey;
        data["name"] = this.name;
        data["host"] = this.host;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationDto {
    id: number | undefined;
    tenantId: number | undefined;
    appKey: string | undefined;
    name: string | undefined;
    host: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    pages: Page[] | undefined;
}

export class Page implements IPage {
    tenantId!: number | undefined;
    applicationId!: number | undefined;
    application!: Application | undefined;
    name!: string | undefined;
    url!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.applicationId = data["applicationId"];
            this.application = data["application"] ? Application.fromJS(data["application"]) : <any>undefined;
            this.name = data["name"];
            this.url = data["url"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["url"] = this.url;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPage {
    tenantId: number | undefined;
    applicationId: number | undefined;
    application: Application | undefined;
    name: string | undefined;
    url: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Application implements IApplication {
    tenantId!: number | undefined;
    appKey!: string | undefined;
    name!: string | undefined;
    host!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    pages!: Page[] | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.appKey = data["appKey"];
            this.name = data["name"];
            this.host = data["host"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            if (Array.isArray(data["pages"])) {
                this.pages = [] as any;
                for (let item of data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["appKey"] = this.appKey;
        data["name"] = this.name;
        data["host"] = this.host;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplication {
    tenantId: number | undefined;
    appKey: string | undefined;
    name: string | undefined;
    host: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    pages: Page[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfPageDto implements IPagedResultDtoOfPageDto {
    totalCount!: number | undefined;
    items!: PageDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(PageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfPageDto {
    totalCount: number | undefined;
    items: PageDto[] | undefined;
}

export class PageDto implements IPageDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    name!: string | undefined;
    url!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    pageExtras!: PageExtraDto[] | undefined;

    constructor(data?: IPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.url = data["url"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            if (Array.isArray(data["pageExtras"])) {
                this.pageExtras = [] as any;
                for (let item of data["pageExtras"])
                    this.pageExtras!.push(PageExtraDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["url"] = this.url;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.pageExtras)) {
            data["pageExtras"] = [];
            for (let item of this.pageExtras)
                data["pageExtras"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPageDto {
    id: number | undefined;
    tenantId: number | undefined;
    name: string | undefined;
    url: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    pageExtras: PageExtraDto[] | undefined;
}

export class PageExtraDto implements IPageExtraDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    pageId!: number | undefined;
    productId!: number | undefined;
    skuId!: number | undefined;
    deviceActivityGameId!: number | undefined;
    salesId!: number | undefined;

    constructor(data?: IPageExtraDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.pageId = data["pageId"];
            this.productId = data["productId"];
            this.skuId = data["skuId"];
            this.deviceActivityGameId = data["deviceActivityGameId"];
            this.salesId = data["salesId"];
        }
    }

    static fromJS(data: any): PageExtraDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageExtraDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["pageId"] = this.pageId;
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["salesId"] = this.salesId;
        return data; 
    }
}

export interface IPageExtraDto {
    id: number | undefined;
    tenantId: number | undefined;
    pageId: number | undefined;
    productId: number | undefined;
    skuId: number | undefined;
    deviceActivityGameId: number | undefined;
    salesId: number | undefined;
}

export class CreatePagesInput implements ICreatePagesInput {
    applicationId!: number | undefined;
    name!: string | undefined;
    url!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    pageExtras!: PageExtraInput[] | undefined;

    constructor(data?: ICreatePagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.applicationId = data["applicationId"];
            this.name = data["name"];
            this.url = data["url"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            if (Array.isArray(data["pageExtras"])) {
                this.pageExtras = [] as any;
                for (let item of data["pageExtras"])
                    this.pageExtras!.push(PageExtraInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["name"] = this.name;
        data["url"] = this.url;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.pageExtras)) {
            data["pageExtras"] = [];
            for (let item of this.pageExtras)
                data["pageExtras"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreatePagesInput {
    applicationId: number | undefined;
    name: string | undefined;
    url: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    pageExtras: PageExtraInput[] | undefined;
}

export class PageExtraInput implements IPageExtraInput {
    productId!: number | undefined;
    skuId!: number | undefined;
    deviceActivityGameId!: number | undefined;
    salesId!: number | undefined;

    constructor(data?: IPageExtraInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.productId = data["productId"];
            this.skuId = data["skuId"];
            this.deviceActivityGameId = data["deviceActivityGameId"];
            this.salesId = data["salesId"];
        }
    }

    static fromJS(data: any): PageExtraInput {
        data = typeof data === 'object' ? data : {};
        let result = new PageExtraInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["salesId"] = this.salesId;
        return data; 
    }
}

export interface IPageExtraInput {
    productId: number | undefined;
    skuId: number | undefined;
    deviceActivityGameId: number | undefined;
    salesId: number | undefined;
}

export class UpdatePagesInput implements IUpdatePagesInput {
    id!: number | undefined;
    applicationId!: number | undefined;
    name!: string | undefined;
    url!: string | undefined;
    iconUrl!: string | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;
    pageExtras!: PageExtraInput[] | undefined;

    constructor(data?: IUpdatePagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.applicationId = data["applicationId"];
            this.name = data["name"];
            this.url = data["url"];
            this.iconUrl = data["iconUrl"];
            this.description = data["description"];
            this.extensionData = data["extensionData"];
            if (Array.isArray(data["pageExtras"])) {
                this.pageExtras = [] as any;
                for (let item of data["pageExtras"])
                    this.pageExtras!.push(PageExtraInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["name"] = this.name;
        data["url"] = this.url;
        data["iconUrl"] = this.iconUrl;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        if (Array.isArray(this.pageExtras)) {
            data["pageExtras"] = [];
            for (let item of this.pageExtras)
                data["pageExtras"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdatePagesInput {
    id: number | undefined;
    applicationId: number | undefined;
    name: string | undefined;
    url: string | undefined;
    iconUrl: string | undefined;
    description: string | undefined;
    extensionData: string | undefined;
    pageExtras: PageExtraInput[] | undefined;
}

export class CreateAppointmentInput implements ICreateAppointmentInput {
    storeId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    visitorCount!: number | undefined;
    companyName!: string | undefined;
    appointmentTime!: moment.Moment | undefined;
    remarks!: string | undefined;
    from!: string | undefined;
    openId!: string | undefined;

    constructor(data?: ICreateAppointmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeId = data["storeId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.visitorCount = data["visitorCount"];
            this.companyName = data["companyName"];
            this.appointmentTime = data["appointmentTime"] ? moment(data["appointmentTime"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
            this.from = data["from"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): CreateAppointmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppointmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["visitorCount"] = this.visitorCount;
        data["companyName"] = this.companyName;
        data["appointmentTime"] = this.appointmentTime ? this.appointmentTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["from"] = this.from;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface ICreateAppointmentInput {
    storeId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    visitorCount: number | undefined;
    companyName: string | undefined;
    appointmentTime: moment.Moment | undefined;
    remarks: string | undefined;
    from: string | undefined;
    openId: string | undefined;
}

export class UpdateAppointmentInput implements IUpdateAppointmentInput {
    id!: number | undefined;
    storeId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    visitorCount!: number | undefined;
    companyName!: string | undefined;
    appointmentTime!: moment.Moment | undefined;
    remarks!: string | undefined;
    from!: string | undefined;
    openId!: string | undefined;

    constructor(data?: IUpdateAppointmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.storeId = data["storeId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.visitorCount = data["visitorCount"];
            this.companyName = data["companyName"];
            this.appointmentTime = data["appointmentTime"] ? moment(data["appointmentTime"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
            this.from = data["from"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): UpdateAppointmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppointmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["visitorCount"] = this.visitorCount;
        data["companyName"] = this.companyName;
        data["appointmentTime"] = this.appointmentTime ? this.appointmentTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["from"] = this.from;
        data["openId"] = this.openId;
        return data; 
    }
}

export interface IUpdateAppointmentInput {
    id: number | undefined;
    storeId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    visitorCount: number | undefined;
    companyName: string | undefined;
    appointmentTime: moment.Moment | undefined;
    remarks: string | undefined;
    from: string | undefined;
    openId: string | undefined;
}

export class AppointmentDto implements IAppointmentDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    storeId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    visitorCount!: number | undefined;
    companyName!: string | undefined;
    appointmentTime!: moment.Moment | undefined;
    remarks!: string | undefined;
    appointmentStatus!: AppointmentDtoAppointmentStatus | undefined;
    reason!: string | undefined;
    salesEngineerId!: number | undefined;
    from!: string | undefined;
    openId!: string | undefined;
    memberId!: number | undefined;

    constructor(data?: IAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.storeId = data["storeId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.visitorCount = data["visitorCount"];
            this.companyName = data["companyName"];
            this.appointmentTime = data["appointmentTime"] ? moment(data["appointmentTime"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
            this.appointmentStatus = data["appointmentStatus"];
            this.reason = data["reason"];
            this.salesEngineerId = data["salesEngineerId"];
            this.from = data["from"];
            this.openId = data["openId"];
            this.memberId = data["memberId"];
        }
    }

    static fromJS(data: any): AppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["storeId"] = this.storeId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["visitorCount"] = this.visitorCount;
        data["companyName"] = this.companyName;
        data["appointmentTime"] = this.appointmentTime ? this.appointmentTime.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["appointmentStatus"] = this.appointmentStatus;
        data["reason"] = this.reason;
        data["salesEngineerId"] = this.salesEngineerId;
        data["from"] = this.from;
        data["openId"] = this.openId;
        data["memberId"] = this.memberId;
        return data; 
    }
}

export interface IAppointmentDto {
    id: number | undefined;
    tenantId: number | undefined;
    storeId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    visitorCount: number | undefined;
    companyName: string | undefined;
    appointmentTime: moment.Moment | undefined;
    remarks: string | undefined;
    appointmentStatus: AppointmentDtoAppointmentStatus | undefined;
    reason: string | undefined;
    salesEngineerId: number | undefined;
    from: string | undefined;
    openId: string | undefined;
    memberId: number | undefined;
}

export class AuditAppointmentInput implements IAuditAppointmentInput {
    id!: number | undefined;
    targetStatus!: AuditAppointmentInputTargetStatus | undefined;

    constructor(data?: IAuditAppointmentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.targetStatus = data["targetStatus"];
        }
    }

    static fromJS(data: any): AuditAppointmentInput {
        data = typeof data === 'object' ? data : {};
        let result = new AuditAppointmentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["targetStatus"] = this.targetStatus;
        return data; 
    }
}

export interface IAuditAppointmentInput {
    id: number | undefined;
    targetStatus: AuditAppointmentInputTargetStatus | undefined;
}

export class PageExtrasDto implements IPageExtrasDto {
    id!: number | undefined;
    tenantId!: number | undefined;
    applicationName!: string | undefined;
    pageName!: string | undefined;
    productId!: number | undefined;
    skuId!: number | undefined;
    deviceActivityGameId!: number | undefined;
    salesId!: number | undefined;
    snsUserInfo!: SnsUserInfo | undefined;
    description!: string | undefined;
    extensionData!: string | undefined;

    constructor(data?: IPageExtrasDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.applicationName = data["applicationName"];
            this.pageName = data["pageName"];
            this.productId = data["productId"];
            this.skuId = data["skuId"];
            this.deviceActivityGameId = data["deviceActivityGameId"];
            this.salesId = data["salesId"];
            this.snsUserInfo = data["snsUserInfo"] ? SnsUserInfo.fromJS(data["snsUserInfo"]) : <any>undefined;
            this.description = data["description"];
            this.extensionData = data["extensionData"];
        }
    }

    static fromJS(data: any): PageExtrasDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageExtrasDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["applicationName"] = this.applicationName;
        data["pageName"] = this.pageName;
        data["productId"] = this.productId;
        data["skuId"] = this.skuId;
        data["deviceActivityGameId"] = this.deviceActivityGameId;
        data["salesId"] = this.salesId;
        data["snsUserInfo"] = this.snsUserInfo ? this.snsUserInfo.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["extensionData"] = this.extensionData;
        return data; 
    }
}

export interface IPageExtrasDto {
    id: number | undefined;
    tenantId: number | undefined;
    applicationName: string | undefined;
    pageName: string | undefined;
    productId: number | undefined;
    skuId: number | undefined;
    deviceActivityGameId: number | undefined;
    salesId: number | undefined;
    snsUserInfo: SnsUserInfo | undefined;
    description: string | undefined;
    extensionData: string | undefined;
}

export class SnsUserInfo implements ISnsUserInfo {
    id!: number | undefined;
    tenantId!: number | undefined;
    snsAppID!: string | undefined;
    subscribe!: number | undefined;
    openid!: string | undefined;
    nickname!: string | undefined;
    sex!: number | undefined;
    language!: string | undefined;
    city!: string | undefined;
    province!: string | undefined;
    country!: string | undefined;
    headimgurl!: string | undefined;
    subscribeTime!: moment.Moment | undefined;
    unSubScribeTime!: moment.Moment | undefined;
    unionid!: string | undefined;
    remark!: string | undefined;
    weixinGroupid!: number | undefined;
    memberId!: number | undefined;
    name!: string | undefined;
    phone!: string | undefined;
    identityID!: string | undefined;
    snsType!: SnsUserInfoSnsType | undefined;
    isFaceMember!: boolean | undefined;
    faceMemberId!: string | undefined;
    faceUrl!: string | undefined;

    constructor(data?: ISnsUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenantId = data["tenantId"];
            this.snsAppID = data["snsAppID"];
            this.subscribe = data["subscribe"];
            this.openid = data["openid"];
            this.nickname = data["nickname"];
            this.sex = data["sex"];
            this.language = data["language"];
            this.city = data["city"];
            this.province = data["province"];
            this.country = data["country"];
            this.headimgurl = data["headimgurl"];
            this.subscribeTime = data["subscribeTime"] ? moment(data["subscribeTime"].toString()) : <any>undefined;
            this.unSubScribeTime = data["unSubScribeTime"] ? moment(data["unSubScribeTime"].toString()) : <any>undefined;
            this.unionid = data["unionid"];
            this.remark = data["remark"];
            this.weixinGroupid = data["weixinGroupid"];
            this.memberId = data["memberId"];
            this.name = data["name"];
            this.phone = data["phone"];
            this.identityID = data["identityID"];
            this.snsType = data["snsType"];
            this.isFaceMember = data["isFaceMember"];
            this.faceMemberId = data["faceMemberId"];
            this.faceUrl = data["faceUrl"];
        }
    }

    static fromJS(data: any): SnsUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SnsUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["snsAppID"] = this.snsAppID;
        data["subscribe"] = this.subscribe;
        data["openid"] = this.openid;
        data["nickname"] = this.nickname;
        data["sex"] = this.sex;
        data["language"] = this.language;
        data["city"] = this.city;
        data["province"] = this.province;
        data["country"] = this.country;
        data["headimgurl"] = this.headimgurl;
        data["subscribeTime"] = this.subscribeTime ? this.subscribeTime.toISOString() : <any>undefined;
        data["unSubScribeTime"] = this.unSubScribeTime ? this.unSubScribeTime.toISOString() : <any>undefined;
        data["unionid"] = this.unionid;
        data["remark"] = this.remark;
        data["weixinGroupid"] = this.weixinGroupid;
        data["memberId"] = this.memberId;
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["identityID"] = this.identityID;
        data["snsType"] = this.snsType;
        data["isFaceMember"] = this.isFaceMember;
        data["faceMemberId"] = this.faceMemberId;
        data["faceUrl"] = this.faceUrl;
        return data; 
    }
}

export interface ISnsUserInfo {
    id: number | undefined;
    tenantId: number | undefined;
    snsAppID: string | undefined;
    subscribe: number | undefined;
    openid: string | undefined;
    nickname: string | undefined;
    sex: number | undefined;
    language: string | undefined;
    city: string | undefined;
    province: string | undefined;
    country: string | undefined;
    headimgurl: string | undefined;
    subscribeTime: moment.Moment | undefined;
    unSubScribeTime: moment.Moment | undefined;
    unionid: string | undefined;
    remark: string | undefined;
    weixinGroupid: number | undefined;
    memberId: number | undefined;
    name: string | undefined;
    phone: string | undefined;
    identityID: string | undefined;
    snsType: SnsUserInfoSnsType | undefined;
    isFaceMember: boolean | undefined;
    faceMemberId: string | undefined;
    faceUrl: string | undefined;
}

export class AddMarketDataInput implements IAddMarketDataInput {
    openId!: string | undefined;
    comment!: string | undefined;
    action!: string | undefined;
    from!: string | undefined;
    salesId!: string | undefined;
    collectionStartTime!: moment.Moment | undefined;
    collectionEndTime!: moment.Moment | undefined;
    increment!: number | undefined;
    residenceTime!: number | undefined;
    url!: string | undefined;

    constructor(data?: IAddMarketDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.comment = data["comment"];
            this.action = data["action"];
            this.from = data["from"];
            this.salesId = data["salesId"];
            this.collectionStartTime = data["collectionStartTime"] ? moment(data["collectionStartTime"].toString()) : <any>undefined;
            this.collectionEndTime = data["collectionEndTime"] ? moment(data["collectionEndTime"].toString()) : <any>undefined;
            this.increment = data["increment"];
            this.residenceTime = data["residenceTime"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): AddMarketDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddMarketDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["comment"] = this.comment;
        data["action"] = this.action;
        data["from"] = this.from;
        data["salesId"] = this.salesId;
        data["collectionStartTime"] = this.collectionStartTime ? this.collectionStartTime.toISOString() : <any>undefined;
        data["collectionEndTime"] = this.collectionEndTime ? this.collectionEndTime.toISOString() : <any>undefined;
        data["increment"] = this.increment;
        data["residenceTime"] = this.residenceTime;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAddMarketDataInput {
    openId: string | undefined;
    comment: string | undefined;
    action: string | undefined;
    from: string | undefined;
    salesId: string | undefined;
    collectionStartTime: moment.Moment | undefined;
    collectionEndTime: moment.Moment | undefined;
    increment: number | undefined;
    residenceTime: number | undefined;
    url: string | undefined;
}

export class AddOrUpdateRequirementInput implements IAddOrUpdateRequirementInput {
    name!: string | undefined;
    tel!: string | undefined;
    company!: string | undefined;
    openId!: string | undefined;
    description!: string | undefined;
    from!: string | undefined;

    constructor(data?: IAddOrUpdateRequirementInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.tel = data["tel"];
            this.company = data["company"];
            this.openId = data["openId"];
            this.description = data["description"];
            this.from = data["from"];
        }
    }

    static fromJS(data: any): AddOrUpdateRequirementInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddOrUpdateRequirementInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tel"] = this.tel;
        data["company"] = this.company;
        data["openId"] = this.openId;
        data["description"] = this.description;
        data["from"] = this.from;
        return data; 
    }
}

export interface IAddOrUpdateRequirementInput {
    name: string | undefined;
    tel: string | undefined;
    company: string | undefined;
    openId: string | undefined;
    description: string | undefined;
    from: string | undefined;
}

export class PagedResultDtoOfGetRequirementsDto implements IPagedResultDtoOfGetRequirementsDto {
    totalCount!: number | undefined;
    items!: GetRequirementsDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRequirementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRequirementsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRequirementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRequirementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRequirementsDto {
    totalCount: number | undefined;
    items: GetRequirementsDto[] | undefined;
}

export class GetRequirementsDto implements IGetRequirementsDto {
    id!: number | undefined;
    name!: string | undefined;
    tel!: string | undefined;
    company!: string | undefined;
    description!: string | undefined;
    openId!: string | undefined;
    handled!: boolean | undefined;
    handleContent!: string | undefined;
    applicationId!: number | undefined;
    applicationName!: string | undefined;

    constructor(data?: IGetRequirementsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.tel = data["tel"];
            this.company = data["company"];
            this.description = data["description"];
            this.openId = data["openId"];
            this.handled = data["handled"];
            this.handleContent = data["handleContent"];
            this.applicationId = data["applicationId"];
            this.applicationName = data["applicationName"];
        }
    }

    static fromJS(data: any): GetRequirementsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRequirementsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["tel"] = this.tel;
        data["company"] = this.company;
        data["description"] = this.description;
        data["openId"] = this.openId;
        data["handled"] = this.handled;
        data["handleContent"] = this.handleContent;
        data["applicationId"] = this.applicationId;
        data["applicationName"] = this.applicationName;
        return data; 
    }
}

export interface IGetRequirementsDto {
    id: number | undefined;
    name: string | undefined;
    tel: string | undefined;
    company: string | undefined;
    description: string | undefined;
    openId: string | undefined;
    handled: boolean | undefined;
    handleContent: string | undefined;
    applicationId: number | undefined;
    applicationName: string | undefined;
}

export class HandleRequirementsInput implements IHandleRequirementsInput {
    ids!: number[] | undefined;
    handleContent!: string | undefined;

    constructor(data?: IHandleRequirementsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["ids"])) {
                this.ids = [] as any;
                for (let item of data["ids"])
                    this.ids!.push(item);
            }
            this.handleContent = data["handleContent"];
        }
    }

    static fromJS(data: any): HandleRequirementsInput {
        data = typeof data === 'object' ? data : {};
        let result = new HandleRequirementsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["handleContent"] = this.handleContent;
        return data; 
    }
}

export interface IHandleRequirementsInput {
    ids: number[] | undefined;
    handleContent: string | undefined;
}

export class VisitorInfoDto implements IVisitorInfoDto {
    recentVisitors!: NameValueDto[] | undefined;
    visitorCount!: number | undefined;

    constructor(data?: IVisitorInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["recentVisitors"])) {
                this.recentVisitors = [] as any;
                for (let item of data["recentVisitors"])
                    this.recentVisitors!.push(NameValueDto.fromJS(item));
            }
            this.visitorCount = data["visitorCount"];
        }
    }

    static fromJS(data: any): VisitorInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new VisitorInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recentVisitors)) {
            data["recentVisitors"] = [];
            for (let item of this.recentVisitors)
                data["recentVisitors"].push(item.toJSON());
        }
        data["visitorCount"] = this.visitorCount;
        return data; 
    }
}

export interface IVisitorInfoDto {
    recentVisitors: NameValueDto[] | undefined;
    visitorCount: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class RecentActionDto implements IRecentActionDto {
    recordTime!: moment.Moment | undefined;
    name!: string | undefined;
    headImageUrl!: string | undefined;
    description!: string | undefined;

    constructor(data?: IRecentActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.recordTime = data["recordTime"] ? moment(data["recordTime"].toString()) : <any>undefined;
            this.name = data["name"];
            this.headImageUrl = data["headImageUrl"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): RecentActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecentActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recordTime"] = this.recordTime ? this.recordTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["headImageUrl"] = this.headImageUrl;
        data["description"] = this.description;
        return data; 
    }
}

export interface IRecentActionDto {
    recordTime: moment.Moment | undefined;
    name: string | undefined;
    headImageUrl: string | undefined;
    description: string | undefined;
}

export enum AppointmentDtoAppointmentStatus {
    Applied = "Applied",
    Cancel = "Cancel",
    Accepted = "Accepted",
    Rejected = "Rejected",
    Completed = "Completed",
}

export enum AuditAppointmentInputTargetStatus {
    Applied = "Applied",
    Cancel = "Cancel",
    Accepted = "Accepted",
    Rejected = "Rejected",
    Completed = "Completed",
}

export enum SnsUserInfoSnsType {
    Taobao = "Taobao",
    WeChat = "WeChat",
    Others = "Others",
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}